Categories: physics.gen-ph
Abstract: The evolution of Earth-Moon system is described by the dark matter field
fluid model proposed in the Meeting of Division of Particle and Field 2004,
American Physical Society. The current behavior of the Earth-Moon system agrees
with this model very well and the general pattern of the evolution of the
Moon-Earth system described by this model agrees with geological and fossil
evidence. The closest distance of the Moon to Earth was about 259000 km at 4.5
billion years ago, which is far beyond the Roche's limit. The result suggests
that the tidal friction may not be the primary cause for the evolution of the
Earth-Moon system. The average dark matter field fluid constant derived from
Earth-Moon system data is 4.39 x 10^(-22) s^(-1)m^(-1). This model predicts
that the Mars's rotation is also slowing with the angular acceleration rate
about -4.38 x 10^(-22) rad s^(-2).

Categories: nlin.PS, physics.chem-ph, q-bio.MN
Abstract: Spatiotemporal pattern formation in a product-activated enzymic reaction at
high enzyme concentrations is investigated. Stochastic simulations show that
catalytic turnover cycles of individual enzymes can become coherent and that
complex wave patterns of molecular synchronization can develop. The analysis
based on the mean-field approximation indicates that the observed patterns
result from the presence of Hopf and wave bifurcations in the considered
system.

Categories: physics.optics, physics.comp-ph
Abstract: We performed a rigorous theoretical convergence analysis of the discrete
dipole approximation (DDA). We prove that errors in any measured quantity are
bounded by a sum of a linear and quadratic term in the size of a dipole d, when
the latter is in the range of DDA applicability. Moreover, the linear term is
significantly smaller for cubically than for non-cubically shaped scatterers.
Therefore, for small d errors for cubically shaped particles are much smaller
than for non-cubically shaped. The relative importance of the linear term
decreases with increasing size, hence convergence of DDA for large enough
scatterers is quadratic in the common range of d. Extensive numerical
simulations were carried out for a wide range of d. Finally we discuss a number
of new developments in DDA and their consequences for convergence.

Categories: physics.optics, physics.comp-ph
Abstract: We propose an extrapolation technique that allows accuracy improvement of the
discrete dipole approximation computations. The performance of this technique
was studied empirically based on extensive simulations for 5 test cases using
many different discretizations. The quality of the extrapolation improves with
refining discretization reaching extraordinary performance especially for
cubically shaped particles. A two order of magnitude decrease of error was
demonstrated. We also propose estimates of the extrapolation error, which were
proven to be reliable. Finally we propose a simple method to directly separate
shape and discretization errors and illustrated this for one test case.

Categories: physics.optics, physics.comp-ph
Abstract: In this manuscript we investigate the capabilities of the Discrete Dipole
Approximation (DDA) to simulate scattering from particles that are much larger
than the wavelength of the incident light, and describe an optimized publicly
available DDA computer program that processes the large number of dipoles
required for such simulations. Numerical simulations of light scattering by
spheres with size parameters x up to 160 and 40 for refractive index m=1.05 and
2 respectively are presented and compared with exact results of the Mie theory.
Errors of both integral and angle-resolved scattering quantities generally
increase with m and show no systematic dependence on x. Computational times
increase steeply with both x and m, reaching values of more than 2 weeks on a
cluster of 64 processors. The main distinctive feature of the computer program
is the ability to parallelize a single DDA simulation over a cluster of
computers, which allows it to simulate light scattering by very large
particles, like the ones that are considered in this manuscript. Current
limitations and possible ways for improvement are discussed.

Categories: physics.optics, physics.comp-ph
Abstract: We present a review of the discrete dipole approximation (DDA), which is a
general method to simulate light scattering by arbitrarily shaped particles. We
put the method in historical context and discuss recent developments, taking
the viewpoint of a general framework based on the integral equations for the
electric field. We review both the theory of the DDA and its numerical aspects,
the latter being of critical importance for any practical application of the
method. Finally, the position of the DDA among other methods of light
scattering simulation is shown and possible future developments are discussed.

Categories: physics.gen-ph, quant-ph
Abstract: It is outlined the possibility to extend the quantum formalism in relation to
the requirements of the general systems theory. It can be done by using a
quantum semantics arising from the deep logical structure of quantum theory. It
is so possible taking into account the logical openness relationship between
observer and system. We are going to show how considering the truth-values of
quantum propositions within the context of the fuzzy sets is here more useful
for systemics . In conclusion we propose an example of formal quantum
coherence.

Categories: astro-ph, nlin.CD, physics.plasm-ph, physics.space-ph
Abstract: We present a theoretical framework for plasma turbulence in astrophysical
plasmas (solar wind, interstellar medium, galaxy clusters, accretion disks).
The key assumptions are that the turbulence is anisotropic with respect to the
mean magnetic field and frequencies are low compared to the ion cyclotron
frequency. The energy injected at the outer scale scale has to be converted
into heat, which ultimately cannot be done without collisions. A KINETIC
CASCADE develops that brings the energy to collisional scales both in space and
velocity. Its nature depends on the physics of plasma fluctuations. In each of
the physically distinct scale ranges, the kinetic problem is systematically
reduced to a more tractable set of equations. In the "inertial range" above the
ion gyroscale, the kinetic cascade splits into a cascade of Alfvenic
fluctuations, which are governed by the RMHD equations at both the collisional
and collisionless scales, and a passive cascade of compressive fluctuations,
which obey a linear kinetic equation along the moving field lines associated
with the Alfvenic component. In the "dissipation range" between the ion and
electron gyroscales, there are again two cascades: the kinetic-Alfven-wave
(KAW) cascade governed by two fluid-like Electron RMHD equations and a passive
phase-space cascade of ion entropy fluctuations. The latter cascade brings the
energy of the inertial-range fluctuations that was damped by collisionless
wave-particle interaction at the ion gyroscale to collisional scales in the
phase space and leads to ion heating. The KAW energy is similarly damped at the
electron gyroscale and converted into electron heat. Kolmogorov-style scaling
relations are derived for these cascades. Astrophysical and space-physical
applications are discussed in detail.

Categories: physics.ed-ph, quant-ph
Abstract: A novel way of picturing the processing of quantum information is described,
allowing a direct visualization of teleportation of quantum states and
providing a simple and intuitive understanding of this fascinating phenomenon.
The discussion is aimed at providing physicists a method of explaining
teleportation to non-scientists. The basic ideas of quantum physics are first
explained in lay terms, after which these ideas are used with a graphical
description, out of which teleportation arises naturally.

Categories: physics.pop-ph
Abstract: I shall present three arguments for the proposition that intelligent life is
very rare in the universe. First, I shall summarize the consensus opinion of
the founders of the Modern Synthesis (Simpson, Dobzhanski, and Mayr) that the
evolution of intelligent life is exceedingly improbable. Second, I shall
develop the Fermi Paradox: if they existed they'd be here. Third, I shall show
that if intelligent life were too common, it would use up all available
resources and die out. But I shall show that the quantum mechanical principle
of unitarity (actually a form of teleology!) requires intelligent life to
survive to the end of time. Finally, I shall argue that, if the universe is
indeed accelerating, then survival to the end of time requires that intelligent
life, though rare, to have evolved several times in the visible universe. I
shall argue that the acceleration is a consequence of the excess of matter over
antimatter in the universe. I shall suggest experiments to test these claims.

Categories: physics.soc-ph
Abstract: No abstract given; compares pairs of languages from World Atlas of Language
Structures.

Categories: physics.gen-ph
Abstract: The Dark Energy problem is forcing us to re-examine our models and our
understanding of relativity and space-time. Here a novel idea of Fundamental
Forces is introduced. This allows us to perceive the General Theory of
Relativity and Einstein's Equation from a new pesrpective. In addition to
providing us with an improved understanding of space and time, it will be shown
how it leads to a resolution of the Dark Energy problem.

Categories: cond-mat.soft, nlin.PS, physics.flu-dyn
Abstract: We employ granular hydrodynamics to investigate a paradigmatic problem of
clustering of particles in a freely cooling dilute granular gas. We consider
large-scale hydrodynamic motions where the viscosity and heat conduction can be
neglected, and one arrives at the equations of ideal gas dynamics with an
additional term describing bulk energy losses due to inelastic collisions. We
employ Lagrangian coordinates and derive a broad family of exact non-stationary
analytical solutions that depend only on one spatial coordinate. These
solutions exhibit a new type of singularity, where the gas density blows up in
a finite time when starting from smooth initial conditions. The density blowups
signal formation of close-packed clusters of particles. As the density blow-up
time $t_c$ is approached, the maximum density exhibits a power law $\sim
(t_c-t)^{-2}$. The velocity gradient blows up as $\sim - (t_c-t)^{-1}$ while
the velocity itself remains continuous and develops a cusp (rather than a shock
discontinuity) at the singularity. The gas temperature vanishes at the
singularity, and the singularity follows the isobaric scenario: the gas
pressure remains finite and approximately uniform in space and constant in time
close to the singularity. An additional exact solution shows that the density
blowup, of the same type, may coexist with an "ordinary" shock, at which the
hydrodynamic fields are discontinuous but finite. We confirm stability of the
exact solutions with respect to small one-dimensional perturbations by solving
the ideal hydrodynamic equations numerically. Furthermore, numerical solutions
show that the local features of the density blowup hold universally,
independently of details of the initial and boundary conditions.

Categories: physics.optics
Abstract: The results of the spectral, energetical and temporal characteristics of
radiation in the presence of the photonic flame effect are presented.
Artificial opal posed on Cu plate at the temperature of liquid nitrogen boiling
point (77 K) being irradiated by nanosecond ruby laser pulse produces long-
term luminiscence with a duration till ten seconds with a finely structured
spectrum in the the antistocks part of the spectrum. Analogous visible
luminescence manifesting time delay appeared in other samples of the artificial
opals posed on the same plate. In the case of the opal infiltrated with
different nonlinear liquids the threshold of the luminiscence is reduced and
the spatial disribution of the bright emmiting area on the opal surface is
being changed. In the case of the putting the frozen nonlinear liquids on the
Cu plate long-term blue bright luminiscence took place in the frozen species of
the liquids. Temporal characteristics of this luminiscence are nearly the same
as in opal matrixes.

Categories: physics.data-an, physics.gen-ph
Abstract: Statistical modeling of experimental physical laws is based on the
probability density function of measured variables. It is expressed by
experimental data via a kernel estimator. The kernel is determined objectively
by the scattering of data during calibration of experimental setup. A physical
law, which relates measured variables, is optimally extracted from experimental
data by the conditional average estimator. It is derived directly from the
kernel estimator and corresponds to a general nonparametric regression. The
proposed method is demonstrated by the modeling of a return map of noisy
chaotic data. In this example, the nonparametric regression is used to predict
a future value of chaotic time series from the present one. The mean predictor
error is used in the definition of predictor quality, while the redundancy is
expressed by the mean square distance between data points. Both statistics are
used in a new definition of predictor cost function. From the minimum of the
predictor cost function, a proper number of data in the model is estimated.

Categories: cs.CE, cond-mat.stat-mech, cs.MS, cs.NA, physics.data-an
Abstract: Real Options for Project Schedules (ROPS) has three recursive
sampling/optimization shells. An outer Adaptive Simulated Annealing (ASA)
optimization shell optimizes parameters of strategic Plans containing multiple
Projects containing ordered Tasks. A middle shell samples probability
distributions of durations of Tasks. An inner shell samples probability
distributions of costs of Tasks. PATHTREE is used to develop options on
schedules.. Algorithms used for Trading in Risk Dimensions (TRD) are applied to
develop a relative risk analysis among projects.

Categories: physics.data-an
Abstract: A physical law is represented by the probability distribution of a measured
variable. The probability density is described by measured data using an
estimator whose kernel is the instrument scattering function. The experimental
information and data redundancy are defined in terms of information entropy.
The model cost function, comprised of data redundancy and estimation error, is
minimized by the creation-annihilation process.

Categories: nlin.CD, cond-mat.other, physics.optics
Abstract: The microwave phonon stimulated emission (SE) has been experimentally and
numerically investigated in a nonautonomous microwave acoustic quantum
generator, called also microwave phonon laser or phaser (see previous works
arXiv:cond-mat/0303188 ; arXiv:cond-mat/0402640 ; arXiv:nlin.CG/0703050)
Phenomena of branching and long-time refractority (absence of the reaction on
the external pulses) for deterministic chaotic and regular processes of SE were
observed in experiments with various levels of electromagnetic pumping. At the
pumping level growth, the clearly depined increasing of the number of
coexisting SE states has been observed both in real physical experiments and in
computer simulations. This confirms the analytical estimations of the branching
density in the phase space. The nature of the refractority of SE pulses is
closely connected with the pointed branching and reflects the crises of strange
attractors, i.e. their collisions with unstable periodic components of the
higher branches of SE states in the nonautonomous microwave phonon laser.

Categories: physics.gen-ph
Abstract: Based on overall experimental observations, especially the pair processes, I
developed a model structure of the vacuum along with a basic-particle formation
scheme begun in 2000 (with collaborator P-I Johansson). The model consists in
that the vacuum is, briefly, filled of neutral but polarizable vacuuons,
consisting each of a p-vaculeon and n- vaculeon of charges $+e$ and $-e$ of
zero rest masses but with spin motions, assumed interacting each other with a
Coulomb force. The model has been introduced in full in a book (Nova Sci, 2005)
and referred to in a number of journal/E-print papers. I outline in this easier
accessible paper the detailed derivation of the model and a corresponding
quantitative determination of the vacuuon size.

Categories: physics.gen-ph
Abstract: The 32-dimensional compounding fields and their quantum interplays in the
trigintaduonion space can be presented by analogy with octonion and sedenion
electromagnetic, gravitational, strong and weak interactions. In the
trigintaduonion fields which are associated with the electromagnetic,
gravitational, strong and weak interactions, the study deduces some conclusions
of field source particles (quarks and leptons) and intermediate particles which
are consistent with current some sorts of interaction theories. In the
trigintaduonion fields which are associated with the hyper-strong and
strong-weak fields, the paper draws some predicts and conclusions of the field
source particles (sub-quarks) and intermediate particles. The research results
show that there may exist some new particles in the nature.

Categories: physics.optics, physics.class-ph, quant-ph
Abstract: Statistical ensemble formalism of Kim, Mandel and Wolf (J. Opt. Soc. Am. A 4,
433 (1987)) offers a realistic model for characterizing the effect of
stochastic non-image forming optical media on the state of polarization of
transmittedlight. With suitable choice of the Jones ensemble, various Mueller
transformations - some of which have been unknown so far - are deduced. It is
observed that the ensemble approach is formally identical to the positive
operator valued measures (POVM) on the quantum density matrix. This
observation, in combination with the recent suggestion by Ahnert and Payne
(Phys. Rev. A 71, 012330, (2005)) - in the context of generalized quantum
measurement on single photon polarization states - that linear optics elements
can be employed in setting up all possible POVMs, enables us to propose a way
of realizing different types of Mueller devices.

Categories: physics.data-an, physics.comp-ph
Abstract: The extraction of a physical law y=yo(x) from joint experimental data about x
and y is treated. The joint, the marginal and the conditional probability
density functions (PDF) are expressed by given data over an estimator whose
kernel is the instrument scattering function. As an optimal estimator of yo(x)
the conditional average is proposed. The analysis of its properties is based
upon a new definition of prediction quality. The joint experimental information
and the redundancy of joint measurements are expressed by the relative entropy.
With the number of experiments the redundancy on average increases, while the
experimental information converges to a certain limit value. The difference
between this limit value and the experimental information at a finite number of
data represents the discrepancy between the experimentally determined and the
true properties of the phenomenon. The sum of the discrepancy measure and the
redundancy is utilized as a cost function. By its minimum a reasonable number
of data for the extraction of the law yo(x) is specified. The mutual
information is defined by the marginal and the conditional PDFs of the
variables. The ratio between mutual information and marginal information is
used to indicate which variable is the independent one. The properties of the
introduced statistics are demonstrated on deterministically and randomly
related variables.

Categories: physics.gen-ph
Abstract: Classical oscillator differential equation is replaced by the corresponding
(finite time) difference equation. The equation is, then, symmetrized so that
it remains invariant under the change d going to -d, where d is the smallest
span of time. This symmetric equation has solutions, which come in reciprocally
related pairs. One member of a pair agrees with the classical solution and the
other is an oscillating solution and does not converge to a limit as d goes to
0. This solution contributes to oscillator energy a term which is a multiple of
half-integers.

Categories: cond-mat.stat-mech, cond-mat.soft, physics.chem-ph
Abstract: An overview of some analytical approaches to the computation of the
structural and thermodynamic properties of single component and multicomponent
hard-sphere fluids is provided. For the structural properties, they yield a
thermodynamically consistent formulation, thus improving and extending the
known analytical results of the Percus-Yevick theory. Approximate expressions
for the contact values of the radial distribution functions and the
corresponding analytical equations of state are also discussed. Extensions of
this methodology to related systems, such as sticky hard spheres and
square-well fluids, as well as its use in connection with the perturbation
theory of fluids are briefly addressed.

Categories: physics.data-an, physics.comp-ph
Abstract: Redundancy of experimental data is the basic statistic from which the
complexity of a natural phenomenon and the proper number of experiments needed
for its exploration can be estimated. The redundancy is expressed by the
entropy of information pertaining to the probability density function of
experimental variables. Since the calculation of entropy is inconvenient due to
integration over a range of variables, an approximate expression for redundancy
is derived that includes only a sum over the set of experimental data about
these variables. The approximation makes feasible an efficient estimation of
the redundancy of data along with the related experimental information and
information cost function. From the experimental information the complexity of
the phenomenon can be simply estimated, while the proper number of experiments
needed for its exploration can be determined from the minimum of the cost
function. The performance of the approximate estimation of these statistics is
demonstrated on two-dimensional normally distributed random data.

Categories: physics.optics
Abstract: Using the recently reported mode locking effect we demonstrate a highly
robust control of electron spin coherence in an ensemble of (In,Ga)As quantum
dots during the single spin coherence time. The spin precession in a transverse
magnetic field can be fully controlled up to 25 K by the parameters of the
exciting pulsed laser protocol such as the pulse train sequence, leading to
adjustable quantum beat bursts in Faraday rotation. Flipping of the electron
spin precession phase was demonstrated by inverting the polarization within a
pulse doublet sequence.

Categories: physics.plasm-ph
Abstract: We calculate the equation of state of dense hydrogen within the chemical
picture. Fluid variational theory is generalized for a multi-component system
of molecules, atoms, electrons, and protons. Chemical equilibrium is supposed
for the reactions dissociation and ionization. We identify the region of
thermodynamic instability which is related to the plasma phase transition. The
reflectivity is calculated along the Hugoniot curve and compared with
experimental results. The equation-of-state data is used to calculate the
pressure and temperature profiles for the interior of Jupiter.

Categories: physics.optics, physics.comp-ph
Abstract: We investigate the use of a Genetic Algorithm (GA) to design a set of
photonic crystals (PCs) in one and two dimensions. Our flexible design
methodology allows us to optimize PC structures which are optimized for
specific objectives. In this paper, we report the results of several such
GA-based PC optimizations. We show that the GA performs well even in very
complex design spaces, and therefore has great potential for use as a robust
design tool in present and future applications.

Categories: physics.bio-ph, physics.data-an, q-bio.BM
Abstract: A number of recently discovered protein structures incorporate a rather
unexpected structural feature: a knot in the polypeptide backbone. These knots
are extremely rare, but their occurrence is likely connected to protein
function in as yet unexplored fashion. Our analysis of the complete Protein
Data Bank reveals several new knots which, along with previously discovered
ones, can shed light on such connections. In particular, we identify the most
complex knot discovered to date in human ubiquitin hydrolase, and suggest that
its entangled topology protects it against unfolding and degradation by the
proteasome. Knots in proteins are typically preserved across species and
sometimes even across kingdoms. However, we also identify a knot which only
appears in some transcarbamylases while being absent in homologous proteins of
similar structure. The emergence of the knot is accompanied by a shift in the
enzymatic function of the protein. We suggest that the simple insertion of a
short DNA fragment into the gene may suffice to turn an unknotted into a
knotted structure in this protein.

Categories: physics.optics
Abstract: We theoretically investigate the possibility of observing resonant activation
in the hopping dynamics of two-mode semiconductor lasers. We present a series
of simulations of a rate-equations model under random and periodic modulation
of the bias current. In both cases, for an optimal choice of the modulation
time-scale, the hopping times between the stable lasing modes attain a minimum.
The simulation data are understood by means of an effective one-dimensional
Langevin equation with multiplicative fluctuations. Our conclusions apply to
both Edge Emitting and Vertical Cavity Lasers, thus opening the way to several
experimental tests in such optical systems.

Categories: physics.optics, math-ph, math.MP
Abstract: There is currently a great deal of interest in the theoretical and practical
possibility of cloaking objects from the observation by electromagnetic waves.
The basic idea of these invisibility devices \cite{glu1, glu2, le},\cite{pss1}
is to use anisotropic {\it transformation media} whose permittivity and
permeability $\var^{\lambda\nu}, \mu^{\lambda\nu}$, are obtained from the ones,
$\var_0^{\lambda\nu}, \mu^{\lambda\nu}_0$, of isotropic media, by singular
transformations of coordinates. In this paper we study electromagnetic cloaking
in the time-domain using the formalism of time-dependent scattering theory.
This formalism allows us to settle in an unambiguous way the mathematical
problems posed by the singularities of the inverse of the permittivity and the
permeability of the {\it transformation media} on the boundary of the cloaked
objects. We write Maxwell's equations in Schr\"odinger form with the
electromagnetic propagator playing the role of the Hamiltonian. We prove that
the electromagnetic propagator outside of the cloaked objects is essentially
self-adjoint. Moreover, the unique self-adjoint extension is unitarily
equivalent to the electromagnetic propagator in the medium
$\var_0^{\lambda\nu}, \mu^{\lambda\nu}_0$. Using this fact, and since the
coordinate transformation is the identity outside of a ball, we prove that the
scattering operator is the identity. Our results give a rigorous proof that the
construction of \cite{glu1, glu2, le}, \cite{pss1} perfectly cloaks passive and
active devices from observation by electromagnetic waves. Furthermore, we prove
cloaking for general anisotropic materials. In particular, our results prove
that it is possible to cloak objects inside general crystals.

Categories: physics.flu-dyn, physics.plasm-ph
Abstract: We study material lines and passive vectors in a model of turbulent flow at
infinite-Reynolds number, the Kraichnan-Kazantsev ensemble of velocities that
are white-noise in time and rough (Hoelder continuous) in space. It is argued
that the phenomenon of ``spontaneous stochasticity'' generalizes to material
lines and that conservation of circulations generalizes to a ``martingale
property'' of the stochastic process of lines.

Categories: physics.comp-ph
Abstract: We present a new version of TaylUR, a Fortran 95 module to automatically
compute the numerical values of a complex-valued function's derivatives with
respect to several variables up to an arbitrary order in each variable, but
excluding mixed derivatives. The new version fixes a potentially serious bug in
the code for exponential-related functions that could corrupt the imaginary
parts of derivatives, as well as being compatible with a wider range of
compilers.

Categories: physics.atom-ph, cond-mat.other
Abstract: We present experimental and theoretical results showing the improved beam
quality and reduced divergence of an atom laser produced by an optical Raman
transition, compared to one produced by an RF transition. We show that Raman
outcoupling can eliminate the diverging lens effect that the condensate has on
the outcoupled atoms. This substantially improves the beam quality of the atom
laser, and the improvement may be greater than a factor of ten for experiments
with tight trapping potentials. We show that Raman outcoupling can produce atom
lasers whose quality is only limited by the wavefunction shape of the
condensate that produces them, typically a factor of 1.3 above the Heisenberg
limit.

Categories: astro-ph, physics.ao-ph
Abstract: Air fluorescence detectors measure the energy of ultra-high energy cosmic
rays by collecting fluorescence light emitted from nitrogen molecules along the
extensive air shower cascade. To ensure a reliable energy determination, the
light signal needs to be corrected for atmospheric effects, which not only
attenuate the signal, but also produce a non-negligible background component
due to scattered Cherenkov light and multiple-scattered light. The correction
requires regular measurements of the aerosol attenuation length and the aerosol
phase function, defined as the probability of light scattered in a given
direction. At the Pierre Auger Observatory in Malargue, Argentina, the phase
function is measured on an hourly basis using two Aerosol Phase Function (APF)
light sources. These sources direct a UV light beam across the field of view of
the fluorescence detectors; the phase function can be extracted from the image
of the shots in the fluorescence detector cameras. This paper describes the
design, current status, standard operation procedure, and performance of the
APF system at the Pierre Auger Observatory.

Categories: physics.bio-ph
Abstract: We present a model for the spontaneous formation of a striated pattern in
polymerizing microtubule solutions. It describes the buckling of a single
microtubule (MT) bundle within an elastic network formed by other similarly
aligned and buckling bundles and unaligned MTs. Phase contrast and polarization
microscopy studies of the temporal evolution of the pattern imply that the
polymerization of MTs within the bundles creates the driving compressional
force. Using the measured rate of buckling, the established MT force-velocity
curve and the pattern wavelength, we obtain reasonable estimates for the MT
bundle bending rigidity and the elastic constant of the network. The analysis
implies that the bundles buckle as solid rods.

Categories: physics.soc-ph
Abstract: The ever-increasing knowledge of the structure of various real-world networks
has uncovered their complex multi-mechanism-governed evolution processes.
Therefore, a better understanding of the structure and evolution of these
networked complex systems requires us to describe such processes in a more
detailed and realistic manner. In this paper, we introduce a new type of
network growth rule which comprises addition and deletion of nodes, and propose
an evolving network model to investigate the effect of node deleting on network
structure. It is found that, with the introduction of node deleting, network
structure is significantly transformed. In particular, degree distribution of
the network undergoes a transition from scale-free to exponential forms as the
intensity of node deleting increases. At the same time, nontrivial
disassortative degree correlation develops spontaneously as a natural result of
network evolution in the model. We also demonstrate that node deleting
introduced in the model does not destroy the connectedness of a growing network
so long as the increasing rate of edges is not excessively small. In addition,
it is found that node deleting will weaken but not eliminate the small-world
effect of a growing network, and generally it will decrease the clustering
coefficient in a network.

Categories: cond-mat.stat-mech, physics.ins-det
Abstract: We report on measurements of the transverse fluctuations of a string in a
turbulent air jet flow. Harmonic modes are excited by the fluctuating drag
force, at different wave-numbers. This simple mechanical probe makes it
possible to measure excitations of the flow at specific scales, averaged over
space and time: it is a scale-resolved, global measurement. We also measure the
dissipation associated to the string motion, and we consider the ratio of the
fluctuations over dissipation (FDR). In an exploratory approach, we investigate
the concept of {\it effective temperature} defined through the FDR. We compare
our observations with other definitions of temperature in turbulence. From the
theory of Kolmogorov (1941), we derive the exponent -11/3 expected for the
spectrum of the fluctuations. This simple model and our experimental results
are in good agreement, over the range of wave-numbers, and Reynolds number
accessible ($74000 \leq Re \leq 170000$).

Categories: physics.chem-ph
Abstract: In line with the local philicity concept proposed by Chattaraj et al.
(Chattaraj, P. K.; Maiti, B.; Sarkar, U. J. Phys. Chem. A. 2003, 107, 4973) and
a dual descriptor derived by Toro-Labbe and coworkers (Morell, C.; Grand, A.;
Toro-Labbe, A. J. Phys. Chem. A. 2005, 109, 205), we propose a multiphilic
descriptor. It is defined as the difference between nucleophilic (Wk+) and
electrophilic (Wk-) condensed philicity functions. This descriptor is capable
of simultaneously explaining the nucleophilicity and electrophilicity of the
given atomic sites in the molecule. Variation of these quantities along the
path of a soft reaction is also analyzed. Predictive ability of this descriptor
has been successfully tested on the selected systems and reactions.
Corresponding force profiles are also analyzed in some representative cases.
Also, to study the intra- and intermolecular reactivities another related
descriptor namely, the nucleophilicity excess (DelW-+) for a nucleophile, over
the electrophilicity in it has been defined and tested on all-metal aromatic
compounds.

Categories: physics.flu-dyn, physics.comp-ph
Abstract: In spite of the large number of papers appeared in the past which are devoted
to the lattice Boltzmann (LB) methods, basic aspects of the theory still remain
unchallenged. An unsolved theoretical issue is related to the construction of a
discrete kinetic theory which yields \textit{exactly} the fluid equations,
i.e., is non-asymptotic (here denoted as \textit{LB inverse kinetic theory}).
The purpose of this paper is theoretical and aims at developing an inverse
kinetic approach of this type. In principle infinite solutions exist to this
problem but the freedom can be exploited in order to meet important
requirements. In particular, the discrete kinetic theory can be defined so that
it yields exactly the fluid equation also for arbitrary non-equilibrium (but
suitably smooth) kinetic distribution functions and arbitrarily close to the
boundary of the fluid domain. Unlike previous entropic LB methods the theorem
can be obtained without functional constraints on the class of the initial
distribution functions. Possible realizations of the theory and asymptotic
approximations are provided which permit to determine the fluid equations
\textit{with prescribed accuracy.} As a result, asymptotic accuracy estimates
of customary LB approaches and comparisons with the Chorin artificial
compressibility method are discussed.

Categories: physics.soc-ph
Abstract: We study numerically the cascading failure problem by using artificially
created scale-free networks and the real network structure of the power grid.
The capacity for a vertex is assigned as a monotonically increasing function of
the load (or the betweenness centrality). Through the use of a simple
functional form with two free parameters, revealed is that it is indeed
possible to make networks more robust while spending less cost. We suggest that
our method to prevent cascade by protecting less vertices is particularly
important for the design of more robust real-world networks to cascading
failures.

Categories: physics.gen-ph
Abstract: Ponderable objects moving in free space according to Newton's First Law
constitute both rulers and clocks when one such object is viewed from the rest
frame of another. Together with the Reciprocity Principle this is used to
demonstrate, in both Galilean and special relativity, the invariance of the
measured length of a ruler in motion. The different times: `proper', `improper'
and `apparent' appearing in different formulations of the relativistic time
dilatation relation are discussed and exemplified by experimental applications.
A non-intuitive `length expansion' effect predicted by the Reciprocity
Principle as a necessary consequence of time dilatation is pointed out

Categories: physics.geo-ph
Abstract: This paper has been withdrawn due to copyright reasons.

Categories: physics.chem-ph
Abstract: The structure of three laminar premixed rich flames has been investigated: a
pure methane flame and two methane flames doped by allene and propyne,
respectively. The gases of the three flames contain 20.9% (molar) of methane
and 33.4% of oxygen, corresponding to an equivalence ratio of 1.25 for the pure
methane flame. In both doped flames, 2.49% of C3H4 was added, corresponding to
a ratio C3H4/CH4 of 12% and an equivalence ratio of 1.55. The three flames have
been stabilized on a burner at a pressure of 6.7 kPa using argon as dilutant,
with a gas velocity at the burner of 36 cm/s at 333 K. The concentration
profiles of stable species were measured by gas chromatography after sampling
with a quartz microprobe. Quantified species included carbon monoxide and
dioxide, methane, oxygen, hydrogen, ethane, ethylene, acetylene, propyne,
allene, propene, propane, 1,2-butadiene, 1,3-butadiene, 1-butene, isobutene,
1-butyne, vinylacetylene, and benzene. The temperature was measured using a
PtRh (6%)-PtRh (30%) thermocouple settled inside the enclosure and ranged from
700 K close to the burner up to 1850 K. In order to model these new results,
some improvements have been made to a mechanism previously developed in our
laboratory for the reactions of C3-C4 unsaturated hydrocarbons. The main
reaction pathways of consumption of allene and propyne and of formation of C6
aromatic species have been derived from flow rate analyses.

Categories: q-bio.NC, cond-mat.dis-nn, physics.soc-ph
Abstract: Structure entails function and thus a structural description of the brain
will help to understand its function and may provide insights into many
properties of brain systems, from their robustness and recovery from damage, to
their dynamics and even their evolution. Advances in the analysis of complex
networks provide useful new approaches to understanding structural and
functional properties of brain networks. Structural properties of networks
recently described allow their characterization as small-world, random
(exponential) and scale-free. They complement the set of other properties that
have been explored in the context of brain connectivity, such as topology,
hodology, clustering, and hierarchical organization. Here we apply new network
analysis methods to cortical inter-areal connectivity networks for the cat and
macaque brains. We compare these corticocortical fibre networks to benchmark
rewired, small-world, scale-free and random networks, using two analysis
strategies, in which we measure the effects of the removal of nodes and
connections on the structural properties of the cortical networks. The brain
networks' structural decay is in most respects similar to that of scale-free
networks. The results implicate highly connected hub-nodes and bottleneck
connections as structural basis for some of the conditional robustness of brain
systems. This informs the understanding of the development of brain networks'
connectivity.

Categories: quant-ph, hep-th, nlin.CD, physics.atom-ph, physics.chem-ph
Abstract: We present an analytic example of two dimensional quantum mechanical system,
where the exponential suppression of the probability of over-barrier reflection
changes non-monotonically with energy. The suppression is minimal at certain
"optimal" energies where reflection occurs with exponentially larger
probability than at other energies.

Categories: physics.optics
Abstract: Using complex plane analysis we show that left-handed slab may support either
leaky slab waves, which are backward because of negative refraction, or leaky
surface waves, which are backward or forward depending on the propagation
direction of the surface wave itself. Moreover, there is a general connection
between the reflection coefficient of the left-handed slab and the one of the
corresponding right-handed slab (with opposite permittivity and permeability)
so that leaky slab modes are excited for the same angle of incidence of the
impinging beam for both structures. Many negative giant lateral shifts can be
explained by the excitation of these leaky modes.

Categories: physics.optics
Abstract: We experimentally demonstrate controlled polarization-selective phenomena in
a whispering gallery mode resonator. We observed efficient ($\approx 75 %$)
polarization conversion of light in a silica microsphere coupled to a tapered
optical fiber with proper optimization of the polarization of the propagating
light. A simple model treating the microsphere as a ring resonator provides a
good fit to the observed behavior.

Categories: physics.chem-ph, physics.flu-dyn
Abstract: We report a new effect of surfactants in pinning a drop contact line,
specifically that lysozyme promotes while lauryl sulfate inhibits pinning. We
explain the pinning disparity assuming difference in wetting: the protein-laden
drop wets a "clean" surface and the surfactant-laden drop wets an
auto-precursored surface.

Categories: physics.gen-ph
Abstract: How to effectively solve the eigen solutions of the nonlinear spinor field
equation coupling with some other interaction fields is important to understand
the behavior of the elementary particles. In this paper, we derive a simplified
form of the eigen equation of the nonlinear spinor, and then propose a scheme
to solve their numerical solutions. This simplified equation has elegant and
neat structure, which is more convenient for both theoretical analysis and
numerical computation.

Categories: physics.optics, physics.gen-ph, quant-ph
Abstract: We show that two distinct quantum states of the electromagnetic field can be
associated to a classical vector X wave or a propagation-invariant solution of
Maxwell equations. The difference between the two states is of pure quantum
mechanical origin since they are internally entangled and disentangled,
respectively and can be generated by different linear or nonlinear processes.
Detection and generation of Schr\"odinger-cat states comprising two entangled
X-waves and their possible applications are discussed.

Categories: physics.ed-ph, physics.gen-ph
Abstract: We measured the correlation of the times between successive flaps of a flag
for a variety of wind speeds and found no evidence of low dimensional chaotic
behavior in the return maps of these times. We instead observed what is best
modeled as random times determined by an exponential distribution. This study
was done as an undergraduate experiment and illustrates the differences between
low dimensional chaotic and possibly higher dimensional chaotic systems.

Categories: physics.gen-ph
Abstract: Because observations of galaxies and clusters have been found inconsistent
with General Relativity (GR), the focus of effort in developing a Scalar
Potential Model (SPM) has been on the examination of galaxies and clusters. The
SPM has been found to be consistent with cluster cellular structure, the flow
of IGM from spiral galaxies to elliptical galaxies, intergalactic redshift
without an expanding universe, discrete redshift, rotation curve (RC) data
without dark matter, asymmetric RCs, galaxy central mass, galaxy central
velocity dispersion, and the Pioneer Anomaly. In addition, the SPM suggests a
model of past expansion, past contraction, and current expansion of the
universe. GR corresponds to the SPM in the limit in which the effect of the
Sources and Sinks approximate a flat scalar potential field such as between
clusters and on the solar system scale, which is small relative to the distance
to a Source.

Categories: quant-ph, cond-mat.other, physics.atom-ph
Abstract: In this paper we investigate some entanglement properties for the Hydrogen
molecule considered as a two interacting spin 1/2 (qubit) model. The
entanglement related to the $H_{2}$ molecule is evaluated both using the von
Neumann entropy and the Concurrence and it is compared with the corresponding
quantities for the two interacting spin system. Many aspects of these functions
are examinated employing in part analytical and, essentially, numerical
techniques. We have compared analogous results obtained by Huang and Kais a few
years ago. In this respect, some possible controversial situations are
presented and discussed.

Categories: physics.soc-ph
Abstract: Useful information about scientific collaboration structures and patterns can
be inferred from computer databases of published papers. The genetic
programming bibliography is the most complete reference of papers on GP\@. In
addition to locating publications, it contains coauthor and coeditor
relationships from which a more complete picture of the field emerges. We treat
these relationships as undirected small world graphs whose study reveals the
community structure of the GP collaborative social network. Automatic analysis
discovers new communities and highlights new facets of them. The investigation
reveals many similarities between GP and coauthorship networks in other
scientific fields but also some subtle differences such as a smaller central
network component and a high clustering.

Categories: physics.comp-ph, physics.chem-ph
Abstract: During a crossover via a switching mechanism from one 2-body potential to
another as might be applied in modeling (chemical) reactions in the vicinity of
bond formation, energy violations would occur due to finite step size which
determines the trajectory of the particles relative to the potential
interactions of the unbonded state by numerical (e.g. Verlet) integration. This
problem is overcome by an algorithm which preserves the coordinates of the
system for each move, but corrects for energy discrepancies by ensuring both
energy and momentum conservation in the dynamics. The algorithm is tested for a
hysteresis loop reaction model with an without the implementation of the
algorithm. The tests involve checking the rate of energy flow out of the MD
simulation box; in the equilibrium state, no net rate of flows within
experimental error should be observed. The temperature and pressure of the box
should also be invariant within the range of fluctuation of these quantities.
It is demonstrated that the algorithm satisfies these criteria.

Categories: physics.atom-ph, physics.gen-ph
Abstract: An overview is presented of laser spectroscopy experiments with cold,
trapped, highly-charged ions, which will be performed at the HITRAP facility at
GSI in Darmstadt (Germany). These high-resolution measurements of ground state
hyperfine splittings will be three orders of magnitude more precise than
previous measurements. Moreover, from a comparison of measurements of the
hyperfine splittings in hydrogen- and lithium-like ions of the same isotope,
QED effects at high electromagnetic fields can be determined within a few
percent. Several candidate ions suited for these laser spectroscopy studies are
presented.

Categories: physics.optics
Abstract: A new method, FM-FTS, combining Frequency Modulation heterodyne laser
spectroscopy and Fourier Transform Spectroscopy is presented. It provides
simultaneous sensitive measurement of absorption and dispersion profiles with
broadband spectral coverage capabilities. Experimental demonstration is made on
the overtone spectrum of C2H2 in the 1.5 $\mu$m region.

Categories: physics.gen-ph
Abstract: In the last years the traditional scenario of Big Bang has been deeply
modified by the study of the quantum features of the Universe evolution,
proposing again the problem of using local physical laws on cosmic scale, with
particular regard to the cosmological constant role. The group extention method
shows that the De Sitter group univocally generalizes the Poincare group,
formally justifies the cosmological constant use and suggests a new
interpretation for Hartle-Hawking boundary conditions in Quantum Cosmology.

Categories: physics.class-ph
Abstract: We discuss an alternative non-perturbative proof of Bertrand's theorem that
leads in a concise way directly to the two allowed fields: the newtonian and
the isotropic harmonic oscillator central fields.

Categories: q-fin.GN, physics.soc-ph, q-fin.ST
Abstract: We analyze 27 house price indexes of Las Vegas from Jun. 1983 to Mar. 2005,
corresponding to 27 different zip codes. These analyses confirm the existence
of a real-estate bubble, defined as a price acceleration faster than
exponential, which is found however to be confined to a rather limited time
interval in the recent past from approximately 2003 to mid-2004 and has
progressively transformed into a more normal growth rate comparable to
pre-bubble levels in 2005. There has been no bubble till 2002 except for a
medium-sized surge in 1990. In addition, we have identified a strong yearly
periodicity which provides a good potential for fine-tuned prediction from
month to month. A monthly monitoring using a model that we have developed could
confirm, by testing the intra-year structure, if indeed the market has returned
to ``normal'' or if more turbulence is expected ahead. We predict the evolution
of the indexes one year ahead, which is validated with new data up to Sep.
2006. The present analysis demonstrates the existence of very significant
variations at the local scale, in the sense that the bubble in Las Vegas seems
to have preceded the more global USA bubble and has ended approximately two
years earlier (mid 2004 for Las Vegas compared with mid-2006 for the whole of
the USA).

Categories: cond-mat.other, physics.optics, quant-ph
Abstract: We give a microscopic derivation of the Clausius-Mossotti relations for a
homogeneous and isotropic magneto-dielectric medium consisting of radiatively
broadened atomic oscillators. To this end the diagram series of electromagnetic
propagators is calculated exactly for an infinite bi-cubic lattice of
dielectric and magnetic dipoles for a lattice constant small compared to the
resonance wavelength $\lambda$. Modifications of transition frequencies and
linewidth of the elementary oscillators are taken into account in a
selfconsistent way by a proper incorporation of the singular self-interaction
terms. We show that in radiatively broadened media sufficiently close to the
free-space resonance the real part of the index of refraction approaches the
value -2 in the limit of $\rho \lambda^3 \gg 1$, where $\rho$ is the number
density of scatterers. Since at the same time the imaginary part vanishes as
$1/\rho$ local field effects can have important consequences for realizing
low-loss negative index materials.

Categories: physics.gen-ph, q-bio.PE
Abstract: Despite their claimed biological plausibility, most self organizing networks
have strict topological constraints and consequently they cannot take into
account a wide range of external stimuli. Furthermore their evolution is
conditioned by deterministic laws which often are not correlated with the
structural parameters and the global status of the network, as it should happen
in a real biological system. In nature the environmental inputs are noise
affected and fuzzy. Which thing sets the problem to investigate the possibility
of emergent behaviour in a not strictly constrained net and subjected to
different inputs. It is here presented a new model of Evolutionary Neural Gas
(ENG) with any topological constraints, trained by probabilistic laws depending
on the local distortion errors and the network dimension. The network is
considered as a population of nodes that coexist in an ecosystem sharing local
and global resources. Those particular features allow the network to quickly
adapt to the environment, according to its dimensions. The ENG model analysis
shows that the net evolves as a scale-free graph, and justifies in a deeply
physical sense- the term gas here used.

Categories: physics.optics, cond-mat.soft, nlin.PS, physics.flu-dyn
Abstract: We investigate the formation of collisionless shocks along the spatial
profile of a gaussian laser beam propagating in nonlocal nonlinear media. For
defocusing nonlinearity the shock survives the smoothing effect of the nonlocal
response, though its dynamics is qualitatively affected by the latter, whereas
for focusing nonlinearity it dominates over filamentation. The patterns
observed in a thermal defocusing medium are interpreted in the framework of our
theory.

Categories: physics.comp-ph, physics.data-an
Abstract: Efficient control of a laser welding process requires the reliable prediction
of process behavior. A statistical method of field modeling, based on
normalized RBFNN, can be successfully used to predict the spatiotemporal
dynamics of surface optical activity in the laser welding process. In this
article we demonstrate how to optimize RBFNN to maximize prediction quality.
Special attention is paid to the structure of sample vectors, which represent
the bridge between the field distributions in the past and future.

Categories: q-fin.ST, physics.data-an, physics.soc-ph
Abstract: We show that recent stock market fluctuations are characterized by the
cumulative distributions whose tails on short, minute time scales exhibit power
scaling with the scaling index alpha > 3 and this index tends to increase
quickly with decreasing sampling frequency. Our study is based on
high-frequency recordings of the S&P500, DAX and WIG20 indices over the
interval May 2004 - May 2006. Our findings suggest that dynamics of the
contemporary market may differ from the one observed in the past. This effect
indicates a constantly increasing efficiency of world markets.

Categories: cond-mat.soft, cond-mat.stat-mech, physics.ins-det, physics.optics
Abstract: We report on a new type of experiment that enables us to monitor spatially
and temporally heterogeneous dynamic properties in complex fluids. Our approach
is based on the analysis of near-field speckles produced by light diffusely
reflected from the superficial volume of a strongly scattering medium. By
periodic modulation of an incident speckle beam we obtain pixel-wise ensemble
averages of the structure function coefficient, a measure of the dynamic
activity. To illustrate the application of our approach we follow the different
stages in the drying process of a colloidal thin film. We show that we can
access ensemble averaged dynamic properties on length scales as small as ten
micrometers over the full field of view.

Categories: physics.soc-ph
Abstract: The purpose of this paper is to assess the statistical characterization of
weighted networks in terms of the generalization of the relevant parameters,
namely average path length, degree distribution and clustering coefficient.
Although the degree distribution and the average path length admit
straightforward generalizations, for the clustering coefficient several
different definitions have been proposed in the literature. We examined the
different definitions and identified the similarities and differences between
them. In order to elucidate the significance of different definitions of the
weighted clustering coefficient, we studied their dependence on the weights of
the connections. For this purpose, we introduce the relative perturbation norm
of the weights as an index to assess the weight distribution. This study
revealed new interesting statistical regularities in terms of the relative
perturbation norm useful for the statistical characterization of weighted
graphs.

Categories: physics.soc-ph
Abstract: Simulations of physicists for the competition between adult languages since
2003 are reviewed. How many languages are spoken by how many people? How many
languages are contained in various language families? How do language
similarities decay with geographical distance, and what effects do natural
boundaries have? New simulations of bilinguality are given in an appendix.

Categories: hep-ph, physics.atom-ph
Abstract: Photon splitting due to vacuum polarization in a laser field is considered.
Using an operator technique, we derive the amplitudes for arbitrary strength,
spectral content and polarization of the laser field. The case of a
monochromatic circularly polarized laser field is studied in detail and the
amplitudes are obtained as three-fold integrals. The asymptotic behavior of the
amplitudes for various limits of interest are investigated also in the case of
a linearly polarized laser field. Using the obtained results, the possibility
of experimental observation of the process is discussed.

Categories: physics.chem-ph
Abstract: The thermal decomposition of norbornane (dissolved in benzene) has been
studied in a jet stirred reactor at temperatures between 873 and 973 K, at
residence times ranging from 1 to 4 s and at atmospheric pressure, leading to
conversions from 0.04 to 22.6%. 25 reaction products were identified and
quantified by gas chromatography, amongst which the main ones are hydrogen,
ethylene and 1,3-cyclopentadiene. A mechanism investigation of the thermal
decomposition of the norbornane - benzene binary mixture has been performed.
Reactions involved in the mechanism have been reviewed: unimolecular
initiations 1 by C-C bond scission of norbornane, fate of the generated
diradicals, reactions of transfer and propagation of norbornyl radicals,
reactions of benzene and cross-coupling reactions.

Categories: physics.chem-ph
Abstract: This work reports a theoretical study of the gas phase unimolecular
decomposition of cyclobutane, cyclopentane and cyclohexane by means of quantum
chemical calculations. A biradical mechanism has been envisaged for each
cycloalkane, and the main routes for the decomposition of the biradicals formed
have been investigated at the CBS-QB3 level of theory. Thermochemical data
(\delta H^0_f, S^0, C^0_p) for all the involved species have been obtained by
means of isodesmic reactions. The contribution of hindered rotors has also been
included. Activation barriers of each reaction have been analyzed to assess the
1 energetically most favorable pathways for the decomposition of biradicals.
Rate constants have been derived for all elementary reactions using transition
state theory at 1 atm and temperatures ranging from 600 to 2000 K. Global rate
constant for the decomposition of the cyclic alkanes in molecular products have
been calculated. Comparison between calculated and experimental results allowed
to validate the theoretical approach. An important result is that the
rotational barriers between the conformers, which are usually neglected, are of
importance in decomposition rate of the largest biradicals. Ring strain
energies (RSE) in transition states for ring opening have been estimated and
show that the main part of RSE contained in the cyclic reactants is removed
upon the activation process.

Categories: physics.optics
Abstract: A review of theoretical and experimental studies of thermal effects in
solid-state lasers is presented, with a special focus on diode-pumped
ytterbium-doped materials. A large part of this review provides however general
information applicable to any kind of solid-state laser. Our aim here is not to
make a list of the techniques that have been used to minimize thermal effects,
but instead to give an overview of the theoretical aspects underneath, and give
a state-of-the-art of the tools at the disposal of the laser scientist to
measure thermal effects. After a presentation of some general properties of
Yb-doped materials, we address the issue of evaluating the temperature map in
Yb-doped laser crystals, both theoretically and experimentally. This is the
first step before studying the complex problem of thermal lensing (part III).
We will focus on some newly discussed aspects, like the definition of the
thermo-optic coefficient: we will highlight some misleading interpretations of
thermal lensing experiments due to the use of the dn/dT parameter in a context
where it is not relevant. Part IV will be devoted to a state-of-the-art of
experimental techniques used to measure thermal lensing. Eventually, in part V,
we will give some concrete examples in Yb-doped materials, where their
peculiarities will be pointed out.

Categories: physics.optics
Abstract: We present a numerical study and analytical model of the optical near-field
diffracted in the vicinity of subwavelength grooves milled in silver surfaces.
The Green's tensor approach permits computation of the phase and amplitude
dependence of the diffracted wave as a function of the groove geometry. It is
shown that the field diffracted along the interface by the groove is equivalent
to replacing the groove by an oscillating dipolar line source. An analytic
expression is derived from the Green's function formalism, that reproduces well
the asymptotic surface plasmon polariton (SPP) wave as well as the transient
surface wave in the near-zone close to the groove. The agreement between this
model and the full simulation is very good, showing that the transient
"near-zone" regime does not depend on the precise shape of the groove. Finally,
it is shown that a composite diffractive evanescent wave model that includes
the asymptotic SPP can describe the wavelength evolution in this transient
near-zone. Such a semi-analytical model may be useful for the design and
optimization of more elaborate photonic circuits whose behavior in large part
will be controlled by surface waves.

Categories: physics.atom-ph
Abstract: We calculate angle-resolved above-threshold ionization spectra for diatomic
molecules in linearly polarized laser fields, employing the strong-field
approximation. The interference structure resulting from the individual
contributions of the different scattering scenarios is discussed in detail,
with respect to the dependence on the internuclear distance and molecular
orientation. We show that, in general, the contributions from the processes in
which the electron is freed at one center and rescatters off the other obscure
the interference maxima and minima obtained from single-center processes.
However, around the boundary of the energy regions for which rescattering has a
classical counterpart, such processes play a negligible role and very clear
interference patterns are observed. In such energy regions, one is able to
infer the internuclear distance from the energy difference between adjacent
interference minima.

Categories: physics.optics, physics.class-ph
Abstract: When light is passing through a rotating medium the optical polarisation is
rotated. Recently it has been reasoned that this rotation applies also to the
transmitted image (Padgett et al. 2006). We examine these two phenomena by
extending an analysis of Player (1976) to general electromagnetic fields. We
find that in this more general case the wave equation inside the rotating
medium has to be amended by a term which is connected to the orbital angular
momentum of the light. We show that optical spin and orbital angular momentum
account respectively for the rotation of the polarisation and the rotation of
the transmitted image.

Categories: physics.data-an
Abstract: We show that it can be considered some of Bach pitches series as a stochastic
process with scaling behavior. Using multifractal deterend fluctuation analysis
(MF-DFA) method, frequency series of Bach pitches have been analyzed. In this
view we find same second moment exponents (after double profiling) in ranges
(1.7-1.8) in his works. Comparing MF-DFA results of original series to those
for shuffled and surrogate series we can distinguish multifractality due to
long-range correlations and a broad probability density function. Finally we
determine the scaling exponents and singularity spectrum. We conclude fat tail
has more effect in its multifractality nature than long-range correlations.

Categories: stat.ME, physics.soc-ph, stat.AP
Abstract: The rich set of interactions between individuals in the society results in
complex community structure, capturing highly connected circles of friends,
families, or professional cliques in a social network. Thanks to frequent
changes in the activity and communication patterns of individuals, the
associated social and communication network is subject to constant evolution.
Our knowledge of the mechanisms governing the underlying community dynamics is
limited, but is essential for a deeper understanding of the development and
self-optimisation of the society as a whole. We have developed a new algorithm
based on clique percolation, that allows, for the first time, to investigate
the time dependence of overlapping communities on a large scale and as such, to
uncover basic relationships characterising community evolution. Our focus is on
networks capturing the collaboration between scientists and the calls between
mobile phone users. We find that large groups persist longer if they are
capable of dynamically altering their membership, suggesting that an ability to
change the composition results in better adaptability. The behaviour of small
groups displays the opposite tendency, the condition for stability being that
their composition remains unchanged. We also show that the knowledge of the
time commitment of the members to a given community can be used for estimating
the community's lifetime. These findings offer a new view on the fundamental
differences between the dynamics of small groups and large institutions.

Categories: cond-mat.stat-mech, cond-mat.soft, physics.chem-ph
Abstract: Extensions of statistical mechanics are routinely being used to infer free
energies from the work performed over single-molecule nonequilibrium
trajectories. A key element of this approach is the ubiquitous expression
dW/dt=\partial H(x,t)/ \partial t which connects the microscopic work W
performed by a time-dependent force on the coordinate x with the corresponding
Hamiltonian H(x,t) at time t. Here we show that this connection, as pivotal as
it is, cannot be used to estimate free energy changes. We discuss the
implications of this result for single-molecule experiments and atomistic
molecular simulations and point out possible avenues to overcome these
limitations.

Categories: q-fin.ST, cond-mat.other, physics.data-an, physics.soc-ph
Abstract: To investigate the universality of the structure of interactions in different
markets, we analyze the cross-correlation matrix C of stock price fluctuations
in the National Stock Exchange (NSE) of India. We find that this emerging
market exhibits strong correlations in the movement of stock prices compared to
developed markets, such as the New York Stock Exchange (NYSE). This is shown to
be due to the dominant influence of a common market mode on the stock prices.
By comparison, interactions between related stocks, e.g., those belonging to
the same business sector, are much weaker. This lack of distinct sector
identity in emerging markets is explicitly shown by reconstructing the network
of mutually interacting stocks. Spectral analysis of C for NSE reveals that,
the few largest eigenvalues deviate from the bulk of the spectrum predicted by
random matrix theory, but they are far fewer in number compared to, e.g., NYSE.
We show this to be due to the relative weakness of intra-sector interactions
between stocks, compared to the market mode, by modeling stock price dynamics
with a two-factor model. Our results suggest that the emergence of an internal
structure comprising multiple groups of strongly coupled components is a
signature of market development.

Categories: physics.plasm-ph, physics.space-ph
Abstract: Particle in cell (PIC) simulations of collisionless magnetic reconnection are
presented that demonstrate that the electron dissipation region develops a
distinct two-scale structure along the outflow direction. The length of the
electron current layer is found to decrease with decreasing electron mass,
approaching the ion inertial length for a proton-electron plasma. A surprise,
however, is that the electrons form a high-velocity outflow jet that remains
decoupled from the magnetic field and extends large distances downstream from
the x-line. The rate of reconnection remains fast in very large systems,
independent of boundary conditions and the mass of electrons.

Categories: physics.optics
Abstract: Mechanisms of whispering-gallery (WG) modes coupling in microdisk photonic
molecules (PMs) with slight and significant size mismatch are numerically
investigated. The results reveal two different scenarios of modes interaction
depending on the degree of this mismatch and offer new insight into how PM
parameters can be tuned to control and modify WG-modes wavelengths and
Q-factors. From a practical point of view, these findings offer a way to
fabricate PM microlaser structures that exhibit low thresholds and directional
emission, and at the same time are more tolerant to fabrication errors than
previously explored coupled-cavity structures composed of identical
microresonators.

Categories: physics.atm-clus
Abstract: A new single-particle shell model is derived by solving the Schr\"odinger
equation for a semi-spheroidal potential well. Only the negative parity states
of the $Z(z)$ component of the wave function are allowed, so that new magic
numbers are obtained for oblate semi-spheroids, semi-sphere and prolate
semi-spheroids. The semi-spherical magic numbers are identical with those
obtained at the oblate spheroidal superdeformed shape: 2, 6, 14, 26, 44, 68,
100, 140, ... The superdeformed prolate magic numbers of the semi-spheroidal
shape are identical with those obtained at the spherical shape of the
spheroidal harmonic oscillator: 2, 8, 20, 40, 70, 112, 168 ...

Categories: physics.optics
Abstract: Influence of hole shape on extraordinary optical transmission was
investigated using hole arrays consisting of rectangular holes with different
aspect ratio. It was found that the transmission could be tuned continuously by
rotating the hole array. Further more, a phase was generated in this process,
and linear polarization states could be changed to elliptical polarization
states. This phase was correlated with the aspect ratio of the holes. An
intuitional model was presented to explain these results.

Categories: physics.atom-ph
Abstract: The intercombination line of Strontium at 689nm is successfully used in laser
cooling to reach the photon recoil limit with Doppler cooling in a
magneto-optical traps (MOT). In this paper we present a systematic study of the
loading efficiency of such a MOT. Comparing the experimental results to a
simple model allows us to discuss the actual limitation of our apparatus. We
also study in detail the final MOT regime emphasizing the role of gravity on
the position, size and temperature along the vertical and horizontal
directions. At large laser detuning, one finds an unusual situation where
cooling and trapping occur in the presence of a high bias magnetic field.

Categories: physics.atom-ph, physics.class-ph
Abstract: We demonstrate that radiative transitions with \Delta l = - 1 are strongly
dominating for all values of n and l, except small region where l << n.

Categories: physics.acc-ph
Abstract: We are proposing to test experimentally the new idea of Enhanced Optical
Cooling (EOC) in an electron storage ring. This experiment will confirm new
fundamental processes in beam physics and will demonstrate new unique
possibilities with this cooling technique. It will open important applications
of EOC in nuclear physics, elementary particle physics and in Light Sources
(LS) based on high brightness electron and ion beams.

Categories: physics.data-an, physics.gen-ph
Abstract: A new approach to non-extensive thermodynamical systems with non-additive
energy and entropy is proposed. The main idea of the paper is based on the
statistical matching of the thermodynamical systems with the additive
multi-step Markov chains. This general approach is applied to the Ising spin
chain with long-range interaction between its elements. The asymptotical
expressions for the energy and entropy of the system are derived for the
limiting case of weak interaction. These thermodynamical quantities are found
to be non-proportional to the length of the system (number of its particle).

Categories: physics.data-an, physics.soc-ph
Abstract: For the 100 largest European universities we studied the statistical
properties of bibliometric indicators related to research performance, field
citation density and journal impact. We find a size-dependent cumulative
advantage for the impact of universities in terms of total number of citations.
In previous work a similar scaling rule was found at the level of research
groups. Therefore we conjecture that this scaling rule is a prevalent property
of the science system. We observe that lower performance universities have a
larger size-dependent cumulative advantage for receiving citations than
top-performance universities. We also find that for the lower-performance
universities the fraction of not-cited publications decreases considerably with
size. Generally, the higher the average journal impact of the publications of a
university, the lower the number of not-cited publications. We find that the
average research performance does not dilute with size. Large top-performance
universities succeed in keeping a high performance over a broad range of
activities. This most probably is an indication of their scientific attractive
power. Next we find that particularly for the lower-performance universities
the field citation density provides a strong cumulative advantage in citations
per publication. The relation between number of citations and field citation
density found in this study can be considered as a second basic scaling rule of
the science system. Top-performance universities publish in journals with
significantly higher journal impact as compared to the lower performance
universities. We find a significant decrease of the fraction of self-citations
with increasing research performance, average field citation density, and
average journal impact.

Categories: physics.gen-ph
Abstract: For the first time we apply the methodologies of nonlinear analysis to
investigate atomic matter. We use these methods in the analysis of Atomic
Weights and of Mass Number of atomic nuclei. Using the AutoCorrelation Function
and Mutual Information we establish the presence of nonlinear effects in the
mechanism of increasing mass of atomic nuclei considered as a function of the
atomic number. We find that increasing mass is divergent, possibly chaotic. We
also investigate the possible existence of a Power Law for atomic nuclei and,
using also the technique of the variogram, we conclude that a fractal regime
could superintend to the mechanism of increasing mass for nuclei. Finally,
using the Hurst exponent, evidence is obtained that the mechanism of increasing
mass in atomic nuclei is in the fractional Brownian regime. The most
interesting results are obtained by using Recurrence Quantification Analysis
(RQA). New recurrences, psudoperiodicities, self-resemblance and class of
self-similarities are identified with values of determinism showing oscillating
values indicating the presence of more or less stability during the process of
increasing mass of atomic nuclei. In brief, new regimes of regularities are
identified for atomic nuclei that deserve to be studied by future researches.
In particular an accurate analysis of binding energy values by nonlinear
methods is further required.

Categories: physics.atom-ph
Abstract: We present a detailed experimental and theoretical study of the effect of
nuclear spin on the performance of optical lattice clocks. With a state-mixing
theory including spin-orbit and hyperfine interactions, we describe the origin
of the $^1S_0$-$^3P_0$ clock transition and the differential g-factor between
the two clock states for alkaline-earth(-like) atoms, using $^{87}$Sr as an
example. Clock frequency shifts due to magnetic and optical fields are
discussed with an emphasis on those relating to nuclear structure. An
experimental determination of the differential g-factor in $^{87}$Sr is
performed and is in good agreement with theory. The magnitude of the tensor
light shift on the clock states is also explored experimentally. State specific
measurements with controlled nuclear spin polarization are discussed as a
method to reduce the nuclear spin-related systematic effects to below
10$^{-17}$ in lattice clocks.

Categories: math.AP, math-ph, math.MP, physics.optics
Abstract: Cloaking devices are prescriptions of electrostatic, optical or
electromagnetic parameter fields (conductivity $\sigma(x)$, index of refraction
$n(x)$, or electric permittivity $\epsilon(x)$ and magnetic permeability
$\mu(x)$) which are piecewise smooth on $\mathbb R^3$ and singular on a
hypersurface $\Sigma$, and such that objects in the region enclosed by $\Sigma$
are not detectable to external observation by waves. Here, we give related
constructions of invisible tunnels, which allow electromagnetic waves to pass
between possibly distant points, but with only the ends of the tunnels visible
to electromagnetic imaging. Effectively, these change the topology of space
with respect to solutions of Maxwell's equations, corresponding to attaching a
handlebody to $\mathbb R^3$. The resulting devices thus function as
electromagnetic wormholes.

Categories: physics.hist-ph
Abstract: The historical significance of the problem of relativistic rigid rotation is
reviewed in light of recently published correspondence between Einstein and the
mathematician Vladimir Varicak from the years 1909 to 1913.

Categories: physics.hist-ph, astro-ph
Abstract: Einstein's early calculations of gravitational lensing, contained in a
scratch notebook and dated to the spring of 1912, are reexamined. A hitherto
unknown letter by Einstein suggests that he entertained the idea of explaining
the phenomenon of new stars by gravitational lensing in the fall of 1915 much
more seriously than was previously assumed. A reexamination of the relevant
calculations by Einstein shows that, indeed, at least some of them most likely
date from early October 1915. But in support of earlier historical
interpretation of Einstein's notes, it is argued that the appearance of Nova
Geminorum 1912 (DN Gem) in March 1912 may, in fact, provide a relevant context
and motivation for Einstein's lensing calculations on the occasion of his first
meeting with Erwin Freundlich during a visit in Berlin in April 1912. We also
comment on the significance of Einstein's consideration of gravitational
lensing in the fall of 1915 for the reconstruction of Einstein's final steps in
his path towards general relativity.

Categories: physics.gen-ph
Abstract: The assumption of the capture by the Solar System of the electrically charged
Planckian DM objects (daemons) from the galactic disk is confirmed not only by
the St.Petersburg (SPb) experiments detecting particles with V<30 km/s. Here
the daemon approach is analyzed considering the positive model independent
result of the DAMA/NaI experiment. We explain the maximum in DAMA signals
observed in the May-June period to be associated with the formation behind the
Sun of a trail of daemons that the Sun captures into elongated orbits as it
moves to the apex. The range of significant 2-6-keV DAMA signals fits well the
iodine nuclei elastically knocked out of the NaI(Tl) scintillator by particles
falling on the Earth with V=30-50 km/s from strongly elongated heliocentric
orbits. The half-year periodicity of the slower daemons observed in SPb
originates from the transfer of particles that are deflected through ~90 deg
into near-Earth orbits each time the particles cross the outer reaches of the
Sun which had captured them. Their multi-loop (cross-like) trajectories
traverse many times the Earth's orbit in March and September, which increases
the probability for the particles to enter near-Earth orbits during this time.
Corroboration of celestial mechanics calculations with observations yields
~1e-19 cm2 for the cross section of daemon interaction with the solar matter.

Categories: physics.flu-dyn
Abstract: We describe a practical procedure for extracting the spatial structure and
the growth rates of slow eigenmodes of a spatially extended system, using a
unique experimental capability both to impose and to perturb desired initial
states. The procedure is used to construct experimentally the spectrum of
linear modes near the secondary instability boundary in Rayleigh-B\'{e}nard
convection. This technique suggests an approach to experimental
characterization of more complex dynamical states such as periodic orbits or
spatiotemporal chaos.

Categories: physics.data-an
Abstract: We have studied the effect of annealing temperature on the statistical
properties of $WO_3$ surface using atomic force microscopy techniques (AFM). We
have applied both level crossing and structure function methods. Level crossing
analysis indicates an optimum annealing temperature of around 400$^oC$ at which
the effective area of the $WO_3$ thin film is maximum, whereas composition of
the surface remains stoichiometric. The complexity of the height fluctuation of
surfaces was characterized by roughness, roughness exponent and lateral size of
surface features. We have found that there is a phase transition at around
400$^oC$ from one set to two sets of roughness parameters. This happens due to
microstructural changes from amorphous to crystalline structure in the samples
that has been already found experimentally.

Categories: physics.data-an
Abstract: The effect of bias voltages on the statistical properties of rough surfaces
has been studied using atomic force microscopy technique and its stochastic
analysis. We have characterized the complexity of the height fluctuation of a
rough surface by the stochastic parameters such as roughness exponent, level
crossing, and drift and diffusion coefficients as a function of the applied
bias voltage. It is shown that these statistical as well as microstructural
parameters can also explain the macroscopic property of a surface. Furthermore,
the tip convolution effect on the stochastic parameters has been examined.

Categories: physics.data-an
Abstract: The effect of etching time scale of glass surface on its statistical
properties has been studied using atomic force microscopy technique. We have
characterized the complexity of the height fluctuation of a etched surface by
the stochastic parameters such as intermittency exponents, roughness, roughness
exponents, drift and diffusion coefficients and find their variations in terms
of the etching time.

Categories: physics.gen-ph
Abstract: The cosmological redshift phenomenon can be described by the dark matter
field fluid model, the results deduced from this model agree very well with the
observations. The observed cosmological redshift of light depends on both the
speed of the emitter and the distance between the emitter and the observer. If
the emitter moves away from us, a redshift is observed. If the emitter moves
towards us, whether a redshift, a blueshift or no shift is observed will depend
on the speed vs. the distance. If the speed is in the range of
c(exp[-beta*D]-1) < v < 0, a redshift is observed; if the speed equals
c(exp[-beta*D]-1), no shift is observed; if the speed v less than
c(exp[-beta*D]-1), a blueshift is observed. A redshift will be always observed
in all directions for any celestial objects as long as their distance from us
is large enough. Therefore, many more redshifts than blueshifts should be
observed for galaxies and supernovae, etc in the sky. This conclusion agrees
with current observations. The estimated value of the redshift constant beta of
the dark matter field fluid is in the range of 10^(-3) ~ 10^(-5)/Mpc. A large
redshift value from a distant celestial object may not necessarily indicate
that it has a large receding speed. Based on the redshift effect of dark matter
field fluid, it is concluded that at least in time average all photons have the
same geometry (size and shape) in all inertial reference frames and do not have
length contraction effect.

Categories: physics.gen-ph
Abstract: Role of axiom of choice in quantum measurement is highlighted by suggesting
that the conscious observer chooses the outcome from a mixed state. Further, in
a periodically repeating universe, these outcomes must be pre-recorded within
the non-physical conscious observers, which precludes free will. Free will
however exists in a universe with open time, It is suggested that psychology's
binding problem is connected with Cantor's original definition of set.
Influence of consciousness on material outcome through quantum processes is
discussed and interesting constraints derived. For example, it is predicted
that quantum mechanical brain states should get frozen if monitored at
sufficiently small space-time intervals - a neuro-biological version of the so
called quantum zeno effect, which has been verified in domain of micro-physics.
Existence of a very small micro-mini-black-hole in brain is predicted as a
space-time structural interface between consciousness and brain, whose
vaporization explains mass-loss reported in weighing experiments, conducting
during the moments of death.

Categories: q-fin.ST, physics.data-an, physics.soc-ph
Abstract: We analyse the dependence of stock return cross-correlations on the sampling
frequency of the data known as the Epps effect: For high resolution data the
cross-correlations are significantly smaller than their asymptotic value as
observed on daily data. The former description implies that changing trading
frequency should alter the characteristic time of the phenomenon. This is not
true for the empirical data: The Epps curves do not scale with market activity.
The latter result indicates that the time scale of the phenomenon is connected
to the reaction time of market participants (this we denote as human time
scale), independent of market activity. In this paper we give a new description
of the Epps effect through the decomposition of cross-correlations. After
testing our method on a model of generated random walk price changes we justify
our analytical results by fitting the Epps curves of real world data.

Categories: physics.soc-ph
Abstract: Human beings like to believe they are in control of their destiny. This
ubiquitous trait seems to increase motivation and persistence, and is probably
evolutionarily adaptive. But how good really is our ability to control? How
successful is our track record in these areas? There is little understanding of
when and under what circumstances we may over-estimate or even lose our ability
to control and optimize outcomes, especially when they are the result of
aggregations of individual optimization processes. Here, we demonstrate
analytically using the theory of Markov Chains and by numerical simulations in
two classes of games, the Minority game and the Parrondo Games, that agents who
optimize their strategy based on past information actually perform worse than
non-optimizing agents. In other words, low-entropy (more informative)
strategies under-perform high-entropy (or random) strategies. This provides a
precise definition of the "illusion of control" in set-ups a priori defined to
emphasize the importance of optimization.

Categories: physics.optics
Abstract: Analysis of electromagnetic planewave propagation in a medium which is a
spatiotemporally homogeneous, temporally nonlocal, isotropic, chiral medium in
a co-moving frame of reference shows that the medium is both spatially and
temporally nonlocal with respect to all non-co-moving inertial frames of
reference. Using the Lorentz transformations of electric and magnetic fields,
we show that plane waves which have positive phase velocity in the co-moving
frame of reference can have negative phase velocity in certain non-co-moving
frames of reference. Similarly, plane waves which have negative phase velocity
in the co-moving frame can have positive phase velocity in certain
non-co-moving frames.

Categories: physics.gen-ph, physics.class-ph
Abstract: Extending physics/0701092, a light source of monochromatic radiation, in
rectilinear motion under constant proper acceleration, passes near an observer
at rest. In the context of special relativity, we describe the observed Doppler
effect. We describe also the interesting discontinuous effect when riding
through occurs. An English version of this article is available.
  -----
  Da^urigante physics/0701092, luma fonto de unukolora radiado ^ce rekta movo
^ce konstanta propra akcelo pasas preter restanta observanto. ^Ce la
special-relativeco, ni priskribas la observatan Doppleran efikon. Ni anka^u
priskribas la interesan nekontinuan efikon se trapaso okazas.

Categories: physics.optics, physics.med-ph
Abstract: Elastic light scattering by mature red blood cells (RBCs) was theoretically
and experimentally analyzed with the discrete dipole approximation (DDA) and
the scanning flow cytometry (SFC), respectively. SFC permits measurement of
angular dependence of light-scattering intensity (indicatrix) of single
particles. A mature RBC is modeled as a biconcave disk in DDA simulations of
light scattering. We have studied the effect of RBC orientation related to the
direction of the incident light upon the indicatrix. Numerical calculations of
indicatrices for several aspect ratios and volumes of RBC have been carried
out. Comparison of the simulated indicatrices and indicatrices measured by SFC
showed good agreement, validating the biconcave disk model for a mature RBC. We
simulated the light-scattering output signals from the SFC with the DDA for
RBCs modeled as a disk-sphere and as an oblate spheroid. The biconcave disk,
the disk-sphere, and the oblate spheroid models have been compared for two
orientations, i.e. face-on and rim-on incidence. Only the oblate spheroid model
for rim-on incidence gives results similar to the rigorous biconcave disk
model.

Categories: physics.gen-ph, physics.bio-ph
Abstract: I discuss several aspects of information theory and its relationship to
physics and neuroscience. The unifying thread of this somewhat chaotic essay is
the concept of Kolmogorov or algorithmic complexity (Kolmogorov Complexity, for
short). I argue that it is natural to interpret cognition as the art of finding
algorithms that apprach the Solomonoff-Kolmogorov-Chaitin (algorithmic)
Complexity limit with appropriate tradeoffs. In addition, I claim that what we
call the universe is an interpreted abstraction--a mental construct--based on
the observed coherence between multiple sensory input streams and our own
interactions. Hence, the notion of Universe is itself a model.

Categories: cs.CY, cs.IR, physics.soc-ph
Abstract: The subject of collective attention is central to an information age where
millions of people are inundated with daily messages. It is thus of interest to
understand how attention to novel items propagates and eventually fades among
large populations. We have analyzed the dynamics of collective attention among
one million users of an interactive website -- \texttt{digg.com} -- devoted to
thousands of novel news stories. The observations can be described by a
dynamical model characterized by a single novelty factor. Our measurements
indicate that novelty within groups decays with a stretched-exponential law,
suggesting the existence of a natural time scale over which attention fades.

Categories: physics.optics
Abstract: A cylindrical wave expansion method is developed to obtain the scattering
field for an ideal two-dimensional cylindrical invisibility cloak. A near-ideal
model of the invisibility cloak is set up to solve the boundary problem at the
inner boundary of the cloak shell. We confirm that a cloak with the ideal
material parameters is a perfect invisibility cloak by systematically studying
the change of the scattering coefficients from the near-ideal case to the ideal
one. However, due to the slow convergence of the zero$^{th}$ order scattering
coefficients, a tiny perturbation on the cloak would induce a noticeable field
scattering and penetration.

Categories: physics.geo-ph, physics.gen-ph
Abstract: Phase singularities as topological objects of wave fields appear in a variety
of physical, chemical, and biological scenarios. In this paper, by making use
of the $\phi$-mapping topological current theory, we study the topological
properties of the phase singularities in two and three dimensional space in
details. The topological inner structure of the phase singularities are
obtained, and the topological charge of the phase singularities are expressed
by the topological numbers: Hopf indices and Brouwer degrees. Furthermore, the
topological invariant of the closed and knotted phase singularities in three
dimensional space are also discussed in details.

Categories: physics.optics
Abstract: Carrier wave shocking is studied using the Pseudo-Spectral Spatial Domain
(PSSD) technique. We describe the shock detection diagnostics necessary for
this numerical study, and verify them against theoretical shocking predictions
for the dispersionless case. These predictions show Carrier Envelope Phase
(CEP) and pulse bandwidth sensitivity in the single-cycle regime. The flexible
dispersion management offered by PSSD enables us to independently control the
linear and nonlinear dispersion. Customized dispersion profiles allow us to
analyze the development of both carrier self-steepening and shocks. The results
exhibit a marked asymmetry between normal and anomalous dispersion, both in the
limits of the shocking regime and in the (near) shocked pulse waveforms.
Combining these insights, we offer some suggestions on how carrier shocking (or
at least extreme self-steepening) might be realised experimentally.

Categories: q-fin.GN, cond-mat.dis-nn, physics.soc-ph
Abstract: The large-scale organization of the world economies is exhibiting
increasingly levels of local heterogeneity and global interdependency.
Understanding the relation between local and global features calls for
analytical tools able to uncover the global emerging organization of the
international trade network. Here we analyze the world network of bilateral
trade imbalances and characterize its overall flux organization, unraveling
local and global high-flux pathways that define the backbone of the trade
system. We develop a general procedure capable to progressively filter out in a
consistent and quantitative way the dominant trade channels. This procedure is
completely general and can be applied to any weighted network to detect the
underlying structure of transport flows. The trade fluxes properties of the
world trade web determines a ranking of trade partnerships that highlights
global interdependencies, providing information not accessible by simple local
analysis. The present work provides new quantitative tools for a dynamical
approach to the propagation of economic crises.

Categories: physics.flu-dyn, nlin.CD
Abstract: We present numerical studies for finitely extensible nonlinear elastic (FENE)
dumbbells which are dispersed in a turbulent plane shear flow at moderate
Reynolds number. The polymer ensemble is described on the mesoscopic level by a
set of stochastic ordinary differential equations with Brownian noise. The
dynamics of the Newtonian solvent is determined by the Navier-Stokes equations.
Momentum transfer of the dumbbells with the solvent is implemented by an
additional volume forcing term in the Navier-Stokes equations, such that both
components of the resulting viscoelastic fluid are connected by a two-way
coupling. The dynamics of the dumbbells is given then by Newton's second law of
motion including small inertia effects. We investigate the dynamics of the flow
for different degrees of dumbbell elasticity and inertia, as given by
Weissenberg and Stokes numbers, respectively. For the parameters accessible in
our study, the magnitude of the feedback of the polymers on the macroscopic
properties of turbulence remains small as quantified by the global energy
budget and the Reynolds stresses. A reduction of the turbulent drag by up to
20% is observed for the larger particle inertia. The angular statistics of the
dumbbells shows an increasing alignment with the mean flow direction for both,
increasing elasticity and inertia. This goes in line with a growing asymmetry
of the probability density function of the transverse derivative of the
streamwise turbulent velocity component. We find that dumbbells get stretched
referentially in regions where vortex stretching or bi-axial strain dominate
the local dynamics and topology of the velocity gradient tensor.

Categories: physics.data-an, cond-mat.other, nlin.CD, nucl-th
Abstract: A random matrix model to describe the coupling of m-fold symmetry in
constructed. The particular threefold case is used to analyze data on
eigenfrequencies of elastomechanical vibration of an anisotropic quartz block.
It is suggested that such experimental/theoretical study may supply powerful
means to discern intrinsic symmetries in physical systems.

Categories: physics.optics
Abstract: We demonstrate an all-optical delay line in hot cesium vapor that tunably
delays 275 ps input pulses up to 6.8 ns and 740 input ps pulses up to 59 ns
(group index of approximately 200) with little pulse distortion. The delay is
made tunable with a fast reconfiguration time (hundreds of ns) by optically
pumping out of the atomic ground states.

Categories: physics.gen-ph
Abstract: Systematic error in calculation of z for high redshift type Ia supernovae
could help explain unexpected luminosity values that indicate an accelerating
rate of expansion of the universe.

Categories: physics.flu-dyn
Abstract: We show that full-image micro-PIV analysis in combination with images of
transient particle motion is a powerful tool for experimental studies of
acoustic radiation forces and acoustic streaming in microfluidic chambers under
piezo-actuation in the MHz range. The measured steady-state motion of both
large 5 um and small 1 um particles can be understood in terms of the acoustic
eigenmodes or standing ultra-sound waves in the given experimental
microsystems. This interpretation is supported by numerical solutions of the
corresponding acoustic wave equation.

Categories: physics.ed-ph
Abstract: This paper introduces a theory about the role of language in learning
physics. The theory is developed in the context of physics students' and
physicists' talking and writing about the subject of quantum mechanics. We
found that physicists' language encodes different varieties of analogical
models through the use of grammar and conceptual metaphor. We hypothesize that
students categorize concepts into ontological categories based on the
grammatical structure of physicists' language. We also hypothesize that
students over-extend and misapply conceptual metaphors in physicists' speech
and writing. Using our theory, we will show how, in some cases, we can explain
student difficulties in quantum mechanics as difficulties with language.

Categories: physics.flu-dyn
Abstract: Microfluidic chips have been fabricated to study electrokinetic pumping
generated by a low voltage AC signal applied to an asymmetric electrode array.
A measurement procedure has been established and followed carefully resulting
in a high degree of reproducibility of the measurements. Depending on the ionic
concentration as well as the amplitude of the applied voltage, the observed
direction of the DC flow component is either forward or reverse. The impedance
spectrum has been thoroughly measured and analyzed in terms of an equivalent
circuit diagram. Our observations agree qualitatively, but not quantitatively,
with theoretical models published in the literature.

Categories: physics.gen-ph
Abstract: In this letter I suggest possible redefinition of mass density, not depending
on speed of the mass element, which leads to a more simple stress-energy for an
object. I calculate energy of black hole.

Categories: physics.ins-det
Abstract: A set of analog electronics boards for serial readout of silicon strip
sensors was fabricated. A commercially available amplifier is mounted on a
homemade hybrid board in order to receive analog signals from silicon strip
sensors. Also, another homemade circuit board is fabricated in order to
translate amplifier control signals into a suitable format and to provide bias
voltage to the amplifier as well as to the silicon sensors. We discuss
technical details of the fabrication process and performance of the circuit
boards we developed.

Categories: q-fin.ST, physics.soc-ph
Abstract: In this paper, we consider daily financial data of a collection of different
stock market indices, exchange rates, and interest rates, and we analyze their
multi-scaling properties by estimating a simple specification of the
Markov-switching multifractal model (MSM). In order to see how well the
estimated models capture the temporal dependence of the data, we estimate and
compare the scaling exponents $H(q)$ (for $q = 1, 2$) for both empirical data
and simulated data of the estimated MSM models. In most cases the multifractal
model appears to generate `apparent' long memory in agreement with the
empirical scaling laws.

Categories: physics.chem-ph, physics.atm-clus, physics.gen-ph
Abstract: An accurate experimental investigation on the Mpemba effect (that is, the
freezing of initially hot water before cold one) is carried out, showing that
in the adiabatic cooling of water a relevant role is played by supercooling as
well as by phase transitions taking place at 6 +/- 1 oC, 3.5 +/- 0.5 oC and 1.3
+/- 0.6 oC, respectively. The last transition, occurring with a non negligible
probability of 0.21, has not been detected earlier. Supported by the
experimental results achieved, a thorough theoretical analysis of supercooling
and such phase transitions, which are interpreted in terms of different
ordering of clusters of molecules in water, is given.

Categories: physics.atom-ph
Abstract: We investigate the possibility to deduce momentum space properties from
time-dependent density functional calculations. Electron and ion momentum
distributions after double ionization of a model Helium atom in a strong
few-cycle laser pulse are studied. We show that, in this case, the choice of
suitable functionals for the observables is considerably more important than
the choice of the correlation potential in the time-dependent Kohn-Sham
equations. By comparison with the solution of the time-dependent Schroedinger
equation, the insufficiency of functionals neglecting electron correlation is
demonstrated. We construct a functional of the Kohn-Sham orbitals, which in
principle yields the exact momentum distributions of the electrons and the ion.
The product-phase approximation is introduced, which reduces the problem of
approximating this functional significantly.

Categories: physics.geo-ph, physics.flu-dyn
Abstract: Star patterns, reminiscent of a wide range of diffusively controlled growth
forms from snowflakes to Saffman-Taylor fingers, are ubiquitous features of ice
covered lakes. Despite the commonality and beauty of these ``lake stars'' the
underlying physical processes that produce them have not been explained in a
coherent theoretical framework. Here we describe a simple mathematical model
that captures the principal features of lake-star formation; radial fingers of
(relatively warm) water-rich regions grow from a central source and evolve
through a competition between thermal and porous media flow effects in a
saturated snow layer covering the lake. The number of star arms emerges from a
stability analysis of this competition and the qualitative features of this
meter-scale natural phenomena are captured in laboratory experiments.

Categories: quant-ph, physics.optics
Abstract: We put forward an approach to estimate the amount of bipartite spatial
entanglement of down-converted photon states correlated in orbital angular
momentum and the magnitude of the transverse (radial) wave vectors. Both
degrees of freedom are properly considered in our framework, which only
requires azimuthal local linear optical transformations and mode selection
analysis with two fiber detectors. The coincidence distributions predicted by
our approach give an excellent fit to the distributions measured in a recent
experiment aimed to show the very high-dimensional transverse entanglement of
twin photons from a down-conversion source. Our estimate for the Schmidt number
is substantially lower but still confirms the presence of high-dimensional
entanglement.

Categories: physics.optics
Abstract: We report the suppression of loss of surface plasmon polariton propagating at
the interface between silver film and optically pumped polymer with dye. Large
magnitude of the effect enables a variety of applications of "active"
nanoplasmonics. The experimental study is accompanied by the development of the
analytical description of the phenomenon and the solution of the controversy
regarding the direction of the wavevector of a wave with a strong evanescent
component in an active medium.

Categories: physics.gen-ph
Abstract: The Special Theory of Relativity and the Theory of the Electron have had an
interesting history together. Originally the electron was studied in a non
relativistic context and this opened up the interesting possibility that lead
to the conclusion that the mass of the electron could be thought of entirely in
electromagnetic terms without introducing inertial considerations. However the
application of Special Relativity lead to several problems, both for an
extended electron and the point electron. These inconsistencies have, contrary
to popular belief not been resolved satisfactorily today, even within the
context of Quantum Theory. Nevertheless these and subsequent studies bring out
the interesting result that Special Relativity breaks down within the Compton
scale or when the Compton scale is not neglected. This again runs contrary to
an uncritical notion that Special Relativity is valid for point particles.

Categories: cond-mat.stat-mech, cond-mat.dis-nn, physics.soc-ph
Abstract: We consider the ferromagnetic large-$q$ state Potts model in complex evolving
networks, which is equivalent to an optimal cooperation problem, in which the
agents try to optimize the total sum of pair cooperation benefits and the
supports of independent projects. The agents are found to be typically of two
kinds: a fraction of $m$ (being the magnetization of the Potts model) belongs
to a large cooperating cluster, whereas the others are isolated one man's
projects. It is shown rigorously that the homogeneous model has a strongly
first-order phase transition, which turns to second-order for random
interactions (benefits), the properties of which are studied numerically on the
Barab\'asi-Albert network. The distribution of finite-size transition points is
characterized by a shift exponent, $1/\tilde{\nu}'=.26(1)$, and by a different
width exponent, $1/\nu'=.18(1)$, whereas the magnetization at the transition
point scales with the size of the network, $N$, as: $m\sim N^{-x}$, with
$x=.66(1)$.

Categories: physics.chem-ph, nucl-th
Abstract: The spectral function of the closed-shell Neon atom is computed by expanding
the electron self-energy through a set of Faddeev equations. This method
describes the coupling of single-particle degrees of freedom with correlated
two-electron, two-hole, and electron-hole pairs. The excitation spectra are
obtained using the Random Phase Approximation, rather than the Tamm-Dancoff
framework employed in the third-order algebraic diagrammatic contruction
[ADC(3)] method. The difference between these two approaches is studied, as
well as the interplay between ladder and ring diagrams in the self-energy.
Satisfactory results are obtained for the ionization energies as well as the
energy of the ground state with the Faddeev-RPA scheme that is also appropriate
for the high-density electron gas.

Categories: physics.bio-ph, cond-mat.soft, q-bio.BM
Abstract: We propose a combined experimental (Atomic Force Microscopy) and theoretical
study of the structural and dynamical properties of nucleosomes. In contrast to
biochemical approaches, this method allows to determine simultaneously the DNA
complexed length distribution and nucleosome position in various contexts.
First, we show that differences in the nucleo-proteic structure observed
between conventional H2A and H2A.Bbd variant nucleosomes induce quantitative
changes in the in the length distribution of DNA complexed with histones. Then,
the sliding action of remodeling complex SWI/SNF is characterized through the
evolution of the nucleosome position and wrapped DNA length mapping. Using a
linear energetic model for the distribution of DNA complexed length, we extract
the net wrapping energy of DNA onto the histone octamer, and compare it to
previous studies.

Categories: physics.atm-clus, physics.comp-ph
Abstract: Density-functional theory has been applied to investigate systematics of
sodium clusters Na_n in the size range of n= 39-55. A clear evolutionary trend
in the growth of their ground-state geometries emerges. The clusters at the
beginning of the series (n=39-43) are symmetric and have partial icosahedral
(two-shell) structure. The growth then goes through a series of disordered
clusters (n=44-52) where the icosahedral core is lost. However, for n>52 a
three shell icosahedral structure emerges. This change in the nature of the
geometry is abrupt. In addition, density-functional molecular dynamics has been
used to calculate the specific heat curves for the representative sizes n= 43,
45, 48 and 52. These results along with already available thermodynamic
calculations for n= 40, 50, and 55 enable us to carry out a detailed comparison
of the heat capacity curves with their respective geometries for the entire
series. Our results clearly bring out strong correlation between the evolution
of the geometries and the nature of the shape of the heat capacities. The
results also firmly establish the size-sensitive nature of the heat capacities
in sodium clusters.

Categories: physics.soc-ph, cond-mat.stat-mech
Abstract: A new public conveyance model applicable to buses and trains is proposed in
this paper by using stochastic cellular automaton. We have found the optimal
density of vehicles, at which the average velocity becomes maximum,
significantly depends on the number of stops and passengers behavior of getting
on a vehicle at stops. The efficiency of the hail-and-ride system is also
discussed by comparing the different behavior of passengers. Moreover, we have
found that a big cluster of vehicles is divided into small clusters, by
incorporating information of the number of vehicles between successive stops.

Categories: math.NA, math-ph, math.MP, physics.comp-ph
Abstract: A library of C functions yielding exact solutions of potential and flux
influences due to uniform surface distribution of singularities on flat
triangular and rectangular elements has been developed. This library, ISLES,
has been used to develop the neBEM solver that is both precise and fast in
solving a wide range of problems of scientific and technological interest. Here
we present the exact expressions proposed for computing the influence of
uniform singularity distributions on triangular elements and illustrate their
accuracy. We also present a study concerning the time taken to evaluate these
long and complicated expressions \textit{vis a vis} that spent in carrying out
simple quadratures. Finally, we solve a classic benchmark problem in
electrostatics, namely, estimation of the capacitance of a unit square plate
raised to unit volt. For this problem, we present the estimated values of
capacitance and compare them successfully with some of the most accurate
results available in the literature. In addition, we present the variation of
the charge density close to the corner of the plate for various degrees of
discretization. The variations are found to be smooth and converging. This is
in clear contrast to the criticism commonly leveled against usual BEM solvers.

Categories: physics.class-ph
Abstract: Retarded electromagnetic potentials are derived from Maxwell's equations and
the Lorenz condition. The difference found between these potentials and the
conventional Li\'{e}nard-Wiechert ones is explained by neglect, for the latter,
of the motion-dependence of the effective charge density. The corresponding
retarded fields of a point-like charge in arbitary motion are compared with
those given by the formulae of Heaviside, Feynman, Jefimenko and other authors.
The fields of an accelerated charge given by the Feynman are the same as those
derived from the Li\'{e}nard-Wiechert potentials but not those given by the
Jefimenko formulae. A mathematical error concerning partial space and time
derivatives in the derivation of the Jefimenko equations is pointed out.

Categories: physics.optics
Abstract: We report that resonant response with a very high quality factor can be
achieved in a planar metamaterial by introducing symmetry breaking in the shape
of its structural elements, which enables excitation of dark modes, i.e. modes
that are weakly coupled to free space.

Categories: quant-ph, cond-mat.other, physics.optics
Abstract: We study Gaussian valence bond states of continuous variable systems,
obtained as the outputs of projection operations from an ancillary space of M
infinitely entangled bonds connecting neighboring sites, applied at each of $N$
sites of an harmonic chain. The entanglement distribution in Gaussian valence
bond states can be controlled by varying the input amount of entanglement
engineered in a (2M+1)-mode Gaussian state known as the building block, which
is isomorphic to the projector applied at a given site. We show how this
mechanism can be interpreted in terms of multiple entanglement swapping from
the chain of ancillary bonds, through the building blocks. We provide optical
schemes to produce bisymmetric three-mode Gaussian building blocks (which
correspond to a single bond, M=1), and study the entanglement structure in the
output Gaussian valence bond states. The usefulness of such states for quantum
communication protocols with continuous variables, like telecloning and
teleportation networks, is finally discussed.

Categories: physics.soc-ph
Abstract: We introduce an immunization method where the percentage of required
vaccinations for immunity are close to the optimal value of a targeted
immunization scheme of highest degree nodes. Our strategy retains the advantage
of being purely local, without the need of knowledge on the global network
structure or identification of the highest degree nodes. The method consists of
selecting a random node and asking for a neighbor that has more links than
himself or more than a given threshold and immunizing him. We compare this
method to other efficient strategies on three real social networks and on a
scale-free network model, and find it to be significantly more effective.

Categories: physics.ed-ph, physics.soc-ph
Abstract: The evolution of Turkish Journal of Chemistry (Turk J. Chem) Hirsch index
(h-index) over the period 1995-2005 is studied and determined in the case of
the self and without self-citations. It is seen that the effect of Hirsch index
of Turk J. Chem has a highly positive trend during the last five years. It
proves that Turk J. Chem is improving itself both in quantity and quality since
h-index reflects peer review, and peer review reflects research quality of a
journal.

Categories: physics.space-ph, physics.plasm-ph
Abstract: We present Cluster measurements of large electric fields correlated with
intense downward field-aligned currents, and show that the data can be
reproduced by a simple model of ionospheric plasma depletion caused by the
currents. This type of magnetosphere-ionosphere interaction may be important
when considering the mapping between these two regions of space.

Categories: physics.ed-ph, physics.comp-ph
Abstract: Among the ideas to be conveyed to students in an introductory quantum course,
we have the pivotal idea championed by Dirac that functions correspond to
column vectors (kets) and that differential operators correspond to matrices
(ket-bras) acting on those vectors. The MATLAB (matrix-laboratory) programming
environment is especially useful in conveying these concepts to students
because it is geared towards the type of matrix manipulations useful in solving
introductory quantum physics problems. In this article, we share MATLAB codes
which have been developed at WPI, focusing on 1D problems, to be used in
conjunction with Griffiths' introductory text.

Categories: physics.geo-ph, physics.space-ph
Abstract: Planetary topography can either be modeled as a load supported by the
lithosphere, or as a dynamical effect due to lithospheric flexure caused by
mantle convection. In both cases the response of the lithosphere to external
forces can be calculated with the theory of thin elastic plates or shells. On
one-plate planets the spherical geometry of the lithospheric shell plays an
important role in the flexure mechanism. So far the equations governing the
deformations and stresses of a spherical shell have only been derived under the
assumption of a shell of constant thickness. However local studies of gravity
and topography data suggest large variations in the thickness of the
lithosphere. In this article we obtain the scalar flexure equations governing
the deformations of a thin spherical shell with variable thickness or variable
Young's modulus. The resulting equations can be solved in succession, except
for a system of two simultaneous equations, the solutions of which are the
transverse deflection and an associated stress function. In order to include
bottom loading generated by mantle convection, we extend the method of stress
functions to include loads with a toroidal tangential component. We further
show that toroidal tangential displacement always occurs if the shell thickness
varies, even in the absence of toroidal loads. We finally prove that the
degree-one harmonic components of the transverse deflection and of the toroidal
tangential displacement are independent of the elastic properties of the shell
and are associated with translational and rotational freedom. The flexure
equations for a shell of variable thickness are useful not only for the
prediction of the gravity signal in local admittance studies, but also for the
construction of stress maps in tectonic analysis.

Categories: cond-mat.other, physics.atom-ph, quant-ph
Abstract: It is shown that fermionic polar molecules or atoms in a bilayer optical
lattice can undergo the transition to a state with circulating currents, which
spontaneously breaks the time reversal symmetry. Estimates of relevant
temperature scales are given and experimental signatures of the circulating
current phase are identified. Related phenomena in bosonic and spin systems
with ring exchange are discussed.

Categories: physics.ins-det
Abstract: The design, construction, and performance of a linear radio-frequency ion
trap (RFQ) intended for use in the Enriched Xenon Observatory (EXO) are
described. EXO aims to detect the neutrinoless double-beta decay of $^{136}$Xe
to $^{136}$Ba. To suppress possible backgrounds EXO will complement the
measurement of decay energy and, to some extent, topology of candidate events
in a Xe filled detector with the identification of the daughter nucleus
($^{136}$Ba). The ion trap described here is capable of accepting, cooling, and
confining individual Ba ions extracted from the site of the candidate
double-beta decay event. A single trapped ion can then be identified, with a
large signal-to-noise ratio, via laser spectroscopy.

Categories: physics.gen-ph
Abstract: It is shown that a gravitationally collapsing black hole acts as an ultrahigh
energy particle accelerator that can accelerate particles to energies
inconceivable in any terrestrial particle accelerator, and that when the energy
E of the particles comprising the matter in the black hole is $ \sim 10^{2} $
GeV or more,or equivalently the temperature T is $ \sim 10^{15}$ K or more, the
entire matter in the black hole will be in the form of quark-gluon plasma
permeated by leptons.

Categories: physics.gen-ph
Abstract: A critique of the singularity theorems of Penrose, Hawking, and Geroch is
given. It is pointed out that a gravitationally collapsing black hole acts as
an ultrahigh energy particle accelerator that can accelerate particles to
energies inconceivable in any terrestrial particle accelerator, and that when
the energy $E$ of the particles comprising matter in a black hole is $\sim
10^{2} GeV$ or more, or equivalently, the temperature $T$ is $\sim 10^{15} K$
or more, the entire matter in the black hole is converted into quark-gluon
plasma permeated by leptons. As quarks and leptons are fermions, it is
emphasized that the collapse of a black-hole to a space-time singularity is
inhibited by Pauli's exclusion principle. It is also suggested that ultimately
a black hole may end up either as a stable quark star, or as a pulsating quark
star which may be a source of gravitational radiation, or it may simply explode
with a mini bang of a sort.

Categories: physics.gen-ph
Abstract: We argue about a possible scenario of physical reality based on the
parallelism between Poincare group and the sunyata philosophy of Nagarjuna. The
notion of "relational" is the common denominator of two views. We have
approached the relational concept in third-person perspective (ontic level). It
is possible to deduce different physical consequence and interpretation through
first-person perspective approach. This relational interpretation leave open
the questions: i)we must abandon the idea for a physical system the possibility
to extract completeness information? ii)we must abandon the idea to infer a
possible structure of physical reality?

Categories: physics.bio-ph, physics.comp-ph
Abstract: We propose a new theoretical method for the calculation of the interaction
energy between macromolecular systems at large distances. The method provides a
linear scaling of the computing time with the system size and is considered as
an alternative to the well known fast multipole method. Its efficiency,
accuracy and applicability to macromolecular systems is analyzed and discussed
in detail.

Categories: physics.optics, physics.chem-ph
Abstract: We use numerical optimization to study the properties of (1) the class of
one-dimensional potential energy functions and (2) systems of point charges in
two-dimensions that yield the largest hyperpolarizabilities, which we find to
be within 30% of the fundamental limit. We investigate the character of the
potential energy functions and resulting wavefunctions and find that a broad
range of potentials yield the same intrinsic hyperpolarizability ceiling of
0.709.

Categories: physics.soc-ph
Abstract: Many real systems possess accelerating statistics where the total number of
edges grows faster than the network size. In this paper, we propose a simple
weighted network model with accelerating growth. We derive analytical
expressions for the evolutions and distributions for strength, degree, and
weight, which are relevant to accelerating growth. We also find that
accelerating growth determines the clustering coefficient of the networks.
Interestingly, the distributions for strength, degree, and weight display a
transition from scale-free to exponential form when the parameter with respect
to accelerating growth increases from a small to large value. All the
theoretical predictions are successfully contrasted with extensive numerical
simulations.

Categories: physics.gen-ph
Abstract: We develop a class of soliton solution of {\it linear} Schr\"odinger equation
without external potential. The quantum probability density generates its own
boundary inside which there is internal vibration whose wave number is
determined by the velocity of the particle as firstly conjectured by de
Broglie. Assuming resonance of the internal vibration will lead to quantization
of particle's momentum in term of wave number of the envelope quantum
probability density. We further show that the linearity of the Schr\"odinger
equation allows us to have non-interacting many solitons solution through
superposition, each describing a particle with equal mass.

Categories: q-fin.ST, physics.soc-ph
Abstract: Prices of commodities or assets produce what is called time-series. Different
kinds of financial time-series have been recorded and studied for decades.
Nowadays, all transactions on a financial market are recorded, leading to a
huge amount of data available, either for free in the Internet or commercially.
Financial time-series analysis is of great interest to practitioners as well as
to theoreticians, for making inferences and predictions. Furthermore, the
stochastic uncertainties inherent in financial time-series and the theory
needed to deal with them make the subject especially interesting not only to
economists, but also to statisticians and physicists. While it would be a
formidable task to make an exhaustive review on the topic, with this review we
try to give a flavor of some of its aspects.

Categories: nlin.PS, physics.optics
Abstract: We demonstrate existence of waves localized at the interface of two nonlinear
periodic media with different coefficients of the cubic nonlinearity via the
one-dimensional Gross--Pitaevsky equation. We call these waves the surface gap
solitons (SGS). In the case of smooth symmetric periodic potentials, we study
analytically bifurcations of SGS's from standard gap solitons and determine
numerically the maximal jump of the nonlinearity coefficient allowing for the
SGS existence. We show that the maximal jump vanishes near the thresholds of
bifurcations of gap solitons. In the case of continuous potentials with a jump
in the first derivative at the interface, we develop a homotopy method of
continuation of SGS families from the solution obtained via gluing of parts of
the standard gap solitons and study existence of SGS's in the photonic band
gaps. We explain the termination of the SGS families in the interior points of
the band gaps from the bifurcation of linear bound states in the continuous
non-smooth potentials.

Categories: physics.comp-ph, cs.DS, nlin.AO
Abstract: As networks and their structure have become a major field of research, a
strong demand for network visualization has emerged. We address this challenge
by formalizing the well established spring layout in terms of dynamic
equations. We thus open up the design space for new algorithms. Drawing from
the knowledge of systems design, we derive a layout algorithm that remedies
several drawbacks of the original spring layout. This new algorithm relies on
the balancing of two antagonistic forces. We thus call it {\em arf} for
"attractive and repulsive forces". It is, as we claim, particularly suited for
a dynamic layout of smaller networks ($n < 10^3$). We back this claim with
several application examples from on going complex systems research.

Categories: physics.plasm-ph
Abstract: Axisymmetric equilibria with incompressible flows of arbitrary direction are
studied in the framework of magnetohydrodynamics under a variety of physically
relevant side conditions. To this end a set of pertinent non-linear ODEs are
transformed to quasilinear ones and the respective initial value problem is
solved numerically with appropriately determined initial values near the
magnetic axis. Several equilibria are then constructed surface by surface. The
non field aligned flow results in novel configurations with a single magnetic
axis, toroidal shell configurations in which the plasma is confined within a
couple of magnetic surfaces and double shell-like configurations. In addition,
the flow affects the elongation and triangularity of the magnetic surfaces.

Categories: physics.bio-ph
Abstract: In the present letter we suggest a new theoretical model for a quantitative
description of the magnetoreception mechanism in birds. The considered
mechanism involves two types of iron minerals (magnetite and maghemite) which
were found in subcellular compartments within sensory dendrites of the upper
beak of several bird species. The analysis of forces acting between the iron
particles shows that the orientation of the external geomagnetic field can
significantly change the probability of the mechanosensitive ion channels
opening and closing. The performed theoretical analysis shows that the
suggested magnetoreceptor system might be a sensitive biological magnetometer
providing an essential part of the magnetic map for navigation.

Categories: math-ph, cond-mat.other, math.MP, nlin.CD, physics.class-ph
Abstract: Generalization of the Kac integral and Kac method for paths measure based on
the Levy distribution has been used to derive fractional diffusion equation.
Application to nonlinear fractional Ginzburg-Landau equation is discussed.

Categories: physics.gen-ph
Abstract: Admitting the validity of Lorentz transformations for the space as time
coordinates of the same event we derive their differential form in order to
underline the correct prerequisites for the application of time and length
contraction or dilation effects. Furthermore we quantify the simultaneity error
occurring in the relativity theory. Having done this, we analyse the root cause
of these effects and identify it with a finite phase velocity associated with
the moving frame. We define this phase velocity by analogy to the de Broglie
wave associated with a moving particle. Based on this construct we demonstrate
that the phase of the de Broglie waves further extended for stationary
particles is a relativistic invariant being the same for all corresponding
observers. Also the phase of the electromagnetic waves transporting energy at
light speed is a relativistic invariant. Therefore the universe and its matter
/ energy may be seen as a superposition of waves propagating such that their
phase is the same for all corresponding observers. The wave phase may replace
the time as an invariant and universal reference.

Categories: physics.class-ph
Abstract: This paper describes the appearance of abnormal film thickness features
formed in elastohydrodynamic contacts lubricated by a fatty alcohol.
Experiments were conducted by varying the slide to roll ratio between a steel
ball and a glass disk in a ball-on-disk type device. Lauric alcohol was used as
lubricant and film thickness was measured in the contact area by optical
interferometry. Experimental results showed that the film thickness
distributions under pure rolling conditions remained classical whereas the film
shape changed when the slide to roll ratio was increased. The thickness in the
central contact area increased and in the same time inlet and exit film
thicknesses were modified. In addition, the film shapes observed when the ball
surface was moving faster than the disk one and those obtained in the opposite
case were different, i.e. when opposite signs but equal absolute values of the
slide to roll ratio were applied.

Categories: physics.class-ph
Abstract: A conclusive demonstration has been provided that the nature of the
shear-thinning, that affects both film thickness and traction in EHL contacts,
follows the ordinary power-law rule that has been described by many empirical
models of which Carreau is but one example. This was accomplished by accurate
measurements in viscometers of the shear response of a PAO that possesses a
very low critical stress for shear-thinning and accurate measurements
in-contact of film thickness and traction under conditions which accentuate the
shear-thinning effect. The in-contact central film thickness and traction were
entirely predictable from the rheological properties obtained from viscometers
using simple calculations. These data should be invaluable to researchers
endeavoring to accurately simulate Hertz zone behavior since the shear-thinning
rheology is extensively characterized and accurate in-contact data are
available to test. In addition, a new model has been introduced that may be
useful for the rheological characterization of mixtures.

Categories: physics.class-ph
Abstract: After the pioneered experimental works on superlubricity by Martin et al. on
MoS2 [1], Hirano et al. on tungsten and silicon [2] and the further
confirmation by Dienwiebel et al. on graphite [3], many groups around the word
investigated the occurrence of near frictionless sliding contacts. This large
mobilization of tribologists, material sciences specialists and physicists has
lead to emerging solutions involving new materials and coatings, the most
promising being carbon based like graphite, diamond, carbon composites or
diamond-like-carbons. Some of them are currently used in practical
applications. The situation is different especially in EHL: the highest
friction coefficients are close to 10% when traction fluids are involved, i.e.
fluids that have especially designed to transmit the highest friction, and they
vary within 3-6% for the rest of lubricants. The range of variation is
consequently very narrow and these typical values are really low compared to
those obtained in dry contacts: as a consequence the gain expected from a super
low traction regime in lubrication will be probably more limited, especially in
the case of experiments conducted at the meso or macro scales. This weak
perspective could be one explanation on the relatively low number of articles
in recent literature dealing with lubricated superlubricity in the above
conditions.

Categories: physics.ins-det, nucl-ex
Abstract: A lead-glass hodoscope calorimeter that was constructed for use in the
Jefferson Lab Real Compton Scattering experiment is described. The detector
provides a measurement of the coordinates and the energy of scattered photons
in the GeV energy range with resolutions of 5 mm and 6%/\sqrt(E{\gamma} [GeV]).
Features of both the detector design and its performance in the high luminosity
environment during the experiment are presented.

Categories: physics.soc-ph, physics.data-an
Abstract: We compute the stationary in-degree probability, $P_{in}(k)$, for a growing
network model with directed edges and arbitrary out-degree probability. In
particular, under preferential linking, we find that if the nodes have a light
tail (finite variance) out-degree distribution, then the corresponding
in-degree one behaves as $k^{-3}$. Moreover, for an out-degree distribution
with a scale invariant tail, $P_{out}(k)\sim k^{-\alpha}$, the corresponding
in-degree distribution has exactly the same asymptotic behavior only if
$2<\alpha<3$ (infinite variance). Similar results are obtained when
attractiveness is included. We also present some results on descriptive
statistics measures %descriptive statistics such as the correlation between the
number of in-going links, $D_{in}$, and outgoing links, $D_{out}$, and the
conditional expectation of $D_{in}$ given $D_{out}$, and we calculate these
measures for the WWW network. Finally, we present an application to the
scientific publications network. The results presented here can explain the
tail behavior of in/out-degree distribution observed in many real networks.

Categories: physics.ed-ph
Abstract: Students, after they leave our care, are called to solve the diverse problems
of the world, so we should teach to increase transfer: the ability to apply
fundamental principles to new problems and contexts. This ability is rare. The
following pages are from a workshop for faculty on designing courses that
promote transfer. I discuss two design principles: to name the transferable
ideas and to illustrate them with examples from diverse subjects. The
discussion uses dimensional reasoning as the example of a valuable transferable
idea, illustrating it with three diverse examples.

Categories: cond-mat.other, physics.data-an
Abstract: Distributions following a power-law are an ubiquitous phenomenon. Methods for
determining the exponent of a power-law tail by graphical means are often used
in practice but are intrinsically unreliable. Maximum likelihood estimators for
the exponent are a mathematically sound alternative to graphical methods.

Categories: physics.gen-ph
Abstract: The holographic upper bound on entropy is applied to the gravitational action
associated with the non-relativistic contraction of a nebula. A critical radius
is identified, as a function of the initial radius and mass, for which the
number of bits associated with the action would equal the maximum number of
bits allowed to the body. The gravitational action of a typical star
approximately saturates the holographic bound, perhaps suggesting a physical
link between holographic principles and astrophysical processes.

Categories: physics.comp-ph, physics.optics, quant-ph
Abstract: We present a method of computing Casimir forces for arbitrary geometries,
with any desired accuracy, that can directly exploit the efficiency of standard
numerical-electromagnetism techniques. Using the simplest possible
finite-difference implementation of this approach, we obtain both agreement
with past results for cylinder-plate geometries, and also present results for
new geometries. In particular, we examine a piston-like problem involving two
dielectric and metallic squares sliding between two metallic walls, in two and
three dimensions, respectively, and demonstrate non-additive and non-monotonic
changes in the force due to these lateral walls.

Categories: cond-mat.mes-hall, physics.optics
Abstract: Normal-incidence transmission and dispersion properties of optical
multilayers and one-dimensional stepwise potential barriers in the
non-tunneling regime are analytically investigated. The optical paths of every
constituent layer in a multilayer structure, as well as the parameters of every
step of the stepwise potential barrier, are constrained by a generalized
quarter-wave condition. No other restrictions on the structure geometry is
imposed, i.e., the layers are arranged arbitrarily. We show that the density of
states (DOS) spectra of the multilayer or barrier in question are subject to
integral conservation rules similar to the Barnett-Loudon sum rule but ocurring
within a finite frequency or energy interval. In the optical case, these
frequency intervals are regular. For the potential barriers, only non-periodic
energy intervals can be present in the spectrum of any given structure, and
only if the parameters of constituent potential steps are properly chosen.
  Abstract The integral conservation relations derived analytically have also
been verified numerically. The relations can be used in dispersion-engineered
multilayer-based devices, e.g., ultrashort pulse compressors or ultracompact
optical delay lines, as well as to design multiple-quantum-well electronic
heterostructures with engineered DOS.

Categories: q-bio.SC, physics.ed-ph, q-bio.QM
Abstract: A practical introduction to stochastic modelling of reaction-diffusion
processes is presented. No prior knowledge of stochastic simulations is
assumed. The methods are explained using illustrative examples. The article
starts with the classical Gillespie algorithm for the stochastic modelling of
chemical reactions. Then stochastic algorithms for modelling molecular
diffusion are given. Finally, basic stochastic reaction-diffusion methods are
presented. The connections between stochastic simulations and deterministic
models are explained and basic mathematical tools (e.g. chemical master
equation) are presented. The article concludes with an overview of more
advanced methods and problems.

Categories: q-bio.PE, astro-ph, physics.geo-ph
Abstract: Data on the prevalence of bone cancer in dinosaurs is available from past
radiological examination of preserved bones. We statistically test this data
for consistency with rates extrapolated from information on bone cancer in
modern vertebrates, and find that there is no evidence of a different rate.
Thus, this test provides no support for a possible role of ionizing radiation
in the K-T extinction event.

Categories: physics.flu-dyn, nlin.CD
Abstract: We compute solutions of the Lagrangian-Averaged Navier-Stokes alpha-model
(LANS) for significantly higher Reynolds numbers (up to Re 8300) than have
previously been accomplished. This allows sufficient separation of scales to
observe a Navier-Stokes (NS) inertial range followed by a 2nd LANS inertial
range. The analysis of the third-order structure function scaling supports the
predicted l^3 scaling; it corresponds to a k^(-1) scaling of the energy
spectrum. The energy spectrum itself shows a different scaling which goes as
k^1. This latter spectrum is consistent with the absence of stretching in the
sub-filter scales due to the Taylor frozen-in hypothesis employed as a closure
in the derivation of LANS. These two scalings are conjectured to coexist in
different spatial portions of the flow. The l^3 (E(k) k^(-1)) scaling is
subdominant to k^1 in the energy spectrum, but the l^3 scaling is responsible
for the direct energy cascade, as no cascade can result from motions with no
internal degrees of freedom. We verify the prediction for the size of the LANS
attractor resulting from this scaling. From this, we give a methodology either
for arriving at grid-independent solutions for LANS, or for obtaining a
formulation of a LES optimal in the context of the alpha models. The fully
converged grid-independent LANS may not be the best approximation to a direct
numerical simulation of the NS equations since the minimum error is a balance
between truncation errors and the approximation error due to using LANS instead
of the primitive equations. Furthermore, the small-scale behavior of LANS
contributes to a reduction of flux at constant energy, leading to a shallower
energy spectrum for large alpha. These small-scale features, do not preclude
LANS to reproduce correctly the intermittency properties of high Re flow.

Categories: physics.gen-ph
Abstract: This paper revisits previous papers related to the theory of relativity.
Afterwards, a reconsideration of the hypothesis of ether-dragging is discussed.
The ether is compatible with the theory of relativity and historical
experiments; this paper explains the Michelson-Morley experiment using the
ether-dragging hypothesis without the orthodox interpretation that the speed c
is a fixed constant in terms of any system of inertial coordinates.

Categories: physics.atom-ph
Abstract: In this paper, we used the multiconfiguration Dirac-Fock method to compute
with high precision the influence of the hyperfine interaction on the
$[Ar]3d^{10} 4s4p ^3P_0$ level lifetime in Zn-like ions for stable and some
quasi-stable isotopes of nonzero nuclear spin between Z=30 and Z=92. The
influence of this interaction on the $[Ar]3d^{10} 4s4p ^3P_1 - [Ar]3d^{10} 4s4p
^3P_0$ separation energy is also calculated for the same ions.

Categories: physics.optics, nlin.CD
Abstract: Dielectric micro-cavities are widely used as laser resonators and
characterizations of their spectra are of interest for various applications. We
experimentally investigate micro-lasers of simple shapes (Fabry-Perot, square,
pentagon, and disk). Their lasing spectra consist mainly of almost equidistant
peaks and the distance between peaks reveals the length of a quantized periodic
orbit. To measure this length with a good precision, it is necessary to take
into account different sources of refractive index dispersion. Our experimental
and numerical results agree with the superscar model describing the formation
of long-lived states in polygonal cavities. The limitations of the
two-dimensional approximation are briefly discussed in connection with
micro-disks.

Categories: physics.soc-ph, physics.class-ph
Abstract: We study cascading failures in networks using a dynamical flow model based on
simple conservation and distribution laws to investigate the impact of
transient dynamics caused by the rebalancing of loads after an initial network
failure (triggering event). It is found that considering the flow dynamics may
imply reduced network robustness compared to previous static overload failure
models. This is due to the transient oscillations or overshooting in the loads,
when the flow dynamics adjusts to the new (remaining) network structure. We
obtain {\em upper} and {\em lower} limits to network robustness, and it is
shown that {\it two} time scales $\tau$ and $\tau_0$, defined by the network
dynamics, are important to consider prior to accurately addressing network
robustness or vulnerability. The robustness of networks showing cascading
failures is generally determined by a complex interplay between the network
topology and flow dynamics, where the ratio $\chi=\tau/\tau_0$ determines the
relative role of the two of them.

Categories: physics.chem-ph, physics.optics
Abstract: The influence of excited-state absorption (ESA) and two-exciton processes on
a coherent population transfer with intense ultrashort chirped pulses in
molecular systems in solution has been studied. An unified treatment of
adiabatic rapid passage (ARP) in such systems has been developed using a
three-state electronic system with relaxation treated as a diffusion on
electronic potential energy surfaces. We have shown that ESA has a profound
effect on coherent population transfer in large molecules that necessitates a
more accurate interpretation of experimental data. A simple and physically
clear model for ARP in molecules with three electronic states in solution has
been developed by extending the Landau-Zener calculations putting in a third
level to random crossing of levels. A method for quantum control of two-exciton
states in molecular complexes has been proposed.

Categories: physics.atom-ph
Abstract: We report on the frequency performance of a low cost (~500$) radio-frequency
sine wave generator, using direct digital synthesis (DDS) and a
field-programmable gate array (FPGA). The output frequency of the device may be
changed dynamically to any arbitrary value ranging from DC to 10 MHz without
any phase slip. Sampling effects are substantially reduced by a high sample
rate, up to 1 MHz, and by a large memory length, more than 2.10^5 samples. By
using a low noise external oscillator to clock the DDS, we demonstrate a phase
noise as low as that of the master clock, that is at the level of -113
dB.rad^2/Hz at 1 Hz from the carrier for an output frequency of 3.75 MHz. The
device is successfully used to confine an ultracold atomic cloud of rubidium 87
in a RF-based trap, and there is no extra heating from the RF source.

Categories: physics.gen-ph
Abstract: The general relativity is the base for any exact evolutionary theory of large
scale structures. We calculate the universal 2+1-dimensional plane equations of
gravitational field in general relativity. Based on the equations, the
evolutions of disk nebula are discussed. A system of nebula can form binary
stars or single star for different conditions. While any simplified linear
theory forms only a single star system. It is proved that the nonlinear
interactions are very general, so the binary stars are also common.

Categories: physics.gen-ph
Abstract: After negative temperature is restated, we find that it will derive
necessarily decrease of entropy. Negative temperature is based on the Kelvin
scale and the condition dU>0 and dS<0. Conversely, there is also negative
temperature for dU<0 and dS>0. But, negative temperature is contradiction with
usual meaning of temperature and with some basic concepts of physics and
mathematics. It is a question in nonequilibrium thermodynamics. We proposed a
possibility of decrease of entropy due to fluctuation magnified and internal
interactions in some isolated systems. From this we discuss some possible
examples and theories.

Categories: physics.flu-dyn, astro-ph, nlin.CD, physics.plasm-ph
Abstract: This paper is a detailed report on a programme of simulations used to settle
a long-standing issue in the dynamo theory and demonstrate that the fluctuation
dynamo exists in the limit of large magnetic Reynolds number Rm>>1 and small
magnetic Prandtl number Pm<<1. The dependence of the critical Rm_c vs. the
hydrodynamic Reynolds number Re is obtained for 1<Re<6700. In the limit Pm<<1,
Rm_c is ~3 times larger than for Pm>1. The stability curve Rm_c(Re) (and, it is
argued, the nature of the dynamo) is substantially different from the case of
the simulations and liquid-metal experiments with a mean flow. It is not as yet
possible to determine numerically whether the growth rate is ~Rm^{1/2} in the
limit Re>>Rm>>1, as should be the case if the dynamo is driven by the
inertial-range motions. The magnetic-energy spectrum in the low-Pm regime is
qualitatively different from the Pm>1 case and appears to develop a negative
spectral slope, although current resolutions are insufficient to determine its
asymptotic form. At 1<Rm<Rm_c, the magnetic fluctuations induced via the
tangling by turbulence of a weak mean field are investigated and the
possibility of a k^{-1} spectrum above the resistive scale is examined. At low
Rm<1, the induced fluctuations are well described by the quasistatic
approximation; the k^{-11/3} spectrum is confirmed for the first time in direct
numerical simulations.

Categories: q-fin.ST, physics.soc-ph
Abstract: The dynamics of many socioeconomic systems is determined by the decision
making process of agents. The decision process depends on agent's
characteristics, such as preferences, risk aversion, behavioral biases, etc..
In addition, in some systems the size of agents can be highly heterogeneous
leading to very different impacts of agents on the system dynamics. The large
size of some agents poses challenging problems to agents who want to control
their impact, either by forcing the system in a given direction or by hiding
their intentionality. Here we consider the financial market as a model system,
and we study empirically how agents strategically adjust the properties of
large orders in order to meet their preference and minimize their impact. We
quantify this strategic behavior by detecting scaling relations of allometric
nature between the variables characterizing the trading activity of different
institutions. We observe power law distributions in the investment time
horizon, in the number of transactions needed to execute a large order and in
the traded value exchanged by large institutions and we show that heterogeneity
of agents is a key ingredient for the emergence of some aggregate properties
characterizing this complex system.

Categories: physics.class-ph
Abstract: The ordered addition of two Lorentz boosts is normally shown to result in a
boost by utilizing concepts from group theory and non-Euclidian geometry. We
present a method for achieving this addition by performing a sequence of
spatial rotations and uni-dimensional Lorentz transformations. The method is
first developed for two-dimensional space and it is then extended to
three-dimensional space by utilizing the commutative property of the rotation
of the y-z plane and a boost along the x-axis. The method employs only matrix
multiplication and certain invariant quantities that are natural consequences
of spatial rotations and Lorentz transformations. The combining of two boosts
in different directions into a single boost cannot be expected a priori because
we show that the converse of this statement is not true. That is, two rotations
interspersed with a boost cannot always be reduced to a single rotation
preceded and followed by boosts.

Categories: physics.class-ph
Abstract: Contact electrification and triboelectrification are well-known in the case
of dissimilar materials, however the case of charge exchange during friction
between nominally identical insulating materials is less documented. We
experimentally investigated the triboelectrification between two smooth
monocrystalline &#945;-Al 2O 3 (sapphire) antagonists by surface force
measurements with a Surface Force Apparatus (SFA). The force between a sphere
and a plane, both in sapphire, was measured as a function of the sphere-plane
distance D, before and after nano-friction tests, under dry argon atmosphere.
Respective contributions of van der Waals, water meniscus and electrostatic
forces were determined. The estimated Hamaker constant was in good agreement
with the Lifshitz theory, and the dominant meniscus attraction at low
separation could be overcome with small radius sphere. We demonstrated that
electrostatic forces were generated by the nano-friction test and we quantified
the adhesion that results from this contact-electrification. In the first stage
of the unloading process, the short range electrostatic force was found to vary
both with time and distance D. Experimental results were correlated with
surface densities of mobile charges on the two surfaces, and the
time-dependence was related to classical surface transport phenomena on alumina
surfaces.

Categories: physics.plasm-ph
Abstract: Starting from the governing equations for a quantum magnetoplasma including
the quantum Bohm potential and electron spin-1/2 effects, we show that the
system of quantum magnetohydrodynamic (QMHD) equations admit rarefactive
solitons due to the balance between nonlinearities and quantum
diffraction/tunneling effects. It is found that the electron spin-1/2 effect
introduces a pressure-like term with negative sign in the QMHD equations, which
modifies the shape of the solitary magnetosonic waves and makes them wider and
shallower. Numerical simulations of the time-dependent system shows the
development of rarefactive QMHD solitary waves that are modified by the spin
effects.

Successful predictions are among the most compelling validations of any
model. Extracting falsifiable predictions from nonlinear multiparameter models
is complicated by the fact that such models are commonly sloppy, possessing
sensitivities to different parameter combinations that range over many decades.
Here we discuss how sloppiness affects the sorts of data that best constrain
model predictions, makes linear uncertainty approximations dangerous, and
introduces computational difficulties in Monte-Carlo uncertainty analysis. We
also present a useful test problem and suggest refinements to the standards by
which models are communicated.

In most vertebrate species, the body axis is generated by the formation of
repeated transient structures called somites. This spatial periodicity in
somitogenesis has been related to the temporally sustained oscillations in
certain mRNAs and their associated gene products in the cells forming the
presomatic mesoderm. The mechanism underlying these oscillations have been
identified as due to the delays involved in the synthesis of mRNA and
translation into protein molecules [J. Lewis, Current Biol. {\bf 13}, 1398
(2003)]. In addition, in the zebrafish embryo intercellular Notch signalling
couples these oscillators and a longitudinal positional information signal in
the form of an Fgf8 gradient exists that could be used to transform these
coupled temporal oscillations into the observed spatial periodicity of somites.
Here we consider a simple model based on this known biology and study its
consequences for somitogenesis. Comparison is made with the known properties of
somite formation in the zebrafish embryo . We also study the effects of
localized Fgf8 perturbations on somite patterning.

We have developed a linearization method to investigate the subthreshold
oscillatory behaviors in nonlinear autonomous systems. By considering firstly
the neuronal system as an example, we show that this theoretical approach can
predict quantitatively the subthreshold oscillatory activities, including the
damping coefficients and the oscillatory frequencies which are in good
agreement with those observed in experiments. Then we generalize the
linearization method to an arbitrary autonomous nonlinear system. The detailed
extension of this theoretical approach is also presented and further discussed.

The widespread use of genetic testing in high risk pregnancies has created
strong interest in rapid and accurate molecular diagnostics for common
chromosomal aneuploidies. We show here that digital polymerase chain reaction
(dPCR) can be used for accurate measurement of trisomy 21 (Down's Syndrome),
the most common human aneuploidy. dPCR is generally applicable to any
aneuploidy, does not depend on allelic distribution or gender, and is able to
detect signals in the presence of mosaics or contaminating maternal DNA.

Biologists are leading current research on genome characterization
(sequencing, alignment, transcription), providing a huge quantity of raw data
about many genome organisms. Extracting knowledge from this raw data is an
important process for biologists, using usually data mining approaches.
However, it is difficult to deals with these genomic information using actual
bioinformatics data mining tools, because data are heterogeneous, huge in
quantity and geographically distributed. In this paper, we present a new
approach between data mining and virtual reality visualization, called visual
data mining. Indeed Virtual Reality becomes ripe, with efficient display
devices and intuitive interaction in an immersive context. Moreover, biologists
use to work with 3D representation of their molecules, but in a desktop
context. We present a software solution, Genome3DExplorer, which addresses the
problem of genomic data visualization, of scene management and interaction.
This solution is based on a well-adapted graphical and interaction paradigm,
where local and global topological characteristics of data are easily visible,
on the contrary to traditional genomic database browsers, always focused on the
zoom and details level.

This paper presents a stability test for a class of interconnected nonlinear
systems motivated by biochemical reaction networks. One of the main results
determines global asymptotic stability of the network from the diagonal
stability of a "dissipativity matrix" which incorporates information about the
passivity properties of the subsystems, the interconnection structure of the
network, and the signs of the interconnection terms. This stability test
encompasses the "secant criterion" for cyclic networks presented in our
previous paper, and extends it to a general interconnection structure
represented by a graph. A second main result allows one to accommodate state
products. This extension makes the new stability criterion applicable to a
broader class of models, even in the case of cyclic systems. The new stability
test is illustrated on a mitogen activated protein kinase (MAPK) cascade model,
and on a branched interconnection structure motivated by metabolic networks.
Finally, another result addresses the robustness of stability in the presence
of diffusion terms in a compartmental system made out of identical systems.

Mechanistic home range models are important tools in modeling animal dynamics
in spatially-complex environments. We introduce a class of stochastic models
for animal movement in a habitat of varying preference. Such models interpolate
between spatially-implicit resource selection analysis (RSA) and
advection-diffusion models, possessing these two models as limiting cases. We
find a closed-form solution for the steady-state (equilibrium) probability
distribution u* using a factorization of the redistribution operator into
symmetric and diagonal parts. How space use is controlled by the preference
function w then depends on the characteristic width of the redistribution
kernel: when w changes rapidly compared to this width, u* ~ w, whereas on
global scales large compared to this width, u* ~ w^2. We analyse the behavior
at discontinuities in w which occur at habitat type boundaries. We simulate the
dynamics of space use given two-dimensional prey-availability data and explore
the effect of the redistribution kernel width. Our factorization allows such
numerical simulations to be done extremely fast; we expect this to aid the
computationally-intensive task of model parameter fitting and inverse modeling.

Transcription networks, and other directed networks can be characterized by
some topological observables such as for example subgraph occurrence (network
motifs). In order to perform such kind of analysis, it is necessary to be able
to generate suitable randomized network ensembles. Typically, one considers
null networks with the same degree sequences of the original ones. The commonly
used algorithms sometimes have long convergence times, and sampling problems.
We present here an alternative, based on a variant of the importance sampling
Montecarlo developed by Chen et al. [1].

It is basic question in biology and other fields to identify the char-
acteristic properties that on one hand are shared by structures from a
particular realm, like gene regulation, protein-protein interaction or neu- ral
networks or foodwebs, and that on the other hand distinguish them from other
structures. We introduce and apply a general method, based on the spectrum of
the normalized graph Laplacian, that yields repre- sentations, the spectral
plots, that allow us to find and visualize such properties systematically. We
present such visualizations for a wide range of biological networks and compare
them with those for networks derived from theoretical schemes. The differences
that we find are quite striking and suggest that the search for universal
properties of biological networks should be complemented by an understanding of
more specific features of biological organization principles at different
scales.

The classical attenuation regulation of gene expression in bacteria is
considered. We propose to represent the secondary RNA structure in the leader
region of a gene or an operon by a term, and we give a probabilistic term
rewriting system modeling the whole process of such a regulation.

Escherichia coli is a motile bacterium that moves up a chemoattractant
gradient by performing a biased random walk composed of alternating runs and
tumbles. Previous models of run and tumble chemotaxis neglect one or more
features of the motion, namely (i) a cell cannot directly detect a
chemoattractant gradient but rather makes temporal comparisons of
chemoattractant concentration, (ii) rather than being entirely random, tumbles
exhibit persistence of direction, meaning that the new direction after a tumble
is more likely to be in the forward hemisphere, and (iii) rotational Brownian
motion makes it impossible for an E. coli cell to swim in a straight line
during a run. This paper presents an analytic calculation of the chemotactic
drift velocity taking account of (i), (ii) and (iii), for weak chemotaxis. The
analytic results are verified by Monte Carlo simulation. The results reveal a
synergy between temporal comparisons and persistence that enhances the drift
velocity, while rotational Brownian motion reduces the drift velocity.

An eutactic star, in a n-dimensional space, is a set of N vectors which can
be viewed as the projection of N orthogonal vectors in a N-dimensional space.
By adequately associating a star of vectors to a particular sea urchin we
propose that a measure of the eutacticity of the star constitutes a measure of
the regularity of the sea urchin. Then we study changes of regularity
(eutacticity) in a macroevolutive and taxonomic level of sea urchins belonging
to the Echinoidea Class. An analysis considering changes through geological
time suggests a high degree of regularity in the shape of these organisms
through their evolution. Rare deviations from regularity measured in
Holasteroida order are discussed.

Statistical mechanics is one of the most powerful and elegant tools in the
quantitative sciences. One key virtue of statistical mechanics is that it is
designed to examine large systems with many interacting degrees of freedom,
providing a clue that it might have some bearing on the analysis of the
molecules of living matter. As a result of data on biological systems becoming
increasingly quantitative, there is a concomitant demand that the models set
forth to describe biological systems be themselves quantitative. We describe
how statistical mechanics is part of the quantitative toolkit that is needed to
respond to such data. The power of statistical mechanics is not limited to
traditional physical and chemical problems and there are a host of interesting
ways in which these ideas can be applied in biology. This article reports on
our efforts to teach statistical mechanics to life science students and
provides a framework for others interested in bringing these tools to a
nontraditional audience in the life sciences.

MOTIVATION: Microarray technology makes it possible to measure thousands of
variables and to compare their values under hundreds of conditions. Once
microarray data are quantified, normalized and classified, the analysis phase
is essentially a manual and subjective task based on visual inspection of
classes in the light of the vast amount of information available. Currently,
data interpretation clearly constitutes the bottleneck of such analyses and
there is an obvious need for tools able to fill the gap between data processed
with mathematical methods and existing biological knowledge. RESULTS: THEA
(Tools for High-throughput Experiments Analysis) is an integrated information
processing system allowing convenient handling of data. It allows to
automatically annotate data issued from classification systems with selected
biological information coming from a knowledge base and to either manually
search and browse through these annotations or automatically generate
meaningful generalizations according to statistical criteria (data mining).
AVAILABILITY: The software is available on the website http://thea.unice.fr/

In this paper we address a general parameter estimation methodology for an
extended biokinetic degradation model [1] for poorly degradable
micropollutants. In particular we concentrate on parameter estimation of the
micropollutant degradation sub-model by specialised microorganisms. In this
case we focus on the case when only substrate degradation data are available
and prove the structural identifiability of the model. Further we consider the
problem of practical identifiability and propose experimental and related
numerical methods for unambiguous parameter estimation based on multiple
substrate degradation curves with different initial concentrations. Finally by
means of simulated pseudo-experiments we have found convincing indications that
the proposed algorithm is stable and yields appropriate parameter estimates
even in unfavourable regimes.

Predicting interactions between small molecules and proteins is a crucial
ingredient of the drug discovery process. In particular, accurate predictive
models are increasingly used to preselect potential lead compounds from large
molecule databases, or to screen for side-effects. While classical in silico
approaches focus on predicting interactions with a given specific target, new
chemogenomics approaches adopt cross-target views. Building on recent
developments in the use of kernel methods in bio- and chemoinformatics, we
present a systematic framework to screen the chemical space of small molecules
for interaction with the biological space of proteins. We show that this
framework allows information sharing across the targets, resulting in a
dramatic improvement of ligand prediction accuracy for three important classes
of drug targets: enzymes, GPCR and ion channels.

BACKGROUND: One of the most evident achievements of bioinformatics is the
development of methods that transfer biological knowledge from characterised
proteins to uncharacterised sequences. This mode of protein function assignment
is mostly based on the detection of sequence similarity and the premise that
functional properties are conserved during evolution. Most automatic approaches
developed to date rely on the identification of clusters of homologous proteins
and the mapping of new proteins onto these clusters, which are expected to
share functional characteristics. RESULTS: Here, we inverse the logic of this
process, by considering the mapping of sequences directly to a functional
classification instead of mapping functions to a sequence clustering. In this
mode, the starting point is a database of labelled proteins according to a
functional classification scheme, and the subsequent use of sequence similarity
allows defining the membership of new proteins to these functional classes. In
this framework, we define the Correspondence Indicators as measures of
relationship between sequence and function and further formulate two Bayesian
approaches to estimate the probability for a sequence of unknown function to
belong to a functional class. This approach allows the parametrisation of
different sequence search strategies and provides a direct measure of
annotation error rates. We validate this approach with a database of enzymes
labelled by their corresponding four-digit EC numbers and analyse specific
cases. CONCLUSION: The performance of this method is significantly higher than
the simple strategy consisting in transferring the annotation from the highest
scoring BLAST match and is expected to find applications in automated
functional annotation pipelines.

In many biochemical processes, proteins bound to DNA at distant sites are
brought into close proximity by loops in the underlying DNA. For example, the
function of some gene-regulatory proteins depends on such DNA looping
interactions. We present a new technique for characterizing the kinetics of
loop formation in vitro, as observed using the tethered particle method, and
apply it to experimental data on looping induced by lambda repressor. Our
method uses a modified (diffusive) hidden Markov analysis that directly
incorporates the Brownian motion of the observed tethered bead. We compare
looping lifetimes found with our method (which we find are consistent over a
range of sampling frequencies) to those obtained via the traditional
threshold-crossing analysis (which can vary depending on how the raw data are
filtered in the time domain). Our method does not involve any time filtering
and can detect sudden changes in looping behavior. For example, we show how our
method can identify transitions between long-lived, kinetically distinct states
that would otherwise be difficult to discern.

We propose a general framework for converting global and local similarities
between biological sequences to quasi-metrics. In contrast to previous works,
our formulation allows asymmetric distances, originating from uneven weighting
of strings, that may induce non-trivial partial orders on sets of biosequences.
Furthermore, the $\ell^p$-type distances considered are more general than
traditional generalized string edit distances corresponding to the $\ell^1$
case, and enable conversion of sequence similarities to distances for a much
wider class of scoring schemes. Our constructions require much less restrictive
gap penalties than the ones regularly used. Numerous examples are provided to
illustrate the concepts introduced and their potential applications.

Environment specific substitution tables have been used effectively for
distinguishing structural and functional constraints on proteins and thereby
identify their active sites (Chelliah et al. (2004)). This work explores
whether a similar approach can be used to identify specificity determining
residues (SDRs) responsible for cofactor dependence, substrate specificity or
subtle catalytic variations. We combine structure-sequence information and
functional annotation from various data sources to create structural alignments
for homologous enzymes and functional partitions therein. We develop a scoring
procedure to predict SDRs and assess their accuracy using information from
bound specific ligands and published literature.

Transforming growth factor (TGF) $\beta$ is known to have properties of both
a tumor suppressor and a tumor promoter. While it inhibits cell proliferation,
it also increases cell motility and decreases cell--cell adhesion. Coupling
mathematical modeling and experiments, we investigate the growth and motility
of oncogene--expressing human mammary epithelial cells under exposure to
TGF--$\beta$. We use a version of the well--known Fisher--Kolmogorov equation,
and prescribe a procedure for its parametrization. We quantify the simultaneous
effects of TGF--$\beta$ to increase the tendency of individual cells and cell
clusters to move randomly and to decrease overall population growth. We
demonstrate that in experiments with TGF--$\beta$ treated cells \textit{in
vitro}, TGF--$\beta$ increases cell motility by a factor of 2 and decreases
cell proliferation by a factor of 1/2 in comparison with untreated cells.

Fast, efficient and reliable algorithms for pairwise alignment of protein
structures are in ever increasing demand for analyzing the rapidly growing data
of protein structures. CLePAPS is a tool developed for this purpose. It
distinguishes itself from other existing algorithms by the use of
conformational letters, which are discretized states of 3D segmental structural
states. A letter corresponds to a cluster of combinations of the three angles
formed by C_alpha pseudobonds of four contiguous residues. A substitution
matrix called CLESUM is available to measure similarity between any two such
letters. CLePAPS regards an aligned fragment pair (AFP) as an ungapped string
pair with a high sum of pairwise CLESUM scores. Using CLESUM scores as the
similarity measure, CLePAPS searches for AFPs by simple string comparison. The
transformation which best superimposes a highly similar AFP can be used to
superimpose the structure pairs under comparison. A highly scored AFP which is
consistent with several other AFPs determines an initial alignment. CLePAPS
then joins consistent AFPs guided by their similarity scores to extend the
alignment by several `zoom-in' iteration steps. A follow-up refinement produces
the final alignment. CLePAPS does not implement dynamic programming. The
utility of CLePAPS is tested on various protein structure pairs.

The key to understanding a protein's function often lies in its
conformational dynamics. We develop a coarse-grained variational model to
investigate the interplay between structural transitions, conformational
flexibility and function of N-terminal calmodulin (nCaM) domain. In this model,
two energy basins corresponding to the ``closed'' apo conformation and ``open''
holo conformation of nCaM domain are connected by a uniform interpolation
parameter. The resulting detailed transition route from our model is largely
consistent with the recently proposed EF$\beta$-scaffold mechanism in EF-hand
family proteins. We find that the N-terminal part in calcium binding loops I
and II shows higher flexibility than the C-terminal part which form this
EF$\beta$-scaffold structure. The structural transition of binding loops I and
II are compared in detail. Our model predicts that binding loop II, with higher
flexibility and early structural change than binding loop I, dominates the
conformational transition in nCaM domain.

Various physical properties such as dipole moment, heat of formation and
energy of the most stable formation of nucleotides and bases were calculated by
PM3 (modified neglect of diatomic overlap, parametric method number 3) and AM1
(Austin model 1) methods. As distinct from previous calculations, for
nucleotides the interaction with neighbours is taken into account up to
gradient of convergence equaling 1. The dependences of these variables from the
place in the codon and the determinative degree were obtained. The difference
of these variables for codons and anticodons is shown.

A multitude of measures have been proposed to quantify the similarity between
protein 3-D structure. Among these measures, contact map overlap (CMO)
maximization deserved sustained attention during past decade because it offers
a fine estimation of the natural homology relation between proteins. Despite
this large involvement of the bioinformatics and computer science community,
the performance of known algorithms remains modest. Due to the complexity of
the problem, they got stuck on relatively small instances and are not
applicable for large scale comparison. This paper offers a clear improvement
over past methods in this respect. We present a new integer programming model
for CMO and propose an exact B &B algorithm with bounds computed by solving
Lagrangian relaxation. The efficiency of the approach is demonstrated on a
popular small benchmark (Skolnick set, 40 domains). On this set our algorithm
significantly outperforms the best existing exact algorithms, and yet provides
lower and upper bounds of better quality. Some hard CMO instances have been
solved for the first time and within reasonable time limits. From the values of
the running time and the relative gap (relative difference between upper and
lower bounds), we obtained the right classification for this test. These
encouraging result led us to design a harder benchmark to better assess the
classification capability of our approach. We constructed a large scale set of
300 protein domains (a subset of ASTRAL database) that we have called Proteus
300. Using the relative gap of any of the 44850 couples as a similarity
measure, we obtained a classification in very good agreement with SCOP. Our
algorithm provides thus a powerful classification tool for large structure
databases.

This note discusses a theoretical issue regarding the application of the
"Modular Response Analysis" method to quasi-steady state (rather than
steady-state) data.

By convention, and even more often, as an unintentional consequence of
design, time distributions of latency and infectious durations in stochastic
epidemic simulations are often exponential. The skewed distribtion typically
leads to unrealistically short times. We examine the effects of altering the
distribution latency and infectious times by comparing the key results after
simulation with exponential and gamma distributions in a homogeneous mixing
model aswell as a model with regional divisions connected by a travel intensity
matrix. We show a delay in spread with more realistic latency times and offer
an explanation of the effect.

import * as THREE from 'three';

const UNIFORMS = {
    // rgba
    u_g1_color: new THREE.Uniform(new THREE.Vector4(0, 0, 0, 1))
};

const CNC_LASER_VERT_SHADER = [
    'varying float v_g_code;',
    'attribute float a_g_code;',
    'void main(){',
    '    v_g_code = a_g_code;',
    '    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
    '}'
].join('');

const CNC_LASER_FRAG_SHADER = [
    'uniform vec4 u_g1_color;',
    'varying float v_g_code;',
    'void main(){',
    '    if(v_g_code == 0.0){',
    '        discard;',
    '    }',
    '    gl_FragColor = u_g1_color;',
    '}'
].join('');

const motionColor = {
    'G0': new THREE.Color(0xc8c8c8),
    'G1': new THREE.Color(0x000000),
    'unknown': new THREE.Color(0x000000)
};

class ToolPathRenderer {
    render(toolPath) {
        const { headerType, mode, movementMode, data } = toolPath;

        // now only support cnc&laser
        if (!['cnc', 'laser'].includes(headerType)) {
            return null;
        }

        if (headerType === 'laser') {
            if (mode === 'greyscale' && movementMode === 'greyscale-dot') {
                return this.parseToPoints(data);
            } else {
                return this.parseToLine(data);
            }
        } else {
            return this.parseToLine(data);
        }
    }

    parseToLine(data) {
        const positions = [];
        const gCodes = [];

        let state = {
            G: 0,
            X: 0,
            Y: 0,
            Z: 0
        };
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            const newState = { ...state };
            item.G !== undefined && (newState.G = item.G);
            item.X !== undefined && (newState.X = item.X);
            item.Y !== undefined && (newState.Y = item.Y);
            item.Z !== undefined && (newState.Z = item.Z);

            if ((state.G === 1) && (newState.G === 0)) {
                positions.push(state.X);
                positions.push(state.Y);
                positions.push(state.Z);
                gCodes.push(newState.G);
            }

            if (state.G !== newState.G
                || state.X !== newState.X
                || state.Y !== newState.Y
                || state.Z !== newState.Z) {
                state = newState;
                positions.push(state.X);
                positions.push(state.Y);
                positions.push(state.Z);
                gCodes.push(state.G);
            }
        }

        const bufferGeometry = new THREE.BufferGeometry();
        const positionAttribute = new THREE.Float32BufferAttribute(positions, 3);
        const gCodeAttribute = new THREE.Float32BufferAttribute(gCodes, 1);
        bufferGeometry.addAttribute('position', positionAttribute);
        bufferGeometry.addAttribute('a_g_code', gCodeAttribute);
        const material = new THREE.ShaderMaterial({
            uniforms: UNIFORMS,
            vertexShader: CNC_LASER_VERT_SHADER,
            fragmentShader: CNC_LASER_FRAG_SHADER,
            side: THREE.DoubleSide,
            transparent: true,
            linewidth: 1
        });
        return new THREE.Line(bufferGeometry, material);
    }

    parseToPoints(data) {
        const geometry = new THREE.Geometry();
        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: THREE.VertexColors,
            opacity: 0.9,
            transparent: true
        });
        let state = {
            G: 0,
            X: 0,
            Y: 0,
            Z: 0
        };
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            const newState = { ...state };
            item.G !== undefined && (newState.G = item.G);
            item.X !== undefined && (newState.X = item.X);
            item.Y !== undefined && (newState.Y = item.Y);
            item.Z !== undefined && (newState.Z = item.Z);

            if (state.G !== newState.G
                || state.X !== newState.X
                || state.Y !== newState.Y
                || state.Z !== newState.Z) {
                state = newState;
                geometry.vertices.push(new THREE.Vector3(state.X, state.Y, state.Z));
                if (state.G === 0) {
                    geometry.colors.push(motionColor.G0);
                } else if (state.G === 1) {
                    geometry.colors.push(motionColor.G1);
                } else {
                    geometry.colors.push(motionColor.unknown);
                }
            }
        }
        return new THREE.Points(geometry, material);
    }
}

export default ToolPathRenderer;

package reflect

import (
	"math/rand"
	"reflect"

	randplus "github.com/cheetah-fun-gs/goplus/math/rand"
)

// Mock 生成 随机值的 mock 数据
func Mock(v interface{}) interface{} {
	return mockAny(reflect.ValueOf(v), false)
}

// MockKeep 生成 原值或0值的 mock 数据
func MockKeep(v interface{}) interface{} {
	return mockAny(reflect.ValueOf(v), true)
}

func randomNew(typ reflect.Type) interface{} {
	switch typ.Kind() {
	case reflect.Bool:
		return false
	case reflect.Int:
		return int(randplus.MustRandint(-2147483648, 2147483647))
	case reflect.Int8:
		return int8(randplus.MustRandint(-128, 127))
	case reflect.Int16:
		return int16(randplus.MustRandint(-32768, 32767))
	case reflect.Int32:
		return int32(randplus.MustRandint(-2147483648, 2147483647))
	case reflect.Int64:
		return int64(randplus.MustRandint(-9223372036854775808, 9223372036854775807))
	case reflect.Uint:
		return uint(randplus.MustRandint(1, 4294967295))
	case reflect.Uint8:
		return uint8(randplus.MustRandint(1, 255))
	case reflect.Uint16:
		return uint16(randplus.MustRandint(1, 65535))
	case reflect.Uint32:
		return uint32(randplus.MustRandint(1, 4294967295))
	case reflect.Uint64:
		return uint64(randplus.MustRandint(1, 9223372036854775807))
	case reflect.Float32:
		return float32(rand.Float32())
	case reflect.Float64:
		return float64(rand.Float64())
	case reflect.Complex64:
		return complex64(complex(rand.Float32(), rand.Float32()))
	case reflect.Complex128:
		return complex128(complex(rand.Float64(), rand.Float64()))
	case reflect.String:
		samples := []string{"abc", "test", "this is a string"}
		weights := []int{}
		for i := 0; i < len(samples); i++ {
			weights = append(weights, 1)
		}
		index := randplus.MustWeightSample(weights)
		return samples[index]
	default:
		return nil
	}
}

func mockAny(v reflect.Value, isKeep bool) interface{} {
	v = DeepElemValue(v)
	switch v.Kind() {
	case reflect.Map:
		return mockMap(v, isKeep, true)
	case reflect.Struct:
		return mockStruct(v, isKeep, true)
	case reflect.Slice:
		return mockSlice(v, isKeep, true)
	case reflect.Array:
		return mockArray(v, isKeep, true)
	case reflect.Chan, reflect.Func, reflect.Interface:
		return nil
	default:
		if isKeep {
			if !v.IsValid() {
				return reflect.New(v.Type()).Interface()
			}
			return v.Interface()
		}
		return randomNew(v.Type())
	}
}

// MockStruct ...
func MockStruct(v interface{}, isKeep, isRecurse bool) map[string]interface{} {
	return mockStruct(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).(map[string]interface{})
}

// mockStruct ..
func mockStruct(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := map[string]interface{}{}
	for i := 0; i < v.NumField(); i++ {
		fieldValue := v.Field(i)
		fieldType := v.Type().Field(i)
		if fieldType.PkgPath == "" { // 只处理导出的字段
			key := structFieldName(fieldType, "json")
			var val interface{}
			if isRecurse {
				val = mockAny(reflect.New(fieldType.Type), isKeep)
			} else {
				val = DeepElemValue(fieldValue).Interface()
			}
			result[key] = val
		}
	}
	if len(result) == 0 {
		return v.Interface()
	}
	return result
}

// MockSlice ...
func MockSlice(v interface{}, isKeep, isRecurse bool) []interface{} {
	return mockSlice(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).([]interface{})
}

// mockSlice ..
func mockSlice(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := mockArray(v, isKeep, isRecurse).([]interface{})
	if len(result) == 0 {
		var val interface{}
		if isRecurse {
			val = mockAny(DeepElemValue(reflect.New(v.Type().Elem())), isKeep)
		} else {
			val = DeepElemValue(reflect.New(v.Type().Elem())).Interface()
		}
		result = append(result, val)
	}
	return result
}

// MockArray ...
func MockArray(v interface{}, isKeep, isRecurse bool) []interface{} {
	return mockArray(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).([]interface{})
}

// mockArray ..
func mockArray(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := []interface{}{}
	for i := 0; i < v.Len(); i++ {
		var val interface{}
		if isRecurse {
			val = mockAny(v.Index(i), isKeep)
		} else {
			val = v.Index(i).Interface()
		}
		result = append(result, val)
	}
	return result
}

// MockMap ...
func MockMap(v interface{}, isKeep, isRecurse bool) map[string]interface{} {
	return mockMap(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).(map[string]interface{})
}

// mockMap ..
func mockMap(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := map[string]interface{}{}
	iter := v.MapRange()
	for iter.Next() {
		key := iter.Key().String()
		var val interface{}
		if isRecurse {
			val = mockAny(iter.Value(), isKeep)
		} else {
			val = iter.Value().Interface()
		}
		result[key] = val
	}
	if len(result) == 0 {
		var val interface{}
		if isRecurse {
			val = mockAny(DeepElemValue(reflect.New(v.Type().Elem())), isKeep)
		} else {
			val = DeepElemValue(reflect.New(v.Type().Elem())).Interface()
		}
		result[""] = val
	}
	return result
}

import * as THREE from 'three';

const UNIFORMS = {
    // rgba
    u_g1_color: new THREE.Uniform(new THREE.Vector4(0, 0, 0, 1))
};

const CNC_LASER_VERT_SHADER = [
    'varying float v_g_code;',
    'attribute float a_g_code;',
    'void main(){',
    '    v_g_code = a_g_code;',
    '    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
    '}'
].join('');

const CNC_LASER_FRAG_SHADER = [
    'uniform vec4 u_g1_color;',
    'varying float v_g_code;',
    'void main(){',
    '    if(v_g_code == 0.0){',
    '        discard;',
    '    }',
    '    gl_FragColor = u_g1_color;',
    '}'
].join('');

const motionColor = {
    'G0': new THREE.Color(0xc8c8c8),
    'G1': new THREE.Color(0x000000),
    'unknown': new THREE.Color(0x000000)
};

class ToolPathRenderer {
    render(toolPath) {
        const { headerType, mode, movementMode, data } = toolPath;

        // now only support cnc&laser
        if (!['cnc', 'laser'].includes(headerType)) {
            return null;
        }

        if (headerType === 'laser') {
            if (mode === 'greyscale' && movementMode === 'greyscale-dot') {
                return this.parseToPoints(data);
            } else {
                return this.parseToLine(data);
            }
        } else {
            return this.parseToLine(data);
        }
    }

    parseToLine(data) {
        const positions = [];
        const gCodes = [];

        let state = {
            G: 0,
            X: 0,
            Y: 0,
            Z: 0
        };
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            const newState = { ...state };
            item.G !== undefined && (newState.G = item.G);
            item.X !== undefined && (newState.X = item.X);
            item.Y !== undefined && (newState.Y = item.Y);
            item.Z !== undefined && (newState.Z = item.Z);

            if ((state.G === 1) && (newState.G === 0)) {
                positions.push(state.X);
                positions.push(state.Y);
                positions.push(state.Z);
                gCodes.push(newState.G);
            }

            if (state.G !== newState.G
                || state.X !== newState.X
                || state.Y !== newState.Y
                || state.Z !== newState.Z) {
                state = newState;
                positions.push(state.X);
                positions.push(state.Y);
                positions.push(state.Z);
                gCodes.push(state.G);
            }
        }

        const bufferGeometry = new THREE.BufferGeometry();
        const positionAttribute = new THREE.Float32BufferAttribute(positions, 3);
        const gCodeAttribute = new THREE.Float32BufferAttribute(gCodes, 1);
        bufferGeometry.addAttribute('position', positionAttribute);
        bufferGeometry.addAttribute('a_g_code', gCodeAttribute);
        const material = new THREE.ShaderMaterial({
            uniforms: UNIFORMS,
            vertexShader: CNC_LASER_VERT_SHADER,
            fragmentShader: CNC_LASER_FRAG_SHADER,
            side: THREE.DoubleSide,
            transparent: true,
            linewidth: 1
        });
        return new THREE.Line(bufferGeometry, material);
    }

    parseToPoints(data) {
        const geometry = new THREE.Geometry();
        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: THREE.VertexColors,
            opacity: 0.9,
            transparent: true
        });
        let state = {
            G: 0,
            X: 0,
            Y: 0,
            Z: 0
        };
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            const newState = { ...state };
            item.G !== undefined && (newState.G = item.G);
            item.X !== undefined && (newState.X = item.X);
            item.Y !== undefined && (newState.Y = item.Y);
            item.Z !== undefined && (newState.Z = item.Z);

            if (state.G !== newState.G
                || state.X !== newState.X
                || state.Y !== newState.Y
                || state.Z !== newState.Z) {
                state = newState;
                geometry.vertices.push(new THREE.Vector3(state.X, state.Y, state.Z));
                if (state.G === 0) {
                    geometry.colors.push(motionColor.G0);
                } else if (state.G === 1) {
                    geometry.colors.push(motionColor.G1);
                } else {
                    geometry.colors.push(motionColor.unknown);
                }
            }
        }
        return new THREE.Points(geometry, material);
    }
}

export default ToolPathRenderer;

package reflect

import (
	"math/rand"
	"reflect"

	randplus "github.com/cheetah-fun-gs/goplus/math/rand"
)

// Mock 生成 随机值的 mock 数据
func Mock(v interface{}) interface{} {
	return mockAny(reflect.ValueOf(v), false)
}

// MockKeep 生成 原值或0值的 mock 数据
func MockKeep(v interface{}) interface{} {
	return mockAny(reflect.ValueOf(v), true)
}

func randomNew(typ reflect.Type) interface{} {
	switch typ.Kind() {
	case reflect.Bool:
		return false
	case reflect.Int:
		return int(randplus.MustRandint(-2147483648, 2147483647))
	case reflect.Int8:
		return int8(randplus.MustRandint(-128, 127))
	case reflect.Int16:
		return int16(randplus.MustRandint(-32768, 32767))
	case reflect.Int32:
		return int32(randplus.MustRandint(-2147483648, 2147483647))
	case reflect.Int64:
		return int64(randplus.MustRandint(-9223372036854775808, 9223372036854775807))
	case reflect.Uint:
		return uint(randplus.MustRandint(1, 4294967295))
	case reflect.Uint8:
		return uint8(randplus.MustRandint(1, 255))
	case reflect.Uint16:
		return uint16(randplus.MustRandint(1, 65535))
	case reflect.Uint32:
		return uint32(randplus.MustRandint(1, 4294967295))
	case reflect.Uint64:
		return uint64(randplus.MustRandint(1, 9223372036854775807))
	case reflect.Float32:
		return float32(rand.Float32())
	case reflect.Float64:
		return float64(rand.Float64())
	case reflect.Complex64:
		return complex64(complex(rand.Float32(), rand.Float32()))
	case reflect.Complex128:
		return complex128(complex(rand.Float64(), rand.Float64()))
	case reflect.String:
		samples := []string{"abc", "test", "this is a string"}
		weights := []int{}
		for i := 0; i < len(samples); i++ {
			weights = append(weights, 1)
		}
		index := randplus.MustWeightSample(weights)
		return samples[index]
	default:
		return nil
	}
}

func mockAny(v reflect.Value, isKeep bool) interface{} {
	v = DeepElemValue(v)
	switch v.Kind() {
	case reflect.Map:
		return mockMap(v, isKeep, true)
	case reflect.Struct:
		return mockStruct(v, isKeep, true)
	case reflect.Slice:
		return mockSlice(v, isKeep, true)
	case reflect.Array:
		return mockArray(v, isKeep, true)
	case reflect.Chan, reflect.Func, reflect.Interface:
		return nil
	default:
		if isKeep {
			if !v.IsValid() {
				return reflect.New(v.Type()).Interface()
			}
			return v.Interface()
		}
		return randomNew(v.Type())
	}
}

// MockStruct ...
func MockStruct(v interface{}, isKeep, isRecurse bool) map[string]interface{} {
	return mockStruct(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).(map[string]interface{})
}

// mockStruct ..
func mockStruct(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := map[string]interface{}{}
	for i := 0; i < v.NumField(); i++ {
		fieldValue := v.Field(i)
		fieldType := v.Type().Field(i)
		if fieldType.PkgPath == "" { // 只处理导出的字段
			key := structFieldName(fieldType, "json")
			var val interface{}
			if isRecurse {
				val = mockAny(reflect.New(fieldType.Type), isKeep)
			} else {
				val = DeepElemValue(fieldValue).Interface()
			}
			result[key] = val
		}
	}
	if len(result) == 0 {
		return v.Interface()
	}
	return result
}

// MockSlice ...
func MockSlice(v interface{}, isKeep, isRecurse bool) []interface{} {
	return mockSlice(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).([]interface{})
}

// mockSlice ..
func mockSlice(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := mockArray(v, isKeep, isRecurse).([]interface{})
	if len(result) == 0 {
		var val interface{}
		if isRecurse {
			val = mockAny(DeepElemValue(reflect.New(v.Type().Elem())), isKeep)
		} else {
			val = DeepElemValue(reflect.New(v.Type().Elem())).Interface()
		}
		result = append(result, val)
	}
	return result
}

// MockArray ...
func MockArray(v interface{}, isKeep, isRecurse bool) []interface{} {
	return mockArray(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).([]interface{})
}

// mockArray ..
func mockArray(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := []interface{}{}
	for i := 0; i < v.Len(); i++ {
		var val interface{}
		if isRecurse {
			val = mockAny(v.Index(i), isKeep)
		} else {
			val = v.Index(i).Interface()
		}
		result = append(result, val)
	}
	return result
}

// MockMap ...
func MockMap(v interface{}, isKeep, isRecurse bool) map[string]interface{} {
	return mockMap(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).(map[string]interface{})
}

// mockMap ..
func mockMap(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := map[string]interface{}{}
	iter := v.MapRange()
	for iter.Next() {
		key := iter.Key().String()
		var val interface{}
		if isRecurse {
			val = mockAny(iter.Value(), isKeep)
		} else {
			val = iter.Value().Interface()
		}
		result[key] = val
	}
	if len(result) == 0 {
		var val interface{}
		if isRecurse {
			val = mockAny(DeepElemValue(reflect.New(v.Type().Elem())), isKeep)
		} else {
			val = DeepElemValue(reflect.New(v.Type().Elem())).Interface()
		}
		result[""] = val
	}
	return result
}

import * as THREE from 'three';

const UNIFORMS = {
    // rgba
    u_g1_color: new THREE.Uniform(new THREE.Vector4(0, 0, 0, 1))
};

const CNC_LASER_VERT_SHADER = [
    'varying float v_g_code;',
    'attribute float a_g_code;',
    'void main(){',
    '    v_g_code = a_g_code;',
    '    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
    '}'
].join('');

const CNC_LASER_FRAG_SHADER = [
    'uniform vec4 u_g1_color;',
    'varying float v_g_code;',
    'void main(){',
    '    if(v_g_code == 0.0){',
    '        discard;',
    '    }',
    '    gl_FragColor = u_g1_color;',
    '}'
].join('');

const motionColor = {
    'G0': new THREE.Color(0xc8c8c8),
    'G1': new THREE.Color(0x000000),
    'unknown': new THREE.Color(0x000000)
};

class ToolPathRenderer {
    render(toolPath) {
        const { headerType, mode, movementMode, data } = toolPath;

        // now only support cnc&laser
        if (!['cnc', 'laser'].includes(headerType)) {
            return null;
        }

        if (headerType === 'laser') {
            if (mode === 'greyscale' && movementMode === 'greyscale-dot') {
                return this.parseToPoints(data);
            } else {
                return this.parseToLine(data);
            }
        } else {
            return this.parseToLine(data);
        }
    }

    parseToLine(data) {
        const positions = [];
        const gCodes = [];

        let state = {
            G: 0,
            X: 0,
            Y: 0,
            Z: 0
        };
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            const newState = { ...state };
            item.G !== undefined && (newState.G = item.G);
            item.X !== undefined && (newState.X = item.X);
            item.Y !== undefined && (newState.Y = item.Y);
            item.Z !== undefined && (newState.Z = item.Z);

            if ((state.G === 1) && (newState.G === 0)) {
                positions.push(state.X);
                positions.push(state.Y);
                positions.push(state.Z);
                gCodes.push(newState.G);
            }

            if (state.G !== newState.G
                || state.X !== newState.X
                || state.Y !== newState.Y
                || state.Z !== newState.Z) {
                state = newState;
                positions.push(state.X);
                positions.push(state.Y);
                positions.push(state.Z);
                gCodes.push(state.G);
            }
        }

        const bufferGeometry = new THREE.BufferGeometry();
        const positionAttribute = new THREE.Float32BufferAttribute(positions, 3);
        const gCodeAttribute = new THREE.Float32BufferAttribute(gCodes, 1);
        bufferGeometry.addAttribute('position', positionAttribute);
        bufferGeometry.addAttribute('a_g_code', gCodeAttribute);
        const material = new THREE.ShaderMaterial({
            uniforms: UNIFORMS,
            vertexShader: CNC_LASER_VERT_SHADER,
            fragmentShader: CNC_LASER_FRAG_SHADER,
            side: THREE.DoubleSide,
            transparent: true,
            linewidth: 1
        });
        return new THREE.Line(bufferGeometry, material);
    }

    parseToPoints(data) {
        const geometry = new THREE.Geometry();
        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: THREE.VertexColors,
            opacity: 0.9,
            transparent: true
        });
        let state = {
            G: 0,
            X: 0,
            Y: 0,
            Z: 0
        };
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            const newState = { ...state };
            item.G !== undefined && (newState.G = item.G);
            item.X !== undefined && (newState.X = item.X);
            item.Y !== undefined && (newState.Y = item.Y);
            item.Z !== undefined && (newState.Z = item.Z);

            if (state.G !== newState.G
                || state.X !== newState.X
                || state.Y !== newState.Y
                || state.Z !== newState.Z) {
                state = newState;
                geometry.vertices.push(new THREE.Vector3(state.X, state.Y, state.Z));
                if (state.G === 0) {
                    geometry.colors.push(motionColor.G0);
                } else if (state.G === 1) {
                    geometry.colors.push(motionColor.G1);
                } else {
                    geometry.colors.push(motionColor.unknown);
                }
            }
        }
        return new THREE.Points(geometry, material);
    }
}

export default ToolPathRenderer;

package reflect

import (
	"math/rand"
	"reflect"

	randplus "github.com/cheetah-fun-gs/goplus/math/rand"
)

// Mock 生成 随机值的 mock 数据
func Mock(v interface{}) interface{} {
	return mockAny(reflect.ValueOf(v), false)
}

// MockKeep 生成 原值或0值的 mock 数据
func MockKeep(v interface{}) interface{} {
	return mockAny(reflect.ValueOf(v), true)
}

func randomNew(typ reflect.Type) interface{} {
	switch typ.Kind() {
	case reflect.Bool:
		return false
	case reflect.Int:
		return int(randplus.MustRandint(-2147483648, 2147483647))
	case reflect.Int8:
		return int8(randplus.MustRandint(-128, 127))
	case reflect.Int16:
		return int16(randplus.MustRandint(-32768, 32767))
	case reflect.Int32:
		return int32(randplus.MustRandint(-2147483648, 2147483647))
	case reflect.Int64:
		return int64(randplus.MustRandint(-9223372036854775808, 9223372036854775807))
	case reflect.Uint:
		return uint(randplus.MustRandint(1, 4294967295))
	case reflect.Uint8:
		return uint8(randplus.MustRandint(1, 255))
	case reflect.Uint16:
		return uint16(randplus.MustRandint(1, 65535))
	case reflect.Uint32:
		return uint32(randplus.MustRandint(1, 4294967295))
	case reflect.Uint64:
		return uint64(randplus.MustRandint(1, 9223372036854775807))
	case reflect.Float32:
		return float32(rand.Float32())
	case reflect.Float64:
		return float64(rand.Float64())
	case reflect.Complex64:
		return complex64(complex(rand.Float32(), rand.Float32()))
	case reflect.Complex128:
		return complex128(complex(rand.Float64(), rand.Float64()))
	case reflect.String:
		samples := []string{"abc", "test", "this is a string"}
		weights := []int{}
		for i := 0; i < len(samples); i++ {
			weights = append(weights, 1)
		}
		index := randplus.MustWeightSample(weights)
		return samples[index]
	default:
		return nil
	}
}

func mockAny(v reflect.Value, isKeep bool) interface{} {
	v = DeepElemValue(v)
	switch v.Kind() {
	case reflect.Map:
		return mockMap(v, isKeep, true)
	case reflect.Struct:
		return mockStruct(v, isKeep, true)
	case reflect.Slice:
		return mockSlice(v, isKeep, true)
	case reflect.Array:
		return mockArray(v, isKeep, true)
	case reflect.Chan, reflect.Func, reflect.Interface:
		return nil
	default:
		if isKeep {
			if !v.IsValid() {
				return reflect.New(v.Type()).Interface()
			}
			return v.Interface()
		}
		return randomNew(v.Type())
	}
}

// MockStruct ...
func MockStruct(v interface{}, isKeep, isRecurse bool) map[string]interface{} {
	return mockStruct(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).(map[string]interface{})
}

// mockStruct ..
func mockStruct(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := map[string]interface{}{}
	for i := 0; i < v.NumField(); i++ {
		fieldValue := v.Field(i)
		fieldType := v.Type().Field(i)
		if fieldType.PkgPath == "" { // 只处理导出的字段
			key := structFieldName(fieldType, "json")
			var val interface{}
			if isRecurse {
				val = mockAny(reflect.New(fieldType.Type), isKeep)
			} else {
				val = DeepElemValue(fieldValue).Interface()
			}
			result[key] = val
		}
	}
	if len(result) == 0 {
		return v.Interface()
	}
	return result
}

// MockSlice ...
func MockSlice(v interface{}, isKeep, isRecurse bool) []interface{} {
	return mockSlice(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).([]interface{})
}

// mockSlice ..
func mockSlice(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := mockArray(v, isKeep, isRecurse).([]interface{})
	if len(result) == 0 {
		var val interface{}
		if isRecurse {
			val = mockAny(DeepElemValue(reflect.New(v.Type().Elem())), isKeep)
		} else {
			val = DeepElemValue(reflect.New(v.Type().Elem())).Interface()
		}
		result = append(result, val)
	}
	return result
}

// MockArray ...
func MockArray(v interface{}, isKeep, isRecurse bool) []interface{} {
	return mockArray(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).([]interface{})
}

// mockArray ..
func mockArray(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := []interface{}{}
	for i := 0; i < v.Len(); i++ {
		var val interface{}
		if isRecurse {
			val = mockAny(v.Index(i), isKeep)
		} else {
			val = v.Index(i).Interface()
		}
		result = append(result, val)
	}
	return result
}

// MockMap ...
func MockMap(v interface{}, isKeep, isRecurse bool) map[string]interface{} {
	return mockMap(DeepElemValue(reflect.ValueOf(v)), isKeep, isRecurse).(map[string]interface{})
}

// mockMap ..
func mockMap(v reflect.Value, isKeep, isRecurse bool) interface{} {
	result := map[string]interface{}{}
	iter := v.MapRange()
	for iter.Next() {
		key := iter.Key().String()
		var val interface{}
		if isRecurse {
			val = mockAny(iter.Value(), isKeep)
		} else {
			val = iter.Value().Interface()
		}
		result[key] = val
	}
	if len(result) == 0 {
		var val interface{}
		if isRecurse {
			val = mockAny(DeepElemValue(reflect.New(v.Type().Elem())), isKeep)
		} else {
			val = DeepElemValue(reflect.New(v.Type().Elem())).Interface()
		}
		result[""] = val
	}
	return result
}

---
layout: post
title: 4. Cartesian Control
category: ROS
tag: ROS
---
- to understand TF look at the my [](https://leechangyo.github.io/robotics/2019/10/04/Kinematic-Model/) post

# Cartesian Control

> Cartesian Control


```python
#!/usr/bin/env python

import math
import numpy
import time
from threading import Thread, Lock

import rospy
import tf
from geometry_msgs.msg import Transform
from sensor_msgs.msg import JointState
from std_msgs.msg import Float32
from urdf_parser_py.urdf import URDF

def S_matrix(w):
    S = numpy.zeros((3,3))
    S[0,1] = -w[2]
    S[0,2] =  w[1]
    S[1,0] =  w[2]
    S[1,2] = -w[0]
    S[2,0] = -w[1]
    S[2,1] =  w[0]
    return S

# This is the function that must be filled in as part of the Project.
def cartesian_control(joint_transforms, b_T_ee_current, b_T_ee_desired,
                      red_control, q_current, q0_desired):
    num_joints = len(joint_transforms)
    dq = numpy.zeros(num_joints)
    #-------------------- Fill in your code here ---------------------------
    J = numpy.zeros((6,num_joints))
    ee_V_ee = numpy.zeros(6) # array([0., 0., 0., 0., 0., 0.])

    T_to_desired = numpy.dot(numpy.linalg.inv(b_T_ee_current),b_T_ee_desired) # symmetry make

    angle, axis = rotation_from_matrix(T_to_desired)
    ## in base frame
    delta_p = T_to_desired[:3,3] #
    delta_theta = numpy.dot(axis,angle)

    p_dot = delta_p*1
    theta_dot = delta_theta*1

    #ee_T_b = numpy.linalg.inv(b_T_ee_current)
    ee_R_b = T_to_desired[:3,:3]

    ee_V_ee[:3] = numpy.dot(ee_R_b,p_dot)
    ee_V_ee[3:] = numpy.dot(ee_R_b,theta_dot)

    for i in range(num_joints):
        J[:,i] = adjoint_matrix(numpy.dot(numpy.linalg.inv(b_T_ee_current),joint_transforms[i]))[:,5]
    dq = numpy.dot(numpy.linalg.pinv(J,0.01),ee_V_ee)
    #----------------------------------------------------------------------
    return dq

def convert_from_message(t):
    trans = tf.transformations.translation_matrix((t.translation.x,
                                                  t.translation.y,
                                                  t.translation.z))
    rot = tf.transformations.quaternion_matrix((t.rotation.x,
                                                t.rotation.y,
                                                t.rotation.z,
                                                t.rotation.w))
    T = numpy.dot(trans,rot)
    return T

def adjoint_matrix(i_T_j):

    i_p_j = numpy.linalg.inv(i_T_j)[:3, 3] # raw column
    i_R_j = i_T_j[:3, :3]
    Ad = numpy.zeros((6,6))
    Ad[:3,:3] = i_R_j
    Ad[3:,3:] = i_R_j
    Ad[:3,3:] = -numpy.dot(i_R_j,S_matrix(i_p_j))

    return Ad

# Returns the angle-axis representation of the rotation contained in the input matrix
# Use like this:
# angle, axis = rotation_from_matrix(R)
def rotation_from_matrix(matrix):
    R = numpy.array(matrix, dtype=numpy.float64, copy=False)
    R33 = R[:3, :3]
    # axis: unit eigenvector of R33 corresponding to eigenvalue of 1
    l, W = numpy.linalg.eig(R33.T)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-8)[0]
    if not len(i):
        raise ValueError("no unit eigenvector corresponding to eigenvalue 1")
    axis = numpy.real(W[:, i[-1]]).squeeze()
    # point: unit eigenvector of R33 corresponding to eigenvalue of 1
    l, Q = numpy.linalg.eig(R)
    i = numpy.where(abs(numpy.real(l) - 1.0) < 1e-8)[0]
    if not len(i):
        raise ValueError("no unit eigenvector corresponding to eigenvalue 1")
    # rotation angle depending on axis
    cosa = (numpy.trace(R33) - 1.0) / 2.0
    if abs(axis[2]) > 1e-8:
        sina = (R[1, 0] + (cosa-1.0)*axis[0]*axis[1]) / axis[2]
    elif abs(axis[1]) > 1e-8:
        sina = (R[0, 2] + (cosa-1.0)*axis[0]*axis[2]) / axis[1]
    else:
        sina = (R[2, 1] + (cosa-1.0)*axis[1]*axis[2]) / axis[0]
    angle = math.atan2(sina, cosa)
    return angle, axis

class CartesianControl(object):

    #Initialization
    def __init__(self):
        #Loads the robot model, which contains the robot's kinematics information
        self.robot = URDF.from_parameter_server()

        #Subscribes to information about what the current joint values are.
        rospy.Subscriber("/joint_states", JointState, self.joint_callback)

        #Subscribes to command for end-effector pose
        rospy.Subscriber("/cartesian_command", Transform, self.command_callback)

        #Subscribes to command for redundant dof
        rospy.Subscriber("/redundancy_command", Float32, self.redundancy_callback)

        # Publishes desired joint velocities
        self.pub_vel = rospy.Publisher("/joint_velocities", JointState, queue_size=1)

        #This is where we hold the most recent joint transforms
        self.joint_transforms = []
        self.q_current = []
        self.x_current = tf.transformations.identity_matrix()
        self.R_base = tf.transformations.identity_matrix()
        self.x_target = tf.transformations.identity_matrix()
        self.q0_desired = 0
        self.last_command_time = 0
        self.last_red_command_time = 0

        # Initialize timer that will trigger callbacks
        self.mutex = Lock()
        self.timer = rospy.Timer(rospy.Duration(0.1), self.timer_callback)

    def command_callback(self, command):
        self.mutex.acquire()
        self.x_target = convert_from_message(command)
        self.last_command_time = time.time()
        self.mutex.release()

    def redundancy_callback(self, command):
        self.mutex.acquire()
        self.q0_desired = command.data
        self.last_red_command_time = time.time()
        self.mutex.release()        

    def timer_callback(self, event):
        msg = JointState()
        self.mutex.acquire()
        if time.time() - self.last_command_time < 0.5:
            dq = cartesian_control(self.joint_transforms,
                                   self.x_current, self.x_target,
                                   False, self.q_current, self.q0_desired)
            msg.velocity = dq
        elif time.time() - self.last_red_command_time < 0.5:
            dq = cartesian_control(self.joint_transforms,
                                   self.x_current, self.x_current,
                                   True, self.q_current, self.q0_desired)
            msg.velocity = dq
        else:            
            msg.velocity = numpy.zeros(7)
        self.mutex.release()
        self.pub_vel.publish(msg)

    def joint_callback(self, joint_values):
        root = self.robot.get_root()
        T = tf.transformations.identity_matrix()
        self.mutex.acquire()
        self.joint_transforms = []
        self.q_current = joint_values.position
        self.process_link_recursive(root, T, joint_values)
        self.mutex.release()

    def align_with_z(self, axis):
        T = tf.transformations.identity_matrix()
        z = numpy.array([0,0,1])
        x = numpy.array([1,0,0])
        dot = numpy.dot(z,axis)
        if dot == 1: return T
        if dot == -1: return tf.transformation.rotation_matrix(math.pi, x)
        rot_axis = numpy.cross(z, axis)
        angle = math.acos(dot)
        return tf.transformations.rotation_matrix(angle, rot_axis)

    def process_link_recursive(self, link, T, joint_values):
        if link not in self.robot.child_map:
            self.x_current = T
            return
        for i in range(0,len(self.robot.child_map[link])):
            (joint_name, next_link) = self.robot.child_map[link][i]
            if joint_name not in self.robot.joint_map:
                rospy.logerror("Joint not found in map")
                continue
            current_joint = self.robot.joint_map[joint_name]        

            trans_matrix = tf.transformations.translation_matrix((current_joint.origin.xyz[0],
                                                                  current_joint.origin.xyz[1],
                                                                  current_joint.origin.xyz[2]))
            rot_matrix = tf.transformations.euler_matrix(current_joint.origin.rpy[0],
                                                         current_joint.origin.rpy[1],
                                                         current_joint.origin.rpy[2], 'rxyz')
            origin_T = numpy.dot(trans_matrix, rot_matrix)
            current_joint_T = numpy.dot(T, origin_T)
            if current_joint.type != 'fixed':
                if current_joint.name not in joint_values.name:
                    rospy.logerror("Joint not found in list")
                    continue
                # compute transform that aligns rotation axis with z
                aligned_joint_T = numpy.dot(current_joint_T, self.align_with_z(current_joint.axis))
                self.joint_transforms.append(aligned_joint_T)
                index = joint_values.name.index(current_joint.name)
                angle = joint_values.position[index]
                joint_rot_T = tf.transformations.rotation_matrix(angle,
                                                                 numpy.asarray(current_joint.axis))
                next_link_T = numpy.dot(current_joint_T, joint_rot_T)
            else:
                next_link_T = current_joint_T

            self.process_link_recursive(next_link, next_link_T, joint_values)

if __name__ == '__main__':
    rospy.init_node('cartesian_control', anonymous=True)
    cc = CartesianControl()
    rospy.spin()



```

<a href="https://postimg.cc/Hc2jxBXX"><img src="https://i.postimg.cc/wMKNwrBf/Capture.png" width="700px" title="source: imgur.com" /><a>
<a href="https://postimg.cc/xJkFjFWF"><img src="https://i.postimg.cc/ZRjkcGjZ/Capture.png" width="700px" title="source: imgur.com" /><a>
<a href="https://postimg.cc/Yv9Py9dH"><img src="https://i.postimg.cc/Hk4Cn85V/Capture.png" width="700px" title="source: imgur.com" /><a>

package io.github.poulad.hnp.web.error;

import javax.annotation.Nonnull;
import lombok.Value;

@Value
public class ValidationError {

  @Nonnull
  String parameter;

  @Nonnull
  RequestParameterType parameterType;

  @Nonnull
  String errorMessage;
}

#!/usr/bin/env python

from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer

class S(BaseHTTPRequestHandler):
    def _set_headers(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()

    def do_GET(self):
        self._set_headers()
        self.wfile.write("<html><body><h1>hello from the other side!</h1></body></html>")

    def do_HEAD(self):
        self._set_headers()

    def do_POST(self):
        content_length = int(self.headers['Content-Length'])  # <--- Gets the size of data
        post_data = self.rfile.read(content_length)  # <--- Gets the data itself
        print "RECEIVED DATA FROM POST" , post_data # <-- Print post data
        print "\n \n"
        self._set_headers()
        self.wfile.write("<html><body><h1>POST!</h1><pre>" + post_data + "</pre></body></html>")

def run(server_class=HTTPServer, handler_class=S,ip='127.0.0.1' port=8081):
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    print 'Starting HTTP server at {0}:{1} .....'.format(ip,port)
    httpd.serve_forever()


if __name__ == "__main__":
    from sys import argv

    if len(argv) == 2:
        run(port=int(argv[1]))
    else:
        run()

#pragma once
#include <functional>

namespace Server
{
    enum class WhatHappened
    {
        LibraryLoadingError,
        AddressInitializationError,
        AddressBindingError,
        SocketCreationError,
        Ok,
        RequestHandlerIsNull,
        SocketInitializationFailed,
        RequestProcessingFatalError,
        RecvFailed,
        SendFailed,
        ConnectionClosed
    };

    using Handler = const std::function<std::string(const std::string_view)> &;

    std::string ToString(const WhatHappened what);

    WhatHappened Start(Handler onRequest);
}
var styles = [
      {
          "featureType": "administrative",
          "elementType": "geometry",
          "stylers": [
              {
                  "color": "#dfeae3"
              }
          ]
      },
      {
          "featureType": "administrative",
          "elementType": "labels.text.fill",
          "stylers": [
              {
                  "color": "#444444"
              }
          ]
      },
      {
          "featureType": "administrative.locality",
          "elementType": "labels",
          "stylers": [
              {
                  "visibility": "on"
              }
          ]
      },
      {
          "featureType": "landscape",
          "elementType": "all",
          "stylers": [
              {
                  "color": "#f2f2f2"
              },
              {
                  "visibility": "simplified"
              }
          ]
      },
      {
          "featureType": "poi",
          "elementType": "all",
          "stylers": [
              {
                  "visibility": "on"
              }
          ]
      },
      {
          "featureType": "poi",
          "elementType": "geometry",
          "stylers": [
              {
                  "visibility": "simplified"
              },
              {
                  "saturation": "-65"
              },
              {
                  "lightness": "45"
              },
              {
                  "gamma": "1.78"
              }
          ]
      },
      {
          "featureType": "poi",
          "elementType": "labels",
          "stylers": [
              {
                  "visibility": "off"
              }
          ]
      },
      {
          "featureType": "poi",
          "elementType": "labels.icon",
          "stylers": [
              {
                  "visibility": "off"
              }
          ]
      },
      {
          "featureType": "road",
          "elementType": "all",
          "stylers": [
              {
                  "saturation": -100
              },
              {
                  "lightness": 45
              }
          ]
      },
      {
          "featureType": "road",
          "elementType": "labels",
          "stylers": [
              {
                  "visibility": "on"
              }
          ]
      },
      {
          "featureType": "road",
          "elementType": "labels.icon",
          "stylers": [
              {
                  "visibility": "off"
              }
          ]
      },
      {
          "featureType": "road.highway",
          "elementType": "all",
          "stylers": [
              {
                  "visibility": "simplified"
              }
          ]
      },
      {
          "featureType": "road.highway",
          "elementType": "labels.icon",
          "stylers": [
              {
                  "visibility": "off"
              }
          ]
      },
      {
          "featureType": "road.arterial",
          "elementType": "labels.icon",
          "stylers": [
              {
                  "visibility": "off"
              }
          ]
      },
      {
          "featureType": "transit.line",
          "elementType": "geometry",
          "stylers": [
              {
                  "saturation": "-33"
              },
              {
                  "lightness": "22"
              },
              {
                  "gamma": "2.08"
              }
          ]
      },
      {
          "featureType": "transit.station.airport",
          "elementType": "geometry",
          "stylers": [
              {
                  "gamma": "2.08"
              },
              {
                  "hue": "#ffa200"
              }
          ]
      },
      {
          "featureType": "transit.station.airport",
          "elementType": "labels",
          "stylers": [
              {
                  "visibility": "off"
              }
          ]
      },
      {
          "featureType": "transit.station.rail",
          "elementType": "labels.text",
          "stylers": [
              {
                  "visibility": "off"
              }
          ]
      },
      {
          "featureType": "transit.station.rail",
          "elementType": "labels.icon",
          "stylers": [
              {
                  "visibility": "simplified"
              },
              {
                  "saturation": "-55"
              },
              {
                  "lightness": "-2"
              },
              {
                  "gamma": "1.88"
              },
              {
                  "hue": "#ffab00"
              }
          ]
      },
      {
          "featureType": "water",
          "elementType": "all",
          "stylers": [
              {
                  "color": "#bbd9e5"
              },
              {
                  "visibility": "simplified"
              }
          ]
      }
]

if (document.getElementById('map-canvas')) {

  function initialize() {
      var myLatlng = new google.maps.LatLng(47.245236, -122.362339);
      var mapOptions = {
          zoom: 13,
          styles: styles,
          center: myLatlng,
          draggable: false,
          scrollwheel: false,
          mapTypeId: google.maps.MapTypeId.ROADMAP
      }
      var map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);

       //=====Initialise Default Marker
      var marker = new google.maps.Marker({
          position: myLatlng,
          map: map,
          title: 'marker',
          icon: {
            url: mapIncludes.markericon,
            size: new google.maps.Size(21, 38),
            scaledSize: new google.maps.Size(21, 38),
            anchor: new google.maps.Point(21, 38)
          }
       //=====You can even customize the icons here
      });

      /*
       //=====Initialise InfoWindow
      var infowindow = new google.maps.InfoWindow({
        // TODO: Confirm this content?
        content: "<B>Skyway Dr</B>"
    });

     //=====Eventlistener for InfoWindow
    google.maps.event.addListener(marker, 'click', function() {
      infowindow.open(map,marker);
    });
    */
  }

  google.maps.event.addDomListener(window, 'load', initialize);
}

package com.skt.nugu.sdk.core.network

import com.skt.nugu.sdk.core.interfaces.connection.ConnectionStatusListener
import com.skt.nugu.sdk.core.interfaces.connection.ConnectionManagerInterface
import com.skt.nugu.sdk.core.interfaces.message.*
import java.util.concurrent.CopyOnWriteArraySet

/**
 * This class is designed to manage connections.
 */
class NetworkManager private constructor(
    private val messageRouter: MessageRouterInterface
) : ConnectionManagerInterface,
    MessageSender by messageRouter,
    MessageRouterObserverInterface {

    companion object {
        /**
         * Create a [NetworkManager]
         * @return a [NetworkManager] instance
         */
        fun create(messageRouter: MessageRouterInterface): NetworkManager {
            val connectionManager = NetworkManager(messageRouter)

            messageRouter.setObserver(connectionManager)

            return connectionManager
        }
    }

    private var enabled = false
    private val messageObservers = CopyOnWriteArraySet<MessageObserver>()
    private val connectionStatusObservers = CopyOnWriteArraySet<ConnectionStatusListener>()
    /**
     * Initiate a connection to DeviceGateway.
     */
    override fun enable() {
        enabled = true
        messageRouter.enable()
    }
    /**
     * Disconnect from DeviceGateway.
     */
    override fun disable() {
        enabled = false
        messageRouter.disable()
    }
    /**
     * check whether a enable
     */
    override fun isEnabled(): Boolean = enabled

    /**
     * reconnect from DeviceGateway.
     */
    override fun reconnect() {
        if (enabled) {
            messageRouter.disable()
            messageRouter.enable()
        }
    }
    /**
     * Returns whether this object is currently connected to DeviceGateway.
     */
    override fun isConnected(): Boolean =
        messageRouter.getConnectionStatus() == ConnectionStatusListener.Status.CONNECTED

    /**
     * Adds an observer to be notified when a message arrives from DeviceGateway.
     * @param observer The observer to add.
     */
    override fun addMessageObserver(observer: MessageObserver) {
        messageObservers.add(observer)
    }

    /**
     * Removes an observer to be notified when a message arrives from DeviceGateway.
     * @param observer The observer to remove.
     */
    override fun removeMessageObserver(observer: MessageObserver) {
        messageObservers.remove(observer)
    }

    /**
     * Adds an observer to be notified of connection status changes.
     * @param observer The observer to add.
     */
    override fun addConnectionStatusListener(listener: ConnectionStatusListener) {
        connectionStatusObservers.add(listener)
        listener.onConnectionStatusChanged(
            messageRouter.getConnectionStatus(),
            ConnectionStatusListener.ChangedReason.NONE
        )
    }

    /**
     * Removes an observer from being notified of connection status changes.
     * @param observer The observer to remove.
     */
    override fun removeConnectionStatusListener(listener: ConnectionStatusListener) {
        connectionStatusObservers.remove(listener)
    }

    /**
     * Receives the connection status changes.
     */
    override fun onConnectionStatusChanged(
        status: ConnectionStatusListener.Status,
        reason: ConnectionStatusListener.ChangedReason
    ) {
        connectionStatusObservers.forEach { it.onConnectionStatusChanged(status,reason) }
    }

    override fun receiveDirectives(directives: List<DirectiveMessage>) {
        messageObservers.forEach {
            it.receiveDirectives(directives)
        }
    }

    override fun receiveAttachment(attachment: AttachmentMessage) {
        messageObservers.forEach {
            it.receiveAttachment(attachment)
        }
    }

    /**
     *  handoff connection from SystemCapability
     */
    override fun handoffConnection(
        protocol: String,
        hostname: String,
        address: String,
        port: Int,
        retryCountLimit: Int,
        connectionTimeout: Int,
        charge: String
    ) {
        messageRouter.handoffConnection(protocol, hostname, address, port, retryCountLimit, connectionTimeout, charge)
    }

    /**
     * Resets the connection immediately.
     */
    override fun resetConnection(description: String?) {
        messageRouter.resetConnection(description)
    }

    /**
     * Set the keepConnection
     */
    override fun keepConnection(enabled: Boolean) = messageRouter.keepConnection(enabled)
}
package com.monet.bidder

import android.os.Bundle
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

@RunWith(RobolectricTestRunner::class)
class DfpRequestHelperTest {
    private val adSize = AdSize(300, 250)
    @Test
    fun `Given ADUNIT_KEYWORD_KEY is present in Bundle  get adUnitId from customEventExtras`() {
        val adUnitId = "adUnitId"
        val serverParameter = "serverParam"
        val customEventExtras = Bundle()
        customEventExtras.putString(Constants.Dfp.ADUNIT_KEYWORD_KEY, adUnitId)
        val helperAdUnit = DfpRequestHelper.getAdUnitID(customEventExtras, serverParameter, adSize)
        Assert.assertEquals(helperAdUnit, adUnitId)
    }

    @Test
    fun `Given ADUNIT_KEYWORD_KEY is not present and serverParameter is not null, 'default' or 'AMAdSize' and it starts with $ sign`() {
        val adUnit = DfpRequestHelper.getAdUnitID(Bundle(), "$100", adSize);
        Assert.assertEquals("300x250", adUnit)
    }

    @Test
    fun `Given ADUNIT_KEYWORD_KEY is not present and serverParameter is not null, 'default' or 'AMAdSize' and it does not start with $ sign (adunit cpm format)`() {
        val serverParam = "test_interstitial@$100"
        val adUnit = DfpRequestHelper.getAdUnitID(Bundle(), serverParam, adSize)
        Assert.assertEquals(adUnit, "test_interstitial")
    }

    @Test
    fun `Given ADUNIT_KEYWORD_KEY is not present and serverParameter is not null, 'default' or 'AMAdSize' and it does not start with $ sign (normal format)`() {
        val normalAdUnitServerParam = "only_ad_unit"
        val adUnit = DfpRequestHelper.getAdUnitID(Bundle(), normalAdUnitServerParam, adSize)
        Assert.assertEquals(adUnit, normalAdUnitServerParam)
    }

    @Test
    fun `Given ADUNIT_KEYWORD_KEY is not present and serverParameters default or AMAdSize`() {
        val defaultServerParam = "default"
        val adUnit = DfpRequestHelper.getAdUnitID(Bundle(), defaultServerParam, adSize)
        Assert.assertEquals(adUnit, "300x250")
        val amAdSizeServerParam = "AMAdSize"
        val unit = DfpRequestHelper.getAdUnitID(Bundle(), amAdSizeServerParam, adSize)
        Assert.assertEquals(unit, "300x250")
    }

    @Test
    fun `Given ADUNIT_KEYWORD_KEY is not present and serverParameter is empty get ad size as adUnit`() {
        val serverParam = ""
        val adUnit = DfpRequestHelper.getAdUnitID(Bundle(), serverParam, adSize)
        Assert.assertEquals(adUnit, "300x250")
    }

    @Test
    fun `Given serverParameter is empty or null return 0 cpm`() {
        Assert.assertEquals(DfpRequestHelper.getCpm(""), 0.0, 0.0)
        Assert.assertEquals(DfpRequestHelper.getCpm(null), 0.0, 0.0)
    }

    @Test
    fun `Given serverParameter starts with $ sign followed by a number`() {
        val cpm = DfpRequestHelper.getCpm("$5.00")
        Assert.assertEquals(cpm, 5.00, 5.00)
    }

    @Test
    fun `Given serverParameter starts with $sign followed by not a number`() {
        val cpm = DfpRequestHelper.getCpm("\$JOSE")
        Assert.assertEquals(cpm, 0.0, 0.0)
    }

    @Test
    fun `Given serverParameter has adUnitId and cpm`(){
        val cpm = DfpRequestHelper.getCpm("test_adunit@$5.00")
        Assert.assertEquals(cpm, 5.0, 5.0)
    }

    @Test
    fun `Given serverParameter has adUnitId and cpm not as a number`(){
        val cpm = DfpRequestHelper.getCpm("test_adunit@\$JOSE")
        Assert.assertEquals(cpm, 0.0, 0.0)
    }
}
module.exports = `body{
    margin:0;   
}

a{
    text-decoration: none !important;
    color: #000 !important;
}

.hide{
    display: none;
}

@media (min-width:200px) and (max-width:740px){
    .matias-navigation{
        z-index: 9999999999;
        margin-top: 0px;
        top: 0;
        width: 100%;
        text-align: center;
        padding-top: 0px;
		height: 100%;
        position: fixed;
        background: #FFF;
        overflow: auto;
    }
}

nav.matias-navigation ul{
    list-style: none;
    width: 100%;
    margin: 0px auto;
}

.matias-navigation__logo{
    width: 100%;
    float: none;
    text-align: center;
    margin: 0px auto;
    background: #000;
    padding-top: 10px;
    padding-bottom: 10px;
}

.matias-navigation__logo a img {
    max-width: 60px;
}

.matias-navigation__logoCloseMobile{
    width: 25%;
    left: 0px;
    position: absolute;
    top: 30px;
    right: 0px;
    z-index: 999;
}

.matias-navigation__logoCloseMobile img {
    width: 20px;
    cursor: pointer;
}

.matias-navigation__upperMenu{
    display: flex;
}

.matias-navigation__upperMenu ul li {
    position: relative;
    width: 31.50%;
    max-width: 170px;
    float: left;
    font-family: 'Asap', sans-serif;
    font-weight: 700;
    margin: 15px 10px 10px;
    transition: 0.3s ease-in-out;
    padding: 0 3px;
    outline: none;
}

.matias-navigation__upperMenu ul li img {
    border-radius: 5px;
    max-height: 85px;
    height: 85px;
    width: 100%;
    object-fit: cover;
}

.matias-navigation__upperMenu ul li span {
    position: absolute;
    top: 50%;
    transform: translate(0px , -50%);
    left: 12px;
}

.matias-navigation__upperMenu ul li span a {
    padding: 4px 7px;
    border-radius: 3px;
    background-color: #fff;
    text-transform: uppercase;
    font-size: 12px;
    color: black;
    text-decoration: none;
}


.accordion-content{
    display: none;
    padding: 0 8px;
    flex-direction: column;
    margin: 10px 0 0 0;
}

.accordion-content11{
    display: block;
}

.accordion-row{
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 100px;
    background-color: #f2f2f2;
    padding-left: 10px;
    min-height: 90px;
    line-height: 90px;
    text-transform: uppercase;
    font-family: 'Asap', sans-serif;
    font-weight: 700;
    color: #000;
    border-radius: 3px;
    margin-bottom: 6px;
}

.accordion-row img {
    max-height: 100px;
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
}

.animate__animated.animate__fadeInLeft {
    --animate-duration: 0.75s;
}
  
.matias-navigation__upperMenu ul {
    padding-left: 0 !important;
}
 
.shifter-open{
  overflow:hidden;
  display:block;
}`;

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;
using System.Runtime.Serialization;
namespace XBMCRPC.List.Filter
{
   public class MusicVideosAnd
   {
       public global::System.Collections.Generic.List<object> and { get; set; }
    }
}

# File upload modal component

The file upload modal is a component that allows users to upload, browse, and modify files. When a save is triggered, the files are then uploaded to the database. The uploaded and/or selected files are returned in an object when the modal is closed.

A common approach to using the File Upload Modal component is within a form, giving users the chance to select files to be attached to a Project, for example. Such an implementation would go as follows:

1. Put a button within the form of the Project edit screen.
2. In your button press handler, specify options for the file-upload-modal, then launch it. See below for more details.
3. When the modal is saved by the user, the files will be uploaded. The file-upload-modal will return the ObjectID of each selected image. You can save these ObjectIDs in your form.

## Setting modal options and launching

The modal technology used with is [NGX Smart modal](https://github.com/maximelafarie/ngx-smart-modal). To set the file-upload-modal data, import the ngxSmartModalService in your component, then call the `setModalData` method:

```
this.ngxSmartModalService.setModalData({
  ...yourOptions
}, 'file-upload-modal', true);
```
After setting the data, use the `open` method to launch the modal:

```
this.ngxSmartModalService.open('file-upload-modal');
```

## Options API

All options are optional except for projectID, which is needed to make sure files are saved to a particular project.

#### __title__ _String_
The title of the modal window. Example: "Select project logo(s)."
### __projectID__ _String_
Should be the project the modal is being launched from. Files will be saved with this project ID.
#### __fileExt__ _String_
A string of accepted file types separated by commas. Example: 'jpg, jpeg, png'
#### __altRequired__ _Boolean_
Whether or not the selected files must each have alt tags specified. Used when specifying image files.
#### __fileNum__ _Number_
Maximum number of files the user can select. If -1 is entered, there is no limit.
#### __returnedFiles__ _Document[]_
An array of document objects returned from the files having been saved. It's not recommended that you set this manually. The File Upload Modal uses this to return files
after they've been saved and the modal has been closed.

## Accessing the returned files

Set up an event listener to check if the File Upload Modal has closed for any reason.
It's recommended you do this in the AfterViewInit lifecycle method.

```
ngAfterViewInit(): void {
  this.ngxSmartModalService.getModal('file-upload-modal').onAnyCloseEventFinished.subscribe((modal: NgxSmartModalComponent) => {
    console.log('The returned data:', modal.getData());
  });
}
```

If the files were successfully saved, you should get an object with a `returnedFiles` containing an array of documents.

#! /usr/bin/env python

from openturns import *

TESTPREAMBLE()

try :

    center = NumericalPoint(4, 0.0)
    center.setName("center")
    center[0] = 0.5
    center[1] = 1.5
    center[2] = 2.5
    center[3] = 3.5
    levels = NumericalPoint(3, 0.0)
    levels.setName("levels")
    levels[0] = 4
    levels[1] = 8
    levels[2] = 16
    myPlane = Factorial(center, levels)
    print "myPlane = " , myPlane
    sample = myPlane.generate()
    print "sample = " , repr(sample)

except :
    import sys
    print "t_Factorial_std.py", sys.exc_type, sys.exc_value

package api

import (
	"net/http"

	"db"
	"encoding/json"
	"fmt"
	"github.com/gorilla/mux"
	"gopkg.in/mgo.v2/bson"
	"io/ioutil"
	"time"
	// "strconv"
)

// Input failed validation.
// swagger:response validationError
type ValidationError struct {
	// The error message
	// in: body
	Body struct {
		Code    int32  `json:"code"`
		Message string `json:"message"`
		Field   string `json:"field"`
	} `json:"body"`
}

// Success Answer
// swagger:response successAnswer
type successAnswer struct {
	// The error message
	// in: body
	Body struct {
		Code    int32  `json:"code"`
		Message string `json:"message"`
		Field   string `json:"field"`
	} `json:"body"`
}

// Server id
// swagger:parameters deleteServer getServerById updateServer
type id struct {
	// id Server Generated
	//
	// in: path
	// required: true
	ID int64 `json:"id"`
}

// Server Param
// swagger:parameters createServer updateServer
type myServerBodyParams struct {
	// Server to submit
	//
	// in: body
	// required: true
	Server *db.Server `json:"server"`
}

// Server Multi
// swagger:parameters  importServer
type myMultipleServerBodyParams struct {
	// Server to submit
	//
	// in: body
	// required: true
	Server *[]db.Server `json:"multiserver"`
}

// swagger:route GET /servers servers listServer
//
// Lists servers
//
// This will show all available asset by default.
//
//
//     Responses:
//       default: validationError
//       200: []server
func GetAllItems(w http.ResponseWriter, req *http.Request) {
	rs, err := db.GetAll()
	if err != nil {
		handleError(err, "Failed to load database items: %v", w)
		return
	}
	bs, err := json.MarshalIndent(rs, "", "    ")
	if err != nil {
		handleError(err, "Failed to load marshal data: %v", w)
		return
	}
	w.Write(bs)
}

func handleError(err error, message string, w http.ResponseWriter) {
	w.WriteHeader(http.StatusInternalServerError)
	w.Write([]byte(fmt.Sprintf(message, err)))
}

// swagger:route POST /servers servers createServer
//
// Add a server
//
// This will register asset.
//
//     Responses:
//       default: validationError
//       200: successAnswer
func PostItem(w http.ResponseWriter, req *http.Request) {
	var server db.Server

	decoder := json.NewDecoder(req.Body)

	// debug, err := json.MarshalIndent(decoder, "", "    ")
	// fmt.Println(" debug", debug)
	// fmt.Println(" err", err)

	errjson := decoder.Decode(&server)

	if errjson != nil {
		fmt.Println("Incorrect body")
		fmt.Println(errjson)
		return
	}
	// fmt.Println(server)

	id := bson.NewObjectId()
	ref := id.Hex()
	Name := server.CMDBName
	Function := server.Function
	SerialNumber := server.SerialNumber
	AssetCode := server.AssetCode
	Model := server.HardwareDefinition.Model
	CPU := server.HardwareDefinition.CPU
	RAM := server.HardwareDefinition.RAM
	Room := server.Localisation.Room
	Building := server.Localisation.Building
	Rack := server.Localisation.Rack
	Remarks := server.Remarks
	Status := server.Status
	UpdateTime := time.Now()
	InsertTime := time.Now()

	fmt.Println(UpdateTime)
	fmt.Println(InsertTime)

	// IpAddr := server.Networking[0].IpAddr
	// PatchPanel := server.Networking[0].PatchPanel
	// ServerPort := server.Networking[0].ServerPort
	// Switch := server.Networking[0].Switch
	// Vlan := server.Networking[0].Vlan
	// MAC := server.Networking[0].MAC

	// item := db.Server{ID: id, CMDBName: Name, Networking: []db.Networks{{IpAddr: IpAddr, PatchPanel: PatchPanel, ServerPort: ServerPort, Switch: Switch, Vlan: Vlan, MAC: MAC}}}

	item := db.Server{ID: id, CMDBName: Name, Function: Function, SerialNumber: SerialNumber, AssetCode: AssetCode, HardwareDefinition: db.HardwareDefinition{Model: Model, CPU: CPU, RAM: RAM}, Localisation: db.Localisation{Room: Room, Building: Building, Rack: Rack}, Remarks: Remarks, Status: Status, UpdateTime: UpdateTime, InsertTime: InsertTime}
	if err := db.Save(item); err != nil {
		handleError(err, "Failed to save data: %v", w)
		return
	}

	// Idea is add static field and use loop for update array of networks
	// Networking: []db.Networks{{IpAddr: IpAddr, PatchPanel: PatchPanel, ServerPort: ServerPort, Switch: Switch, Vlan: Vlan, MAC: MAC}},
	var collec string
	collec = "networking"
	fmt.Println(server.Networking)

	for _, net := range server.Networking {
		fmt.Println(net)
		// Launch update with id = id
		if err := db.Update(ref, collec, net); err != nil {
			handleError(err, "Failed to save data: %v", w)
			return
		}
	}
	w.Write([]byte("OK"))
}

// swagger:route DELETE /servers/{id} servers deleteServer
//
// Delete servers
//
// This will delete asset.
//
//     Responses:
//       default: validationError
//       200: successAnswer
func DeleteItem(w http.ResponseWriter, req *http.Request) {
	vars := mux.Vars(req)
	id := vars["id"]

	if err := db.Remove(id); err != nil {
		handleError(err, "Failed to remove item: %v", w)
		return
	}
	w.Write([]byte("OK"))
}

// swagger:route GET /servers/{id} servers getServerById
//
// Lists specific server
//
// This will list details for specific server.
//
//     Responses:
//       default: validationError
//       200: server
func GetItem(w http.ResponseWriter, req *http.Request) {
	vars := mux.Vars(req)
	id := vars["id"]
	fmt.Println("id", id)

	rs, err := db.GetOne(id)
	// fmt.Println("rs", rs)
	// fmt.Println("err", err)

	if err != nil {
		handleError(err, "Failed to read database: %v", w)
		return
	}

	bs, err := json.Marshal(rs)
	if err != nil {
		handleError(err, "Failed to marshal data: %v", w)
		return
	}
	w.Write(bs)
}

// swagger:route PATCH /servers/{id} servers updateServer
//
// Update specific server
//
// This will update details for specific server.
//
//     Responses:
//       default: validationError
//       200: successAnswer
func UpdateItem(w http.ResponseWriter, req *http.Request) {
	// fmt.Println("Im in update api")
	vars := mux.Vars(req)
	id := vars["id"]
	// fmt.Println("id", id)

	var server db.Server

	decoder := json.NewDecoder(req.Body)

	errjson := decoder.Decode(&server)

	if errjson != nil {
		fmt.Println("Incorrect body")
		fmt.Println(errjson)
		return
	}

	if erro, err := db.Updatemain(id, server); err != nil && erro != nil {
		handleError(err, "Failed to save data: %v", w)
		return
	}
	w.Write([]byte("OK"))
}

// swagger:route POST /servers/import servers importServer
//
// Import / Add multiple Servers
//
// This will insert multiple servers.
//
//     Responses:
//       default: validationError
//       200: successAnswer
func PostMultipleItems(w http.ResponseWriter, req *http.Request) {
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		panic(err)
	}
	var server []db.Server
	err = json.Unmarshal(body, &server)
	// fmt.Println("Body:", body)
	if err != nil {
		//handle error
	}
	// Loop for multiple of server included in JSON
	for i := range server {
		fmt.Println(server[i].CMDBName)
		fmt.Println(server[i])
		if err := db.Save(server[i]); err != nil {
			handleError(err, "Failed to save data: %v", w)
			return
		}

	}
}
const glob = require('glob');
const { stat, readFile } = require('fs/promises');

const { consoleError } = require('./constants');

function getFilesList(paths = []) {
  if (!Array.isArray(paths)) {
    throw new TypeError(`${consoleError}: Argument "paths" should be an array!`);
  }

  let filesList = [];

  for (const path of paths) {
    const files = glob.sync(path);

    filesList = filesList.concat(files);
  }

  return filesList;
}

async function getFileData(filePath) {
  try {
    if (!filePath || typeof filePath !== 'string') {
      throw new TypeError('filePath must be a string!');
    }

    const fileStat = await stat(filePath);
    const fileData = await readFile(filePath, 'utf8');

    return { fileStat, fileData };
  } catch (error) {
    throw new Error(`${consoleError}: ${error}`);
  }
}

async function startPlugins(filePath, config) {
  try {
    const { fileStat, fileData } = await getFileData(filePath);

    for (const plugin of config.plugins) {
      plugin({ fileData, fileStat }, config);
    }
  } catch (error) {
    throw new Error(`${consoleError}: ${error}`);
  }
}

module.exports = { getFilesList, getFileData, startPlugins };

package io.rsocket.transport.netty;

import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;
import io.netty.handler.codec.http.websocketx.PongWebSocketFrame;
import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;
import io.netty.handler.codec.http.websocketx.WebSocketFrame;
import io.netty.handler.codec.http.websocketx.WebSocketHandshakeException;
import io.netty.util.CharsetUtil;

public class WebSocketClientHandler extends SimpleChannelInboundHandler<Object> {

  private final WebSocketClientHandshaker handshaker;
  private ChannelPromise handshakeFuture;

  public WebSocketClientHandler(WebSocketClientHandshaker handshaker) {
    this.handshaker = handshaker;
  }

  public ChannelFuture handshakeFuture() {
    return handshakeFuture;
  }

  @Override
  public void handlerAdded(ChannelHandlerContext ctx) {
    handshakeFuture = ctx.newPromise();
  }

  @Override
  public void channelActive(ChannelHandlerContext ctx) {
    handshaker.handshake(ctx.channel());
  }

  @Override
  public void channelInactive(ChannelHandlerContext ctx) {
    System.out.println("WebSocket Client disconnected!");
  }

  @Override
  public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
    Channel ch = ctx.channel();
    if (!handshaker.isHandshakeComplete()) {
      try {
        handshaker.finishHandshake(ch, (FullHttpResponse) msg);
        System.out.println("WebSocket Client connected!");
        handshakeFuture.setSuccess();
      } catch (WebSocketHandshakeException e) {
        System.out.println("WebSocket Client failed to connect");
        handshakeFuture.setFailure(e);
      }
      return;
    }

    if (msg instanceof FullHttpResponse) {
      FullHttpResponse response = (FullHttpResponse) msg;
      throw new IllegalStateException(
          "Unexpected FullHttpResponse (getStatus="
              + response.status()
              + ", content="
              + response.content().toString(CharsetUtil.UTF_8)
              + ')');
    }

    WebSocketFrame frame = (WebSocketFrame) msg;
    if (frame instanceof TextWebSocketFrame) {
      TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;
      System.out.println("WebSocket Client received message: " + textFrame.text());
    } else if (frame instanceof PongWebSocketFrame) {
      System.out.println("WebSocket Client received pong");
    } else if (frame instanceof CloseWebSocketFrame) {
      System.out.println("WebSocket Client received closing");
      ch.close();
    }
  }

  @Override
  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
    cause.printStackTrace();
    if (!handshakeFuture.isDone()) {
      handshakeFuture.setFailure(cause);
    }
    ctx.close();
  }
}

import 'dotenv/config';
import express from 'express';
import UserController from './app/controllers/UserController';
import BullBoard from 'bull-board';
import Queue from './app/lib/Queue';

const app = express();
BullBoard.setQueues(Queue.queues.map(queue => queue.bull));

app.use(express.json());
app.post('/users', UserController.store);

app.use('/admin/queues', BullBoard.UI);

app.listen(3333, () => {
  console.log('Server running on localhost:3333');
});
module.exports = function getZerosCount(number, base) {
//next function is the sieve of Eratosfen
  function sieve(upper_bound){
    let grains = [0, 0];
    for (let i = 2; i <= upper_bound; i++)
      grains.push(i);
    for (let i = 2; i < Math.sqrt(upper_bound); i++)
      for (let j = i*i; j <= upper_bound; j+=i)
        if (grains[j] != 0) grains[j] = 0;
    return grains.filter(function(x) {return x != 0});
  }

//next function find prime factorization of base (array of couples: prime and its degree)
  function factorization(base_number_system, prime_numbers) {
  let prime_dividers = [];
  for (let i = 0; prime_numbers[i] <= base; i++) {
    let p = prime_numbers[i], count = 0;
    while ((base_number_system >= prime_numbers[i]) && (base_number_system % prime_numbers[i] == 0)) {
      base_number_system = base_number_system / prime_numbers[i];
      p = prime_numbers[i];  
      count++;
    }
    if (count)
      prime_dividers.push([p, count]);
    }
  return prime_dividers;
  }

// Next function find how many zeros in the end of number, which is factorial of `number` in `prime_base` base system
  function getZerosForPrimeBase(number, prime_base) {
    let zeros = 0;
    for (let i = 1; Math.pow(prime_base, i) <= number; i++)
      zeros += Math.floor(number / Math.pow(prime_base, i));
    return zeros;
  }

//let's do it
//first, we seek prime numbers
prime_numbers_before_base = sieve(base);

//second, we add number of zeros to our array of couples and get array of trios: [prime, its degree, zeros]
  candidates = factorization(base, prime_numbers_before_base);
  for (let i = 0; i < candidates.length; i++) 
    candidates[i].push(getZerosForPrimeBase(number, candidates[i][0]));

//and finally, we will chose THE ONE (just believe me, Neo)
  neo = candidates.reduce(function(x, y) {return ((x[2] / x[1]) < (y[2] / y[1]))?x:y;});
  return Math.floor(neo[2] / neo[1]);
} 
/*******************************************************************************
 * Copyright (C) 2021 Mohd Hariz Afiq Bin Abdul Rahman
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 ******************************************************************************/
package com.harix.VoucherSystem.SpecialOffer;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


@RestController
@RequestMapping(value = "/api/specialoffer")
public class SpecialOfferController {

	@Autowired
	private SpecialOfferService spOfferService;
	
	@PostMapping(value = "/create")
	public Optional<SpecialOffer> createNewSpecialOffer(@Validated @RequestBody SpecialOffer spOffer) {
		return spOfferService.createNewSpecialOffer(spOffer);
	}
	
	@GetMapping(value = "/list")
	public List<SpecialOffer> retrieveAllSpecialOffer(){
		return spOfferService.listSpecialOffer();
	}
	
	@DeleteMapping(value = "/delete/{id}")
	public void deleteSpecialOffer(@PathVariable(value = "id") int spOfferId) {
		spOfferService.deleteSpecialOffer(spOfferId);
	}
}

package cn.xishan.oftenporter.demo.oftendb.base;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

import cn.xishan.oftenporter.oftendb.data.impl.MysqlSource;
import cn.xishan.oftenporter.oftendb.db.DBException;
import cn.xishan.oftenporter.oftendb.db.DBHandle;
import cn.xishan.oftenporter.oftendb.db.mysql.SqlHandle;
import cn.xishan.oftenporter.porter.core.util.WPTool;

public class SqlDBSource extends MysqlSource
{

    public SqlDBSource()
    {
        super((wObject, configed, configing) -> configing.setCollectionName("test1"));
        Connection connection = null;
        Statement statement = null;
        try
        {
            String initSql =
                    "CREATE TABLE IF NOT EXISTS `test1` (\n" + "  `_id` char(32) NOT NULL,\n"
                            + "  `name` varchar(35) NOT NULL,\n"
                            + "  `age` int(11) NOT NULL,\n"
                            + "  `sex` varchar(2) NOT NULL,\n"
                            + "  `time` datetime NOT NULL,\n"
                            + "  PRIMARY KEY (`_id`)\n"
                            + ") ENGINE=InnoDB DEFAULT CHARSET=utf8";
            connection = getConn();
             statement = connection.createStatement();
            statement.execute(initSql);
        } catch (Exception e)
        {
            e.printStackTrace();
        } finally
        {
            WPTool.close(statement);
            WPTool.close(connection);
        }
    }

    @Override
    public Connection getConnection()
    {
        return getConn();
    }

    private Connection getConn()
    {

        try
        {
            Class.forName("org.h2.Driver");
            Connection conn = DriverManager.getConnection(
                    "jdbc:h2:~/PorterDemo/oftendb;MODE=MySQL", "sa", "");
            return conn;
        } catch (Exception e)
        {
            throw new DBException(e);
        }

    }

    @Override
    public DBHandle getDBHandle()
            throws DBException
    {
        SqlHandle sqlHandle = new SqlHandle(getConn());
        return sqlHandle;
    }

}

package com.githup.hicoincom.exception;

/**
 * @author ZPZ
 */
public class ArgsNullException extends RuntimeException{
    public ArgsNullException(){ super();}
    public ArgsNullException(String msg){super(msg);}
}

/* TEMPLATE GENERATED TESTCASE FILE
Filename: CWE126_Buffer_Overread__new_char_loop_83_goodG2B.cpp
Label Definition File: CWE126_Buffer_Overread__new.label.xml
Template File: sources-sink-83_goodG2B.tmpl.cpp
*/
/*
 * @description
 * CWE: 126 Buffer Over-read
 * BadSource:  Use a small buffer
 * GoodSource: Use a large buffer
 * Sinks: loop
 *    BadSink : Copy data to string using a loop
 * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack
 *
 * */
#ifndef OMITGOOD

#include "std_testcase.h"
#include "CWE126_Buffer_Overread__new_char_loop_83.h"

namespace CWE126_Buffer_Overread__new_char_loop_83
{
CWE126_Buffer_Overread__new_char_loop_83_goodG2B::CWE126_Buffer_Overread__new_char_loop_83_goodG2B(char * dataCopy)
{
    data = dataCopy;
    /* FIX: Use a large buffer */
    data = new char[100];
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
}

CWE126_Buffer_Overread__new_char_loop_83_goodG2B::~CWE126_Buffer_Overread__new_char_loop_83_goodG2B()
{
    {
        size_t i, destLen;
        char dest[100];
        memset(dest, 'C', 100-1);
        dest[100-1] = '\0'; /* null terminate */
        destLen = strlen(dest);
        /* POTENTIAL FLAW: using length of the dest where data
         * could be smaller than dest causing buffer overread */
        for (i = 0; i < destLen; i++)
        {
            dest[i] = data[i];
        }
        dest[100-1] = '\0';
        printLine(dest);
        delete [] data;
    }
}
}
#endif /* OMITGOOD */

package com.fich.wafproject.dao;
 
import com.fich.wafproject.model.Event;
import java.util.List;
 
public interface EventDao {
 
    void saveEvent(Event event);
    
    Event findByTransactionId(String transactionId);
    
    List<Event> findAllEvent(int pageNumber, String[] targets, String[] names, String[] values, boolean pagination);
    
    List<Event> findAllEvent();
    
    Event findById(Integer id);
    
    List<Event> findEventsByProperties(String[] properties, String[] values);
    
    public void delete(Integer id);
    
    public void deletAll();
     
}
#include "../../non_core/joypad.h"

#if defined(_WIN32) || defined(_MSC_VER) || defined(__ANDROID__)
#include "SDL.h"
#else 
#include <SDL2/SDL.h>
#endif

#if defined(__ANDROID__) 
#include <jni.h>
#endif

#ifdef PSVITA
#include <psp2/ctrl.h>
#endif

#include "stdlib.h"
#include "../../core/mmu/mbc.h"
#include "../../non_core/logger.h"

SDL_Joystick *joystick;

typedef struct {
    int x;
    int y;
    int w;
    int h;
} b_rect;

typedef struct {
    int key_code; // Key code on the keyboard which
                       // maps to the given gameboy button
    int state; // 1 pressed, 0 unpressed
    b_rect rect;
} button_state;


enum {UP = 0, DOWN, LEFT, RIGHT, A, B, START, SELECT};

#if defined(__SWITCH__)
#define JOY_A     0
#define JOY_B     1
#define JOY_X     2
#define JOY_Y     3
#define JOY_PLUS  10
#define JOY_MINUS 11
#define JOY_LEFT  12
#define JOY_UP    13
#define JOY_RIGHT 14
#define JOY_DOWN  15

int button_config[] = {JOY_UP, JOY_DOWN, JOY_LEFT, JOY_RIGHT, JOY_A, JOY_B, JOY_PLUS, JOY_MINUS};

#elif defined(PSVITA)

#define SDLK_VITA_TRIANGLE 0
#define SDLK_VITA_CIRCLE 1 
#define SDLK_VITA_CROSS 2
#define SDLK_VITA_SQUARE 3

#define SDLK_VITA_LTRIGGER 4
#define SDLK_VITA_RTRIGGER 5

#define SDLK_VITA_DOWN 6
#define SDLK_VITA_LEFT 7
#define SDLK_VITA_UP 8
#define SDLK_VITA_RIGHT 9

#define SDLK_VITA_SELECT 10
#define SDLK_VITA_START 11

int button_config[] = {SDLK_VITA_UP, SDLK_VITA_DOWN, SDLK_VITA_LEFT, SDLK_VITA_RIGHT
    , SDLK_VITA_CROSS, SDLK_VITA_CIRCLE, SDLK_VITA_START, SDLK_VITA_SELECT};

#else

int button_config[] = {SDLK_UP, SDLK_DOWN, SDLK_LEFT, SDLK_RIGHT, SDLK_a, SDLK_s, SDLK_RETURN, SDLK_SPACE};

#endif

button_state buttons[8];

#define TOTAL_BUTTONS (sizeof(buttons)/sizeof(buttons[0]))

static SDL_DisplayMode current;
static SDL_Haptic *haptic;
static int rumble_on = 0; // If rumble is activated

#if defined(__ANDROID__) 
static void vibrate() {

    // Retrieve the JNI environment
    JNIEnv* env = (JNIEnv*)SDL_AndroidGetJNIEnv();

    // retrieve the Java instance of the SDL Activity
    jobject activity = (jobject)SDL_AndroidGetActivity();

    // find the Java class of the activity. It should be SDLActivity or a subclass of it.
    jclass c = (*env)->GetObjectClass(env, activity);
    if (c == 0) {
        log_message(LOG_ERROR, "JNI: Unable to find the \"PlutoboyActivity\" class\n");
        return ; 
    }

    // Get the Vibrate method id
    jmethodID mid = (*env)->GetMethodID(env, c, "vibrate", "()V");
    if (mid == 0) {
        log_message(LOG_ERROR, "JNI: Unable to find the \"vibrate\" method id\n");
        return ; 
    }
    
    (*env)->CallVoidMethod(env, activity, mid); 

    // clean up the local references.
    (*env)->DeleteLocalRef(env, activity);
    (*env)->DeleteLocalRef(env, c);
}
#endif


static int isValidEvent(void * userdata, SDL_Event* event)
{
    return event->type == SDL_QUIT ||
           event->type == SDL_KEYDOWN || 
           event->type == SDL_KEYUP || 
           event->type == SDL_JOYBUTTONDOWN || 
           event->type == SDL_JOYBUTTONUP || 
           event->type == SDL_FINGERUP || 
           event->type == SDL_FINGERDOWN || 
           event->type == SDL_FINGERMOTION; 
}

/*  Intialize the joypad, should be called before any other
 *  joypad functions */
void init_joypad() { 

    #if defined(__ANDROID__)   
    rumble_on = 1;
    #else
    rumble_on = 0;
    #endif

    joystick = 0;
    if (SDL_NumJoysticks() > 0) {
        joystick = SDL_JoystickOpen(0);
    }

#ifndef PSVITA 
    // Attempt to setup Haptic Feedback
    haptic = SDL_HapticOpen(0);
    if (haptic == NULL) {
        log_message(LOG_WARN, "Unable to open haptic device %s\n", SDL_GetError());
    } else {
        if (haptic != NULL && SDL_HapticRumbleInit(haptic) != 0) {
            rumble_on = 1;
        } else {
            log_message(LOG_WARN, "Unable to initialize rumble %s\n", SDL_GetError());
        }
    } 
#endif
    // Setup buttons 
    SDL_GetCurrentDisplayMode(0, &current);    
     
    buttons[UP].state = 0;
    buttons[UP].key_code = button_config[UP];
    b_rect rect_u = {DPAD_UP_X, DPAD_UP_Y(current.h), DPAD_UP_W, DPAD_UP_H};
    buttons[UP].rect = rect_u;

    buttons[DOWN].state = 0;
    buttons[DOWN].key_code = button_config[DOWN];
    b_rect rect_d = {DPAD_DOWN_X, DPAD_DOWN_Y(current.h), DPAD_DOWN_W, DPAD_DOWN_H};
    buttons[DOWN].rect = rect_d; 

    buttons[LEFT].state = 0;
    buttons[LEFT].key_code = button_config[LEFT];
    b_rect rect_l = {DPAD_LEFT_X, DPAD_LEFT_Y(current.h), DPAD_LEFT_W, DPAD_LEFT_H};
    buttons[LEFT].rect = rect_l; 

    buttons[RIGHT].state = 0;
    buttons[RIGHT].key_code = button_config[RIGHT];
    b_rect rect_r = {DPAD_RIGHT_X, DPAD_RIGHT_Y(current.h), DPAD_RIGHT_W, DPAD_RIGHT_H};
    buttons[RIGHT].rect = rect_r; 

    buttons[A].state = 0;
    buttons[A].key_code = button_config[A];
    b_rect rect_a = {A_X(current.w), A_Y(current.h), A_W, A_H};
    buttons[A].rect = rect_a; 

    buttons[B].state = 0;
    buttons[B].key_code = button_config[B];
    b_rect rect_b = {B_X(current.w), B_Y(current.h), B_W, B_H};
    buttons[B].rect = rect_b; 

    buttons[START].state = 0;
    buttons[START].key_code = button_config[START];
    b_rect rect_st = {START_X, START_Y(current.h), START_W, START_H};
    buttons[START].rect = rect_st; 
   
    buttons[SELECT].state = 0;
    buttons[SELECT].key_code = button_config[SELECT];
    b_rect rect_se = {SELECT_X, SELECT_Y(current.h), SELECT_W, SELECT_H};
    buttons[SELECT].rect = rect_se; 

    SDL_SetEventFilter(isValidEvent, NULL);
}

/* Check each individual GameBoy key. Returns 1 if
 * the specified key is being held down, 0 otherwise */
int down_pressed()   { return buttons[DOWN].state;  }  
int up_pressed()     { return buttons[UP].state; }
int left_pressed()   { return buttons[LEFT].state;}
int right_pressed()  { return buttons[RIGHT].state;} 
int a_pressed()      { return buttons[A].state; }
int b_pressed()      { return buttons[B].state;}
int start_pressed()  { return buttons[START].state; }
int select_pressed() { return buttons[SELECT].state; } 

/* Returns 1 if any of the 8 GameBoy keys are being held down,
 * 0 otherwise */
int key_pressed() {

    return down_pressed() || up_pressed() || left_pressed() || right_pressed()
    || a_pressed() || b_pressed() || start_pressed() || select_pressed();
}


// Given relative screen x and y positions and an on/off state
// sets any buttons those co-ordinates are in to the given state.
void check_keys_pressed(float x, float y, int state) {
    float p_x = x * current.w;
    float p_y = y * current.h;
   
     for (size_t i = 0; i < TOTAL_BUTTONS; i++) {
        if (p_x >= buttons[i].rect.x && 
                p_x <= buttons[i].rect.x + buttons[i].rect.w &&
                p_y >= buttons[i].rect.y &&
                p_y <= buttons[i].rect.y + buttons[i].rect.h) {
            
            // If activating button, send rumble feedback
            if (rumble_on && !buttons[i].state && state) {
               // SDL_HapticRumblePlay(haptic, 0.5, 100);
               #if defined(__ANDROID__)
                  vibrate();
               #endif
            }
            buttons[i].state = state;
            
         }
    }
}

// Given new x/y relative screen positions and x/y movement 
// determines which keys are now pressed
void check_keys_moved(float x, float y, float mv_x, float mv_y) {
    // Pixel positions after movement
    float p_x = x * current.w;
    float p_y = y * current.h;

    // Pixel positions before movement
    float old_p_x = (x - mv_x) * current.w;
    float old_p_y = (y - mv_y) * current.h;
   
    int activated = 0;

     for (size_t i = 0; i < TOTAL_BUTTONS; i++) {
        int was_on = (old_p_x >= buttons[i].rect.x) &&
                     (old_p_x <= buttons[i].rect.x + buttons[i].rect.w) &&
                     (old_p_y >= buttons[i].rect.y) &&
                     (old_p_y <= buttons[i].rect.y + buttons[i].rect.h);

        int is_on = (p_x >= buttons[i].rect.x) && 
                    (p_x <= buttons[i].rect.x + buttons[i].rect.w) &&
                    (p_y >= buttons[i].rect.y) &&
                    (p_y <= buttons[i].rect.y + buttons[i].rect.h);
            
        if (!was_on && is_on) {
            activated = 1;
            buttons[i].state = 1;           
        }

        if (was_on && !is_on) {
            buttons[i].state = 0;
        }    
    } 

         
    // If activating button, send rumble feedback
    if (rumble_on && activated) {
        // SDL_HapticRumblePlay(haptic, 0.5, 100);
        #if defined(__ANDROID__)
        vibrate();
        #endif
    }
}


void unset_keys() {
    for (size_t i = 0; i < TOTAL_BUTTONS; i++) {
        buttons[i].state = 0;
    }
}


/* Update current state of GameBoy keys as well as control
 * other external actions for the emulator */
int update_keys() {
        SDL_Event event;

        if (SDL_PollEvent(&event)) {

            switch (event.type) {
                    // exit if the window is closed
                case SDL_QUIT:
                            write_SRAM();
                            return 1;
                            break;

#if !defined(PSVITA) && !defined(__SWITCH__)
                case SDL_KEYDOWN: // Key pressed
                    if (event.key.keysym.sym == SDLK_ESCAPE) {
                        write_SRAM();
                        return 1;
                    }

                    for (size_t i = 0; i < TOTAL_BUTTONS; i++) {
                            if (buttons[i].key_code == event.key.keysym.sym) {
                                buttons[i].state = 1;
                                break;
                            }
                        }
                        break;

                case SDL_KEYUP: //Key released
                    for (size_t i = 0; i < TOTAL_BUTTONS; i++) {
                            if (buttons[i].key_code == event.key.keysym.sym) {
                                buttons[i].state = 0;
                                break;
                            }
                        }
                    break;

#else
                case SDL_JOYBUTTONDOWN:
                case SDL_JOYBUTTONUP:
                    for (size_t i = 0; i < TOTAL_BUTTONS; i++) {
                        if (buttons[i].key_code == event.jbutton.button) {
                            buttons[i].state = (event.jbutton.state == SDL_PRESSED);
                            break;
                        }
                    }
                break;

#endif
#ifndef PSVITA          
                case SDL_FINGERDOWN:
                    check_keys_pressed(event.tfinger.x, event.tfinger.y, 1);
                    break;

                case SDL_FINGERUP:
                    check_keys_pressed(event.tfinger.x, event.tfinger.y, 0);
                    break;

                // Assume only one finger can be on a button at a time considering
                // the size of the buttons. It would be more accurate in the future
                // to keep track of finger ids for each button 
                case SDL_FINGERMOTION:
                    check_keys_moved(event.tfinger.x, event.tfinger.y,
                                     event.tfinger.dx, event.tfinger.dy);
                    break;
                default: 
                    printf("%d\n",  event.type);
                    
#endif
            }                   
        }
    return 0;
}

<?php

/**
 * Module: SmartFAQ
 * Author: The SmartFactory <www.smartfactory.ca>
 * Licence: GNU
 */

use XoopsModules\Smartfaq;

global $xoopsTpl, $xoopsModule;

$uid     = $xoopsUser ? $xoopsUser->getVar('uid') : 0;
$isAdmin = (Smartfaq\Utility::userIsAdmin() || Smartfaq\Utility::hasModerator());

/** @var Smartfaq\Helper $helper */
$helper = Smartfaq\Helper::getInstance();

$xoopsTpl->assign('sf_adminpage', "<a href='" . XOOPS_URL . "/modules/smartfaq/admin/index.php'>" . _MD_SF_ADMIN_PAGE . '</a>');
$xoopsTpl->assign('isAdmin', $isAdmin);

$xoopsTpl->assign(
    [
        'lang_on'       => _MD_SF_ON,
        'lang_postedby' => _MD_SF_POSTEDBY,
        'lang_faq'      => _MD_SF_QUESTION,
        'lang_datesub'  => _MD_SF_DATESUB,
        'lang_hits'     => _MD_SF_HITS,
    ]
);
$xoopsTpl->assign('sectionname', $myts->displayTarea($xoopsModule->getVar('name')));

$xoopsTpl->assign('modulename', $xoopsModule->dirname());
$xoopsTpl->assign('displaylastfaq', $helper->getConfig('displaylastfaq'));
$xoopsTpl->assign('displaysubcatdsc', $helper->getConfig('displaysubcatdsc'));
$xoopsTpl->assign('displaycollaps', $helper->getConfig('displaycollaps'));
$xoopsTpl->assign('display_date_col', $helper->getConfig('display_date_col'));
$xoopsTpl->assign('display_hits_col', $helper->getConfig('display_hits_col'));

$xoopsTpl->assign('displaytopcatdsc', $helper->getConfig('displaytopcatdsc'));

$xoopsTpl->assign('ref_smartfaq', 'SmartFAQ is developed by The SmartFactory (http://www.smartfactory.ca), a division of InBox Solutions (http://www.inboxsolutions.net)');

$xoopsTpl->assign('xoops_module_header', "<link rel='stylesheet' type='text/css' href='" . XOOPS_URL . "/modules/smartfaq/assets/css/smartfaq.css'>");

package com.codepath.apps.restclienttemplate.fragments;

import android.os.Bundle;
import android.support.annotation.Nullable;
import android.util.Log;

import com.codepath.apps.restclienttemplate.TwitterApp;
import com.codepath.apps.restclienttemplate.TwitterClient;
import com.loopj.android.http.JsonHttpResponseHandler;

import org.json.JSONArray;
import org.json.JSONObject;

import cz.msebera.android.httpclient.Header;

/**
 * Created by Arielle on 03-Mar-18.
 */

public class UserTimelineFragment extends TweetsListFragment {
    TwitterClient client;
    public static UserTimelineFragment newInstance(String  screenName){
       UserTimelineFragment userTimelineFragment = new UserTimelineFragment();
       Bundle args= new Bundle();
       args.putString("screen_name", screenName);
       userTimelineFragment.setArguments(args);
       return userTimelineFragment;


    }

    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        client = TwitterApp.getRestClient();
        populateTimeLine();
    }

    private void populateTimeLine() {
        //comes from the activity
        String screenName = getArguments().getString("screen_name");

        client.getUserTimeline(screenName, new JsonHttpResponseHandler() {
                                   @Override
                                   public void onSuccess(int statusCode, Header[] headers, JSONObject response) {
                                       Log.d("TwitterClient", response.toString());

                                   }

                                   @Override
                                   public void onSuccess(int statusCode, Header[] headers, JSONArray response) {
                                       addItems(response);
                                       //    Log.d("TwitterClient",response.toString());

                                       //iterate trought the JSON array
                                       //for each entry, deserialyze the JSON object
                                       for (int i = 0; i < response.length(); i++) {
                                           //convert each object to a Tweet model
                                           //add that tweet model to our data source
                                           //notify the adapter that we've added an item


                                       }
                                   }

                                   @Override
                                   public void onFailure(int statusCode, Header[] headers, String responseString, Throwable throwable) {
                                       Log.d("TwitterClient", responseString);
                                       throwable.printStackTrace();
                                   }

                                   @Override
                                   public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONArray errorResponse) {
                                       Log.d("TwitterClient", errorResponse.toString());
                                       throwable.printStackTrace();
                                   }

                                   @Override
                                   public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) {
                                       Log.d("TwitterClient", errorResponse.toString());
                                       throwable.printStackTrace();
                                   }


                                           //         Log.d("TwitterClient",response.toString());
            //iterate trought the JSON array
            //for each entry, deserialize the JSON object


        });
}}

package org.apache.kyuubi.engine.spark

import org.apache.curator.framework.CuratorFramework

import org.apache.kyuubi.Utils
import org.apache.kyuubi.config.KyuubiConf
import org.apache.kyuubi.ha.HighAvailabilityConf.{HA_ZK_AUTH_TYPE, HA_ZK_NAMESPACE, HA_ZK_QUORUM}
import org.apache.kyuubi.ha.client.{ZooKeeperAuthTypes, ZooKeeperClientProvider}
import org.apache.kyuubi.zookeeper.{EmbeddedZookeeper, ZookeeperConf}

trait WithDiscoverySparkSQLEngine extends WithSparkSQLEngine {
  private var zkServer: EmbeddedZookeeper = _
  def namespace: String
  override def withKyuubiConf: Map[String, String] = {
    assert(zkServer != null)
    Map(
      HA_ZK_QUORUM.key -> zkServer.getConnectString,
      HA_ZK_AUTH_TYPE.key -> ZooKeeperAuthTypes.NONE.toString,
      HA_ZK_NAMESPACE.key -> namespace)
  }

  override def beforeAll(): Unit = {
    zkServer = new EmbeddedZookeeper()
    val zkData = Utils.createTempDir()
    val tmpConf = KyuubiConf()
    tmpConf.set(ZookeeperConf.ZK_CLIENT_PORT, 0)
    tmpConf.set(ZookeeperConf.ZK_DATA_DIR, zkData.toString)
    zkServer.initialize(tmpConf)
    zkServer.start()
  }

  override def afterAll(): Unit = {
    if (zkServer != null) {
      zkServer.stop()
    }
  }

  override protected def beforeEach(): Unit = {
    super.beforeEach()
    startSparkEngine()
  }

  override protected def afterEach(): Unit = {
    super.afterEach()
    stopSparkEngine()
  }

  def withZkClient(f: CuratorFramework => Unit): Unit = {
    ZooKeeperClientProvider.withZkClient(kyuubiConf)(f)
  }

  protected def getDiscoveryConnectionString: String = {
    if (zkServer == null) {
      ""
    } else {
      zkServer.getConnectString
    }
  }
}
---
title: "Recitation 3 Note"
author: "Yiming Gong"
date: "2021-07-22T02:56:26Z"
link: "https://bookdown.org/yg484/rec_3_note/"
length_weight: "7.8%"
pinned: false
---

This is class note for recitation 3 on July 22th. [...] restrict the time scale to two instants only: The price of one share at time \(t\) will be denoted by \(S(t)\). The
current stock price \(S(0)\) is known to all investors \(A(t)\) and \(A(0)\) \[
S(t)-S(0)
\] The return is defined as: \[
K_S = \frac{S(t)-S(0)}{S(0)}, t= 1
\] Is the return \(K_S\) a fixed value or a random value? Similar for return of bond: \[
K_A = \frac{A(t)-A(0)}{A(0)}, t = 1
\] Is the return \(K_A\) a fixed value or a random value? The future stock price \(S(1)\) is a random variable with at least two
different ...

'use strict';

var memo = require('./');

/**
 * When a string is passed, a function is returned
 */

var cwd = memo(process.cwd());

// use `cwd`
var foo = cwd('foo');
var bar = cwd('bar');
var baz = cwd('baz');

// use `foo`
var qux = foo('a/b/c');
// use `qux`
var fez = qux('x/y/z');

/**
 * Get a memoized path by calling the function
 */

console.log(cwd());
//=> /User/dev/memo-path
console.log(foo());
//=> /User/dev/memo-path/foo
console.log(bar());
//=> /User/dev/memo-path/bar
console.log(baz());
//=> /User/dev/memo-path/baz
console.log(qux());
//=> /User/dev/memo-path/foo/a/b/c
console.log(fez());
//=> /User/dev/memo-path/foo/a/b/c/x/y/z


/**
 * The memoized path is also exposed on the function's `.path` property
 */

console.log(cwd.path);
//=> /User/dev/memo-path
console.log(foo.path);
//=> /User/dev/memo-path/foo
console.log(bar.path);
//=> /User/dev/memo-path/bar
console.log(baz.path);
//=> /User/dev/memo-path/baz
console.log(qux.path);
//=> /User/dev/memo-path/foo/a/b/c
console.log(fez.path);
//=> /User/dev/memo-path/foo/a/b/c/x/y/z

<?php 
namespace App\Http\Controllers;

use App\Language;
    use App\Film;

     
class LanguageController extends Controller {

    /**
    * Display a listing of the resource.
    *
    * @return  Response
    */
    public function index()
    {
        request()->session()->forget("keyword");
        request()->session()->forget("clear");
        request()->session()->forget("defaultSelect");
        session(["mutate" => '1']);


        return view('language_show', ['languages' => Language::paginate(20)]);
    }

    /**
    * Show the form for creating a new resource.
    *
    * @return  Response
    */
    public function create()
    {
        return view('language');
    }

    /**
    * Store a newly created resource in storage.
    *
    * @return  Response
    */
    public function store()
    {
            $data = request()->all();

    $language = Language::create([
             "name" => $data["name"],
          ]);

      
        return redirect('/language');;
    }

    /**
    * Display the specified resource.
    *
    * @param    Mixed
    * @return  Response
    */
    public function show(Language $language )
    {
        request()->session()->forget("mutate");
        $language->load(array("film",));
        return view('language_display', compact('language'));        }

    /**
    * Show the form for editing the specified resource.
    *
    * @param    Mixed
    * @return  Response
    */
    public function edit(Language $language )
    {
        request()->session()->forget("mutate");
        $language->load(array("film",));
        return view('language_edit', compact('language'));
    }

    /**
    * Update the specified resource in storage.
    *
    * @param    Mixed
    * @return  Response
    */
    public function update(Language $language )
    {
            $language->update(request()->all());

        return back();
    }

    /**
    * Remove the specified resource from storage.
    *
    * @param    Mixed
    * @return  Response
    */
    public function destroy(Language $language )
    {
            $language->delete();
        return back();
    }

    /**
    * Load and display related tables.
    * @param    Mixed
    * @return  Response
    */
    public function related(Language $language ){

        session(["mutate" => '1']);
        if(request()->exists('cs')){
            request()->session()->forget("keyword");
            return back();
        }

        if(request()->exists('tab') && session("clear", "none") != request()->get('tab')){
            request()->session()->forget("keyword");
            session(["clear" => request()->get('tab')]);
        }

        $table = request()->get('tab');
        $language->load(array("film",));
return view('language_related', compact(['language', 'table']));
    }

    /**
    * Search Table element By keyword
    * @return  Response
    */
    public function search(){
        $keyword = request()->get('keyword');

        if(request()->exists('tab')){
            session(['keyword' => $keyword]);
            return back();
        }

        session(["keyword" => $keyword]);

        $keyword = '%'.$keyword.'%';

        $languages = Language::where('language_id', 'like', $keyword)
         ->orWhere('language_id', 'like', $keyword)

         ->orWhere('name', 'like', $keyword)

         ->orWhere('last_update', 'like', $keyword)

        ->paginate(20);
    $languages->setPath("search?keyword=$keyword");
    return view('language_show', compact('languages'));
    }

    /**
    * Sort Table element
    * @return  Response
    */
    public function sort(){
        $path = "";

            request()->session()->forget("sortKey");
    request()->session()->forget("sortOrder");
    if(!request()->exists('tab')){
$languages = Language::query();
         if(request()->exists('name')){
            $languages = $languages->orderBy('name', $this->getOrder('name'));
            $path = "name";
        }else{
            request()->session()->forget("name");
        }
          $languages = $languages->paginate(20);
        $languages->setPath("sort?$path");
        return view('language_show', compact('languages'));

    }else{

    if(request()->exists('tab') == 'film'){

                  if(request()->exists('title')){
             session(['sortOrder' => $this->getOrder('title')]);
             session(['sortKey' => 'title']);
        }else{
            request()->session()->forget("title");
        }

                 if(request()->exists('description')){
             session(['sortOrder' => $this->getOrder('description')]);
             session(['sortKey' => 'description']);
        }else{
            request()->session()->forget("description");
        }

                 if(request()->exists('release_year')){
             session(['sortOrder' => $this->getOrder('release_year')]);
             session(['sortKey' => 'release_year']);
        }else{
            request()->session()->forget("release_year");
        }

                  if(request()->exists('rental_duration')){
             session(['sortOrder' => $this->getOrder('rental_duration')]);
             session(['sortKey' => 'rental_duration']);
        }else{
            request()->session()->forget("rental_duration");
        }

                 if(request()->exists('rental_rate')){
             session(['sortOrder' => $this->getOrder('rental_rate')]);
             session(['sortKey' => 'rental_rate']);
        }else{
            request()->session()->forget("rental_rate");
        }

                 if(request()->exists('length')){
             session(['sortOrder' => $this->getOrder('length')]);
             session(['sortKey' => 'length']);
        }else{
            request()->session()->forget("length");
        }

                 if(request()->exists('replacement_cost')){
             session(['sortOrder' => $this->getOrder('replacement_cost')]);
             session(['sortKey' => 'replacement_cost']);
        }else{
            request()->session()->forget("replacement_cost");
        }

                    }
             return back();
    }
    }

    /**
    * Clear Search Pattern
    *
    */
    public function clearSearch(){
        request()->session()->forget("keyword");
        return back();
    }



    function addFilm(Language $language ){
    $language->film()->sync(request()->get('film'));
    return back();
}
 
    private function getOrder($param){
        if(session($param, "none") != "none"){
            session([$param => session($param, 'asc') == 'asc' ? 'desc':'asc']);
        }else{
            session([$param => 'asc']);
        }
        return session($param);
    }



}


package ru.rsmu.olympreg.utils.restconnector.examsapimodel;

import javax.xml.bind.annotation.XmlRootElement;
import java.util.Date;

/**
 * @author leonid.
 */
@XmlRootElement( name = "exam" )
public class ExamFacade {
    private long id;
    private String subject;
    private String eventType;
    private String name;
    private Date date;


    public long getId() {
        return id;
    }

    public void setId( long id ) {
        this.id = id;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject( String subject ) {
        this.subject = subject;
    }

    public String getEventType() {
        return eventType;
    }

    public void setEventType( String eventType ) {
        this.eventType = eventType;
    }

    public String getName() {
        return name;
    }

    public void setName( String name ) {
        this.name = name;
    }

    public Date getDate() {
        return date;
    }

    public void setDate( Date date ) {
        this.date = date;
    }
}

require "application_system_test_case"

class InstitutionsTest < ApplicationSystemTestCase
  setup do
    @institution = institutions(:one)
  end

  test "visiting the index" do
    visit institutions_url
    assert_selector "h1", text: "Institutions"
  end

  test "creating a Institution" do
    visit institutions_url
    click_on "New Institution"

    fill_in "Description", with: @institution.description
    fill_in "Name", with: @institution.name
    click_on "Create Institution"

    assert_text "Institution was successfully created"
    click_on "Back"
  end

  test "updating a Institution" do
    visit institutions_url
    click_on "Edit", match: :first

    fill_in "Description", with: @institution.description
    fill_in "Name", with: @institution.name
    click_on "Update Institution"

    assert_text "Institution was successfully updated"
    click_on "Back"
  end

  test "destroying a Institution" do
    visit institutions_url
    page.accept_confirm do
      click_on "Destroy", match: :first
    end

    assert_text "Institution was successfully destroyed"
  end
end

import axiosWithAuth from "../../utils/axiosWithAuth.js";

export const LOADING_START = "LOADING_START";
export const LOADING_DONE = "LOADING_DONE";
export const LOGIN_FAILED = "LOGIN_FAILED";
export const LOGOUT = "LOGOUT";
export const SET_CURRENT_USER = "SET_CURRENT_USER";
export const SET_OTHER_USER = "SET_OTHER_USER";
export const WIPE_OTHER_USER = "WIPE_OTHER_USER";
export const SAVED_JOBS = "SAVED_JOBS";
export const DELETE_JOBS = "DELETE_JOBS";
export const DELETE_APPLIED = "DELETE_APPLIED";
export const GET_SAVED_APPLIED_JOBS = "GET_SAVED_APPLIED_JOBS";
export const APPLIED_JOBS = "APPLIED_JOBS";

// export const loadingStart = () =>{
//     return { type: LOADING_START, payload: null };
// }
export const loadingDone = () => {
  return { type: LOADING_DONE, payload: null };
};
export const login = (user) => {
  return { type: SET_CURRENT_USER, payload: user };
};
export const logout = () => {
  return { type: LOGOUT, payload: null };
};
export const getCurrentUser = () => (dispatch) => {
  axiosWithAuth()
    .get("/users/user")
    .then((res) => {
      dispatch({ type: SET_CURRENT_USER, payload: res.data });
    })
    .catch((err) => {
      dispatch({ type: LOGIN_FAILED, payload: err });
      console.log("GetCurrentUser CATCH ERROR: ", err.response.data.message);
    });
  return null;
};

export const updateUser = (userObj, setLoading) => (dispatch) => {
  axiosWithAuth()
    .put(`/users/user`, userObj)
    .then((res) => {
      console.log("update user", res);
      dispatch({ type: SET_CURRENT_USER, payload: res.data });
      dispatch({ type: SET_OTHER_USER, payload: res.data });
    })
    .catch((err) => {
      setLoading(false);
      console.log("updateUser CATCH ERROR: ", err.response.data.message);
      alert(err.response.data.message);
    });
  return null;
};

export const updateProfilePicture = (formData, setPictureLoading) => (
  dispatch
) => {
  // console.log('updateProfilePicture firing', formData);
  axiosWithAuth()
    .put("/users/user/picture", formData)
    .then((res) => {
      console.log("updateProfilePicture res: ", res);
      dispatch({ type: SET_CURRENT_USER, payload: res.data });
      setPictureLoading(false);
    })
    .catch((err) => {
      console.log(
        "updateProfilePicture CATCH ERROR: ",
        err.response.data.message
      );
      alert(err.response.data.message);
      setPictureLoading(false);
    });
  return null;
};
export const deleteProfilePicture = (setPictureLoading) => (dispatch) => {
  console.log("deleteProfilePicture firing");
  axiosWithAuth()
    .delete("/users/user/picture")
    .then((res) => {
      dispatch({ type: SET_CURRENT_USER, payload: { profile_img: "" } });
      setPictureLoading(false);
    })
    .catch((err) => {
      console.log(
        "deleteProfilePicture CATCH ERROR: ",
        err.response.data.message
      );
      alert(err.response.data.message);
      setPictureLoading(false);
    });
  return null;
};

export const updateSaved = (saved, user_id) => (dispatch) => {
  axiosWithAuth()
    .post("/saved/", saved)
    .then((res) => {
      axiosWithAuth()
        .get(`/saved/${user_id}`)
        .then((res) => {
          dispatch({ type: SAVED_JOBS, payload: res.data });
        })
        .catch((error) => {
          console.error(error.message);
        });
    })
    .catch((err) => {
      console.log(err);
    });
  return null;
};

export const deleteSaved = (job_id) => (dispatch) => {
  axiosWithAuth()
    .delete(`/saved/${job_id}`)
    .then((res) => {
      dispatch({ type: DELETE_JOBS, payload: job_id });
    })
    .catch((err) => {
      console.log(err);
    });
  return null;
};

export const deleteApplied = (job_id) => (dispatch) => {
  axiosWithAuth()
    .delete(`/saved/${job_id}`)
    .then((res) => {
      dispatch({ type: DELETE_APPLIED, payload: job_id });
    })
    .catch((err) => {
      console.log(err);
    });
  return null;
};

export const getSavedAppliedJobs = (user_id) => (dispatch) => {
  axiosWithAuth()
    .get(`/saved/${user_id}`)
    .then((res) => {
      dispatch({ type: GET_SAVED_APPLIED_JOBS, payload: res.data });
    })
    .catch((error) => {
      console.error(error.message);
    });
};

export const updateApplied = (applied, user_id) => (dispatch) => {
  axiosWithAuth()
    .post("/saved/", applied)
    .then((res) => {
      axiosWithAuth()
        .get(`/saved/${user_id}`)
        .then((res) => {
          dispatch({ type: APPLIED_JOBS, payload: res.data });
        })
        .catch((error) => {
          console.error(error.message);
        });
    })
    .catch((err) => {
      console.log(err);
    });
};

<?php
/* @var $this InvoiceHeaderController */
/* @var $model InvoiceHeader */

$this->breadcrumbs = array(
    'Invoice Headers' => array('admin'),
    'Manage',
);

Yii::app()->clientScript->registerScript('search', "
$('.search-button').click(function(){
    $('.search-form').slideToggle(600);
    $('.bulk-action').toggle();
    $(this).toggleClass('active');
    if ($(this).hasClass('active')) {
            $(this).text('');
    } else {
            $(this).text('Advanced Search');
    }
    return false;
});

$('#invoiceSearch').submit(function(){
    $('#invoice-header-grid').yiiGridView('update', {
        data: $(this).serialize()
    });
    return false;
});
");
?>

<div id="maincontent">
    <div class="row">
        <div class="small-12 columns">
            <div class="clearfix page-action">
                <!-- <a class="button success right" href="<?php //echo Yii::app()->baseUrl.'/transaction/invoiceHeader/create'; ?>"><span class="fa fa-plus"></span>Create Invoice Headers</a> -->
                <h2>Manage Invoice Headers</h2>
            </div>

            <div class="search-bar">
                <div class="clearfix button-bar">
                    <div class="form">
                        <?php $form = $this->beginWidget('CActiveForm', array(
                            'action' => Yii::app()->createUrl($this->route),
                            'method' => 'get',
                            'id' => 'invoiceSearch',
                        )); ?>

                        <div class="row">
                            <div class="medium-6 columns">
                                <div class="field">
                                    <div class="row collapse">
                                        <div class="small-4 columns">
                                            <?php echo $form->label($model, 'customer_name', array('class' => 'prefix')); ?>
                                        </div>
                                        <div class="small-8 columns">
                                            <?php echo $form->textField($model, 'customer_name'); ?>
                                        </div>
                                    </div>
                                </div>	
                                <div class="field">
                                    <div class="row collapse">
                                        <div class="small-4 columns">
                                            <?php echo $form->label($model, 'customer_type', array('class' => 'prefix')); ?>
                                        </div>
                                        <div class="small-8 columns">
                                            <?php echo $form->dropDownList($model, 'customer_type', array('Individual' => 'Individual', 'Company' => 'Company',), array('prompt' => 'Select',)); ?>
                                        </div>
                                    </div>
                                </div>

                                <div class="field">
                                    <div class="row collapse">
                                        <div class="small-4 columns">
                                            <label class="prefix"><?php echo $form->labelEx($model, 'invoice_date'); ?></label>
                                        </div>
                                        <div class="small-8 columns">
                                            <div class="row">
                                                <div class="medium-5 columns">
                                                    <?php $this->widget('zii.widgets.jui.CJuiDatePicker', array(
                                                        'model' => $model,
                                                        'attribute' => "invoice_date",
                                                        // additional javascript options for the date picker plugin
                                                        'options' => array(
                                                            'dateFormat' => 'yy-mm-dd',
                                                        //'changeMonth'=>true,
                                                        // 'changeYear'=>true,
                                                        // 'yearRange'=>'1900:2020'
                                                        ),
                                                        'htmlOptions' => array(),
                                                    )); ?>
                                                    <?php echo $form->error($model, 'invoice_date'); ?>

                                                </div>
                                                <div class="medium-7 columns">
                                                    <div class="field">
                                                        <div class="row collapse">
                                                            <div class="small-4 columns">
                                                                <label class="prefix">To</label>
                                                            </div>
                                                            <div class="small-8 columns">
                                                                <?php $this->widget('zii.widgets.jui.CJuiDatePicker', array(
                                                                    'model' => $model,
                                                                    'attribute' => "invoice_date_to",
                                                                    // additional javascript options for the date picker plugin
                                                                    'options' => array(
                                                                        'dateFormat' => 'yy-mm-dd',
                                                                    //             'changeMonth'=>true,
                                                                    // 'changeYear'=>true,
                                                                    // 'yearRange'=>'1900:2020'
                                                                    ),
                                                                    'htmlOptions' => array(),
                                                                )); ?>
                                                            </div>
                                                        </div>
                                                    </div>

                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>	

                                <div class="field">
                                    <div class="row collapse">
                                        <div class="small-4 columns">
                                            <label class="prefix"><?php echo $form->labelEx($model, 'due_date'); ?></label>
                                        </div>
                                        <div class="small-8 columns">
                                            <div class="row">
                                                <div class="medium-5 columns">
                                                    <?php $this->widget('zii.widgets.jui.CJuiDatePicker', array(
                                                        'model' => $model,
                                                        'attribute' => "due_date",
                                                        // additional javascript options for the date picker plugin
                                                        'options' => array(
                                                            'dateFormat' => 'yy-mm-dd',
                                                        //             'changeMonth'=>true,
                                                        // 'changeYear'=>true,
                                                        // 'yearRange'=>'1900:2020'
                                                        ),
                                                        'htmlOptions' => array(),
                                                    )); ?>
                                                    <?php echo $form->error($model, 'due_date'); ?>
                                                </div>
                                                <div class="medium-7 columns">
                                                    <div class="field">
                                                        <div class="row collapse">
                                                            <div class="small-4 columns">
                                                                <label class="prefix">To</label>
                                                            </div>
                                                            <div class="small-8 columns">
                                                                <?php $this->widget('zii.widgets.jui.CJuiDatePicker', array(
                                                                    'model' => $model,
                                                                    'attribute' => "due_date_to",
                                                                    // additional javascript options for the date picker plugin
                                                                    'options' => array(
                                                                        'dateFormat' => 'yy-mm-dd',
                                                                    //             'changeMonth'=>true,
                                                                    // 'changeYear'=>true,
                                                                    // 'yearRange'=>'1900:2020'
                                                                    ),
                                                                    'htmlOptions' => array(),
                                                                )); ?>
                                                                <?php echo $form->error($model, 'due_date_to'); ?>
                                                            </div>
                                                        </div>
                                                    </div>															
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>	
                            </div>	
                            <div class="medium-6 columns">

                                <div class="field">
                                    <div class="row collapse">
                                        <div class="small-4 columns">
                                            <?php echo $form->label($model, 'invoice_number', array('class' => 'prefix')); ?>
                                        </div>
                                        <div class="small-8 columns">
                                            <?php echo $form->textField($model, 'invoice_number'); ?>
                                        </div>
                                    </div>
                                </div>	

                                <div class="field">
                                    <div class="row collapse">
                                        <div class="small-4 columns">
                                            <?php echo $form->label($model, 'status', array('class' => 'prefix')); ?>
                                        </div>
                                        <div class="small-8 columns">						
                                            <?php echo $form->dropDownList($model, 'status', array('PAID' => 'PAID', 'NOT PAID' => 'NOT PAID',), array('prompt' => 'Select',)); ?>
                                        </div>
                                    </div>
                                </div>	

                                <div class="buttons text-right">
                                    <?php echo CHtml::submitButton('Search', array('class' => 'button cbutton')); ?>
                                </div>

                            </div>
                        </div>

                        <?php $this->endWidget(); ?>
                    </div>
                </div>
            </div>

            <div class="grid-view">
                <?php $this->widget('zii.widgets.grid.CGridView', array(
                    'id' => 'invoice-header-grid',
                    'dataProvider' => $model->search(),
                    'filter' => $model,
                    // 'summaryText'=>'',
                    'rowCssClassExpression' => '(($data->status == "PAID")?"hijau":"merah")',
                    'template' => '{items}<!--<div class="clearfix">{summary}{pager}</div>-->',
                    'pager' => array(
                        'cssFile' => false,
                        'header' => '',
                    ),
                    'columns' => array(
                        array(
                            'class' => 'CCheckBoxColumn', //CHECKBOX COLUMN ADDED.
                            'selectableRows' => 2, //MULTIPLE ROWS CAN BE SELECTED.
                            'checked' => function($data) use($prChecked) {
                                return in_array($data->id, $prChecked);
                            },
                        ),
                        array(
                            'name' => 'invoice_number', 
                            'value' => 'CHtml::link($data->invoice_number, array("view", "id"=>$data->id))', 
                            'type' => 'raw'
                        ),
                        'invoice_date',
                        'due_date',
                        array(
                            'name' => 'reference_type', 
                            'value' => '$data->reference_type == 1 ? "Sales Order" : "Retail Sales"'
                        ),
                        array(
                            'name' => 'sales_order_id', 
                            'value' => '$data->sales_order_id != null ? $data->salesOrder->sale_order_no : CHtml::link($data->registrationTransaction->sales_order_number, array("/frontDesk/registrationTransaction/view", "id"=>$data->registration_transaction_id))',
                            'type' => 'raw'
                        ),
                        array(
                            'header' => 'WO #', 
                            'value' => '$data->sales_order_id != null ? "" : $data->registrationTransaction->work_order_number'
                        ),
                        array(
                            'name' => 'customer_id', 
                            'value' => '$data->customer_id != null ? $data->customer->name : ""'
                        ),
                        array(
                            'name' => 'customer_type', 
                            'value' => '$data->customer_id != null ? $data->customer->customer_type : ""'
                        ),
                        'status',
                    ),
                )); ?>

                <div class="button-group">
                    <?php if (Yii::app()->user->checkAccess("saleInvoiceEdit")): ?>
                        <?php echo CHtml::button("View Invoice", array("id" => "btnProses", 'class' => 'button cbutton')); ?>
                    <?php endif; ?>
                    <?php if (Yii::app()->user->checkAccess("saleInvoiceEdit")): ?>
                        <?php echo CHtml::button("Export PDF", array("id" => "btnProsesPdf", 'class' => 'button cbutton')); ?>
                    <?php endif; ?>

                    <?php echo CHtml::button("Clear Selected", array("id" => "btnClear", 'class' => 'button cbutton')); ?>
                </div>
            </div>
        </div>
    </div> <!-- end row -->
</div> <!-- end maintenance -->

<?php Yii::app()->clientScript->registerScript('centang', '
	$("#btnProses").click(function(){
        var checked=$("#invoice-header-grid").yiiGridView("getChecked","invoice-header-grid_c0");
        var count=checked.length;
        if (count>0){
            $.ajax({
                    data:{checked:checked},
                    url:"' . CHtml::normalizeUrl(array('invoiceHeader/prTemp')) . '",
                    success:function(data){
                    	$("#invoice-header-grid").yiiGridView("update",{});
                    	window.location.href = "' . CHtml::normalizeUrl(array('invoiceHeader/viewInvoices')) . '";
                    },              
            });
        } else {
            console.log("No Invoice items selected");
            alert("No Invoice items selected");
        }
    });

    $("#btnProsesPdf").click(function(){
        var checked=$("#invoice-header-grid").yiiGridView("getChecked","invoice-header-grid_c0");
        var count=checked.length;
        if (count > 0){
            $.ajax({
                data:{checked:checked},
                url:"' . CHtml::normalizeUrl(array('invoiceHeader/prTemp')) . '",
                success:function(data){
                    $("#invoice-header-grid").yiiGridView("update",{});
                    window.location.href = "' . CHtml::normalizeUrl(array('invoiceHeader/pdfAll')) . '";
                },              
            });
        } else {
            console.log("No Invoice items selected");
            alert("No Invoice items selected");
        }
    });

    $("#btnClear").click(function(){
        var checked="clear";
        $.ajax({
            data:{checked:checked},
            url:"' . CHtml::normalizeUrl(array('invoiceHeader/prTemp')) . '",
            success:function(data){
                $("#invoice-header-grid").yiiGridView("update",{});
            },              
        });
    });
'); ?>

/*
 <codex>
 <abstract>Simple 4x4 matrix computations</abstract>
 </codex>
 */

#ifndef MATRIX_H
#define MATRIX_H

void mat4f_LoadIdentity(float* m);
void mat4f_LoadScale(float* s, float* m);

void mat4f_LoadXRotation(float radians, float* mout);
void mat4f_LoadYRotation(float radians, float* mout);
void mat4f_LoadZRotation(float radians, float* mout);

void mat4f_LoadTranslation(float* t, float* mout);

void mat4f_LoadPerspective(float fov_radians, float aspect, float zNear, float zFar, float* mout);
void mat4f_LoadOrtho(float left, float right, float bottom, float top, float near, float far, float* mout);

void mat4f_MultiplyMat4f(const float* a, const float* b, float* mout);

#endif /* MATRIX_H */

<template>
  <div class="pay">
    <div class="pay-type">
      <span>交易方式:</span>
      <div :class="payType === 'union' ? 'unionSelected' : 'union'"
        @click="changePayType('union')"></div>
      <div :class="payType === 'deposit' ? 'depositSelected' : 'deposit'"
        @click="changePayType('deposit')"></div>
      <div :class="payType === 'alipay' ? 'alipaySelected' : 'alipay'"
        @click="changePayType('alipay')"></div>
      <div :class="payType === 'wepay' ? 'wepaySelected' : 'wepay'"
        @click="changePayType('wepay')"></div>
    </div>
    <!-- <div class="pay-total">
      <div class="pt-count">
        总计:
        <span>货品种类:{{od.total_type}}类</span>
        <span>数量总计:{{od.total_quantity}}件</span>
      </div>
      <div class="pt-pay">
        <span>运费共计:<span class="money">{{od.total_carriage}}</span></span>
        <span>货品总金额:<span class="money">¥{{od.total_money}}</span></span>
        <span class="ptp-total">应付总额(不含运费):<span class="money">¥{{od.total_money}}</span></span>
      </div>
    </div> -->
  </div>
</template>

<script>
export default {
  props: ['od', 'payType'],
  methods: {
    changePayType(type) {
      if(type === 'alipay' || type === 'wepay') this.$emit('updatePayType', {type})
      else this.$message('功能暂未开通...')
    }
  }
}
</script>

<style scoped lang="less">
.pay {
  width: 1024px;
  // height: 192px;

  @eColor: #ec6337;

  .p-box {
    display: flex;
    align-items: center;
    height: 112px;
    width: 1024px;
    padding: 0 10px;
    margin-bottom: 10px;
    font-size: 14px;
    color: #666;
    background-color: white;
  }

  .pay-type {
    .p-box;
    align-items: center;

    div {
      margin-left: 10px;
      width: 140px;
      height: 40px;
      box-sizing: border-box;
      cursor: pointer;
      border-radius: 4px;
    }

    .union {
      background: url(/static/img/p_union.png) 0 0 ~'/' 140px auto no-repeat;
      cursor: not-allowed;
    }

    .unionSelected {
      border: 1px solid @eColor;
      background: url(/static/img/p_union_selected.png) 0 0 ~'/' 140px auto no-repeat;
    }

    .deposit {
      background: url(/static/img/p_deposit.png) 0 0 ~'/' 140px auto no-repeat;
      cursor: not-allowed;
    }

    .depositSelected {
      border: 1px solid @eColor;
      background: url(/static/img/p_deposit_selected.png) 0 0 ~'/' 140px auto no-repeat;
    }

    .alipay {
      border: 1px solid #d8d8d8;
      background: url(/static/img/p_alipay_selected.png) 0 0 ~'/' 140px auto no-repeat;
    }

    .alipaySelected {
      border: 1px solid @eColor;
      background: url(/static/img/p_alipay_selected.png) 0 0 ~'/' 140px auto no-repeat;
    }

    .wepay {
      border: 1px solid #d8d8d8;
      background: url(/static/img/p_wepay_selected.png) 0 0 ~'/' 140px auto no-repeat;
    }

    .wepaySelected {
      border: 1px solid @eColor;
      background: url(/static/img/p_wepay_selected.png) 0 0 ~'/' 140px auto no-repeat;
    }
  }

  // .pay-total {
  //   .p-box;
  //   justify-content: space-between;

  //   .pt-count {

  //   }

  //   .pt-pay {
  //     display: flex;
  //     flex-direction: column;
  //     align-items: flex-end;
  //     font-size: 12px;

  //     .ptp-total {
  //       font-size: 14px;
  //     }

  //     .money {
  //       color: #ec6337;
  //       margin-left: 4px;
  //     }
  //   }
  // }
}
</style>

<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title><?= $title ?></title>

  <!-- Custom fonts for this template-->
  <link href="<?= base_url(); ?>assets/sbadmin/vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

  <!-- Custom styles for this template-->
  <link href="<?= base_url(); ?>assets/sbadmin/css/sb-admin-2.min.css" rel="stylesheet">
  <style>
    html { 
      background: url(<?= base_url(); ?>assets/img/backgroundpnp.jpeg) no-repeat center center fixed; 
      -webkit-background-size: cover;
      -moz-background-size: cover;
      -o-background-size: cover;
      background-size: cover;
    }
    body {
      background-color: transparent;
    }
    .special-card {
      background-color: rgba(245, 245, 245, 1);
      opacity: .91;
    }
  </style>

</head>

<body>
const axios = require("../connectionService").axios
const { JSDOM } = require("jsdom");
const unwanted = JSON.parse(process.env.unwanted)
const banList = JSON.parse(process.env.banList)
const extraStrategy = require('./extraStrategy')
async function getBestPriceForCard(dom, edition, extras){
    extraStrategy.removeUselessExtras(extras)
    const cheapestStorePdp = getCheapestOptionURL(dom, edition, extras)
    return await getPriceFromCheapestStore(cheapestStorePdp, edition, extras)
}

function getCheapestOptionURL(dom, edition, extras){
    const availableOptions = [...dom.window.document.querySelectorAll("#aba-cards>.estoque-linha")]
    let rightEdition = availableOptions.filter(item => item.querySelector(".ed-simb") && 
        item.querySelector(".ed-simb").href.endsWith(`=${edition}`))
    if(extras.length)
      rightEdition = filterExtras(rightEdition, extras)
    rightEdition = removeUnwantedQualityGrades(rightEdition)
    rightEdition = removeStoresFromBanlist(rightEdition)
    const url = "https://www.ligamagic.com.br/" +rightEdition[0].querySelector(".goto").href
    const selectedGrade =  rightEdition[0].querySelector(".e-col4>font").innerHTML
    return {url, selectedGrade}
}

function removeStoresFromBanlist(rightEdition){
    return rightEdition.filter(item => {
        const img = item.querySelector(".e-col1 img").title;
        return !banList.some(store => img.includes(store))
    })
}

function filterExtras(rightEdition, extras){
    return rightEdition.filter(
        item => item.querySelector("p.extras") 
        && extras.every(
            extra => item.querySelector("p.extras").innerHTML.split(", ").includes(extra)
            )
        )
}

function removeUnwantedQualityGrades(rightEdition){
    return rightEdition.filter(item => 
        {
            const quality = item.querySelector(".e-col4>font")
            return !unwanted.some(qlty =>
                quality && quality.innerHTML.includes(qlty)) 
        })
}

async function getPriceFromCheapestStore(cheapestStorePdp, edition, extras){
    const page = await(axios.get(cheapestStorePdp.url))
    const dom = new JSDOM(page.data)
    let options = [...dom.window.document.querySelectorAll(".itemMain table table:last-child tbody tr")].slice(1)
    options = options.filter(item => filterFoils(item, extras)).filter(filterOutOfStock)
    const selected = options.filter(item => 
        item.querySelector(".very2Small") &&
        item.querySelector(".very2Small").innerHTML.includes(cheapestStorePdp.selectedGrade)
        && item.querySelector("img").src.toLowerCase().includes(`/${edition.toLowerCase()}_`))[0]
    if(selected.querySelector(".itemPreco").childElementCount > 0)
        return selected.querySelector(".itemPreco").lastElementChild.innerHTML
    else
        return selected.querySelector(".itemPreco").innerHTML
}

function filterOutOfStock(item){
    return item.querySelector(".hmin30:nth-child(5)").innerHTML !== "0 unid.";
}

function filterFoils(item, extras){
    const inner = (auction) => {
        return auction.querySelector(".hmin30:nth-child(4)")
            && extraStrategy.containsAllExtras(auction.querySelector(".hmin30:nth-child(4)"), extras)
    }

    return extras ? inner(item) : !inner(item)

}



exports.getBestPriceForCard = getBestPriceForCard;
import Foundation
import ExecutionContext
import Future
import Result

public protocol TransactionType : DataConsumerType {
    func tryConsume(content:ContentType) -> Bool
    
    var action:Future<AbstractActionType> {get}
    
    func selfProcess()
}

class Transaction<RequestContent : ConstructableContentType, ResponseContent : FlushableContentType> : TransactionType {
    let app:Express
    let routeId:String
    let out:DataConsumerType
    let head:RequestHeadType
    let factory:RequestContent.Factory
    let content:Future<RequestContent.Factory.Content>
    let actionPromise:Promise<AbstractActionType>
    let action:Future<AbstractActionType>
    let request:Promise<Request<RequestContent>>
    
    internal required init(app:Express, routeId:String, head:RequestHeadType, out:DataConsumerType) {
        self.app = app
        self.routeId = routeId
        self.out = out
        self.head = head
        self.factory = RequestContent.Factory(response: head)
        self.content = factory.content()
        self.actionPromise = Promise()
        self.action = actionPromise.future
        self.request = Promise<Request<RequestContent>>()
        content.settle(in: ExecutionContext.user).onSuccess() { content in
            let request = Request<RequestContent>(app: app, head: head, body: content as? RequestContent)
            self.request.trySuccess(value: request)
        }
        content.onFailure { e in
            self.actionPromise.tryFail(error: e)
        }
    }
    
    convenience init(app:Express, routeId:String, head:RequestHeadType, out:DataConsumerType, handler:@escaping (Request<RequestContent>) -> Future<Action<ResponseContent>>) {
        self.init(app: app, routeId: routeId, head: head, out: out)
        request.future.onSuccess { request in
            let action = handler(request)
            action.onSuccess { action in
                self.actionPromise.trySuccess(value: action)
            }
            action.onFailure { e in
                self.failAction(e: e)
            }
        }
    }
    
    func failAction(e:Error) {
        self.actionPromise.tryFail(error: e)
    }
    
    func handleActionWithRequest<C : ConstructableContentType>(actionAndRequest:Future<(AbstractActionType, Request<C>?)>) {
        actionAndRequest.onComplete { result in
            let action = Future(result: result.map {$0.0})
            self.handleAction(action: action, request: result.value?.1)
        }
    }
    
    func handleAction<C : ConstructableContentType>(action:Future<AbstractActionType>, request:Request<C>?) {
        action.settle(in:ExecutionContext.action ).onSuccess{ action in
            if let request = request {
                self.processAction(action: action, request: request)
            } else {
                //yes we certainly have request here
                
                self.request.future.onSuccess{value in
                    self.processAction(action: action, request: value)
                }
            }
        }
        action.onFailure { e in
            //yes, we always have at least the default error handler
            let next = self.app.errorHandler.handle(e: e)!
            
            if let request = request {
                self.processAction(action: next, request: request)
            } else {
                self.request.future.onSuccess { request in
                    self.processAction(action: next, request: request)
                }
            }
        }
    }
    
    func selfProcess() {
        handleAction(action: action, request: Optional<Request<RequestContent>>.none)
    }
    
    func processAction<C : ConstructableContentType>(action:AbstractActionType, request:Request<C>) {
        switch action {
            case let flushableAction as FlushableAction: flushableAction.flushTo(out: out)
            case let intermediateAction as IntermediateActionType:
                let actAndReq = intermediateAction.nextAction(request: request)
                handleActionWithRequest(actionAndRequest: actAndReq)
            case let selfSufficientAction as SelfSufficientActionType:
                selfSufficientAction.handle(app: app, routeId: routeId, request: request, out: out).onFailure { e in
                    let action = Future<AbstractActionType>(error: e)
                    self.handleAction(action: action, request: request)
                }
            default:
                //TODO: handle server error
                print("wierd action... can do nothing with it")
        }
    }
    
    func tryConsume(content:ContentType) -> Bool {
        return factory.tryConsume(content: content)
    }
    
    func consume(data:Array<UInt8>) -> Future<Void> {
        return factory.consume(data: data)
    }
    
    func dataEnd() throws {
        try factory.dataEnd()
    }
}

typealias TransactionFactory = (RequestHeadType, DataConsumerType)->TransactionType
pragma solidity 0.6.10;
pragma experimental ABIEncoderV2;

import { IController } from "../interfaces/IController.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title IntegrationRegistry
 * @author Set Protocol
 *
 * The IntegrationRegistry holds state relating to the Modules and the integrations they are connected with.
 * The state is combined into a single Registry to allow governance updates to be aggregated to one contract.
 */
contract IntegrationRegistry is Ownable {

    /* ============ Events ============ */

    event IntegrationAdded(address indexed _module, address indexed _adapter, string _integrationName);
    event IntegrationRemoved(address indexed _module, address indexed _adapter, string _integrationName);
    event IntegrationEdited(
        address indexed _module,
        address _newAdapter,
        string _integrationName
    );

    /* ============ State Variables ============ */

    // Address of the Controller contract
    IController public controller;

    // Mapping of module => integration identifier => adapter address
    mapping(address => mapping(bytes32 => address)) private integrations;

    /* ============ Constructor ============ */

    /**
     * Initializes the controller
     *
     * @param _controller          Instance of the controller
     */
    constructor(IController _controller) public {
        controller = _controller;
    }

    /* ============ External Functions ============ */

    /**
     * GOVERNANCE FUNCTION: Add a new integration to the registry
     *
     * @param  _module       The address of the module associated with the integration
     * @param  _name         Human readable string identifying the integration
     * @param  _adapter      Address of the adapter contract to add
     */
    function addIntegration(
        address _module,
        string memory _name,
        address _adapter
    )
        public
        onlyOwner
    {
        bytes32 hashedName = _nameHash(_name);
        require(controller.isModule(_module), "Must be valid module.");
        require(integrations[_module][hashedName] == address(0), "Integration exists already.");
        require(_adapter != address(0), "Adapter address must exist.");

        integrations[_module][hashedName] = _adapter;

        emit IntegrationAdded(_module, _adapter, _name);
    }

    /**
     * GOVERNANCE FUNCTION: Batch add new adapters. Reverts if exists on any module and name
     *
     * @param  _modules      Array of addresses of the modules associated with integration
     * @param  _names        Array of human readable strings identifying the integration
     * @param  _adapters     Array of addresses of the adapter contracts to add
     */
    function batchAddIntegration(
        address[] memory _modules,
        string[] memory _names,
        address[] memory _adapters
    )
        external
        onlyOwner
    {
        // Storing modules count to local variable to save on invocation
        uint256 modulesCount = _modules.length;

        require(modulesCount > 0, "Modules must not be empty");
        require(modulesCount == _names.length, "Module and name lengths mismatch");
        require(modulesCount == _adapters.length, "Module and adapter lengths mismatch");

        for (uint256 i = 0; i < modulesCount; i++) {
            // Add integrations to the specified module. Will revert if module and name combination exists
            addIntegration(
                _modules[i],
                _names[i],
                _adapters[i]
            );
        }
    }

    /**
     * GOVERNANCE FUNCTION: Edit an existing integration on the registry
     *
     * @param  _module       The address of the module associated with the integration
     * @param  _name         Human readable string identifying the integration
     * @param  _adapter      Address of the adapter contract to edit
     */
    function editIntegration(
        address _module,
        string memory _name,
        address _adapter
    )
        public
        onlyOwner
    {
        bytes32 hashedName = _nameHash(_name);

        require(controller.isModule(_module), "Must be valid module.");
        require(integrations[_module][hashedName] != address(0), "Integration does not exist.");
        require(_adapter != address(0), "Adapter address must exist.");

        integrations[_module][hashedName] = _adapter;

        emit IntegrationEdited(_module, _adapter, _name);
    }

    /**
     * GOVERNANCE FUNCTION: Batch edit adapters for modules. Reverts if module and
     * adapter name don't map to an adapter address
     *
     * @param  _modules      Array of addresses of the modules associated with integration
     * @param  _names        Array of human readable strings identifying the integration
     * @param  _adapters     Array of addresses of the adapter contracts to add
     */
    function batchEditIntegration(
        address[] memory _modules,
        string[] memory _names,
        address[] memory _adapters
    )
        external
        onlyOwner
    {
        // Storing name count to local variable to save on invocation
        uint256 modulesCount = _modules.length;

        require(modulesCount > 0, "Modules must not be empty");
        require(modulesCount == _names.length, "Module and name lengths mismatch");
        require(modulesCount == _adapters.length, "Module and adapter lengths mismatch");

        for (uint256 i = 0; i < modulesCount; i++) {
            // Edits integrations to the specified module. Will revert if module and name combination does not exist
            editIntegration(
                _modules[i],
                _names[i],
                _adapters[i]
            );
        }
    }

    /**
     * GOVERNANCE FUNCTION: Remove an existing integration on the registry
     *
     * @param  _module       The address of the module associated with the integration
     * @param  _name         Human readable string identifying the integration
     */
    function removeIntegration(address _module, string memory _name) external onlyOwner {
        bytes32 hashedName = _nameHash(_name);
        require(integrations[_module][hashedName] != address(0), "Integration does not exist.");

        address oldAdapter = integrations[_module][hashedName];
        delete integrations[_module][hashedName];

        emit IntegrationRemoved(_module, oldAdapter, _name);
    }

    /* ============ External Getter Functions ============ */

    /**
     * Get integration adapter address associated with passed human readable name
     *
     * @param  _module       The address of the module associated with the integration
     * @param  _name         Human readable adapter name
     *
     * @return               Address of adapter
     */
    function getIntegrationAdapter(address _module, string memory _name) external view returns (address) {
        return integrations[_module][_nameHash(_name)];
    }

    /**
     * Get integration adapter address associated with passed hashed name
     *
     * @param  _module       The address of the module associated with the integration
     * @param  _nameHash     Hash of human readable adapter name
     *
     * @return               Address of adapter
     */
    function getIntegrationAdapterWithHash(address _module, bytes32 _nameHash) external view returns (address) {
        return integrations[_module][_nameHash];
    }

    /**
     * Check if adapter name is valid
     *
     * @param  _module       The address of the module associated with the integration
     * @param  _name         Human readable string identifying the integration
     *
     * @return               Boolean indicating if valid
     */
    function isValidIntegration(address _module, string memory _name) external view returns (bool) {
        return integrations[_module][_nameHash(_name)] != address(0);
    }

    /* ============ Internal Functions ============ */

    /**
     * Hashes the string and returns a bytes32 value
     */
    function _nameHash(string memory _name) internal pure returns(bytes32) {
        return keccak256(bytes(_name));
    }
}
import React from 'react';
import styled from 'styled-components/native';

export const Container = styled.SafeAreaView`
    flex: 1;
    justify-content:center;
    width:100%;
    /* background-color:#F2F6F8; */
    background-color:${props=>props.theme.background};
    padding:20px 20px 0 20px;
    
`;

export const Scroler = styled.ScrollView`
    flex: 1;
`;
export const Loading = styled.ActivityIndicator`
    margin:20px 0;
    color:${props=>props.theme.color};
`;
export const DadosCovid = styled.View`
`;

export const Graficos = styled.View`
    
`;

export const GraficosView = styled.View`
    margin:1px;
`;

export const Texto = styled.Text`

`;
export const Angola = styled.View`
    margin:1px;
    
    
    
    
`;
export const DadosAngola = styled.View`
    flex-direction:row;
    justify-content:space-between;
    flex:1;
    
   
`;

export const Dados = styled.View`
    background-color:${props=>props.theme.container};
    width:49%;
    padding:10px;
    overflow:hidden;
    border-radius:12px;
    elevation:2;
    margin-bottom:10px;
    height:90px;
    
`;

export const DadosCont = styled.View`
`;

export const TextoCont = styled.View`
    flex-direction:row;
    justify-content:space-between;
    align-items:center;
    margin-top:20px;
`;
export const TituloDado = styled.Text`
    font-family:"Poppins-Bold";
    letter-spacing:1px;
    font-size:18px;
    text-align:right;
    color:${props=>props.theme.color};
`;

export const TituloDadoNew = styled.Text`
    font-family:"Poppins-Bold";
    letter-spacing:1px;
    font-size:10px;
    text-align:right;
    margin-right:6px;
    color:${props=>props.theme.color};
    
`;
export const TituloDadoCritico = styled.Text`

    font-family:"Poppins-Bold";
    letter-spacing:1px;
    font-size:14px;
    color:${props=>props.theme.color};
`;
export const DadosCovidAngola = styled.View`

`;

Sensitivity analysis is an effective tool for systematically identifying
specific perturbations in parameters that have significant effects on the
behavior of a given biosystem, at the scale investigated. In this work, using a
two-dimensional, multiscale non-small cell lung cancer (NSCLC) model, we
examine the effects of perturbations in system parameters which span both
molecular and cellular levels, i.e. across scales of interest. This is achieved
by first linking molecular and cellular activities and then assessing the
influence of parameters at the molecular level on the tumor's spatio-temporal
expansion rate, which serves as the output behavior at the cellular level.
Overall, the algorithm operated reliably over relatively large variations of
most parameters, hence confirming the robustness of the model. However, three
pathway components (proteins PKC, MEK, and ERK) and eleven reaction steps were
determined to be of critical importance by employing a sensitivity coefficient
as an evaluation index. Each of these sensitive parameters exhibited a similar
changing pattern in that a relatively larger increase or decrease in its value
resulted in a lesser influence on the system's cellular performance. This study
provides a novel cross-scaled approach to analyzing sensitivities of
computational model parameters and proposes its application to
interdisciplinary biomarker studies.

Heavy-tailed or power-law distributions are becoming increasingly common in
biological literature. A wide range of biological data has been fitted to
distributions with heavy tails. Many of these studies use simple fitting
methods to find the parameters in the distribution, which can give highly
misleading results. The potential pitfalls that can occur when using these
methods are pointed out, and a step-by-step guide to fitting power-law
distributions and assessing their goodness-of-fit is offered.

Despite recent molecular technique improvements, biological knowledge remains
incomplete. Reasoning on living systems hence implies to integrate
heterogeneous and partial informations. Although current investigations
successfully focus on qualitative behaviors of macromolecular networks, others
approaches show partial quantitative informations like protein concentration
variations over times. We consider that both informations, qualitative and
quantitative, have to be combined into a modeling method to provide a better
understanding of the biological system. We propose here such a method using a
probabilistic-like approach. After its exhaustive description, we illustrate
its advantages by modeling the carbon starvation response in Escherichia coli.
In this purpose, we build an original qualitative model based on available
observations. After the formal verification of its qualitative properties, the
probabilistic model shows quantitative results corresponding to biological
expectations which confirm the interest of our probabilistic approach.

Many complex biological, social, and economical networks show topologies
drastically differing from random graphs. But, what is a complex network, i.e.\
how can one quantify the complexity of a graph? Here the Offdiagonal Complexity
(OdC), a new, and computationally cheap, measure of complexity is defined,
based on the node-node link cross-distribution, whose nondiagonal elements
characterize the graph structure beyond link distribution, cluster coefficient
and average path length. The OdC apporach is applied to the {\sl Helicobacter
pylori} protein interaction network and randomly rewired surrogates thereof. In
addition, OdC is used to characterize the spatial complexity of cell
aggregates. We investigate the earliest embryo development states of
Caenorhabditis elegans. The development states of the premorphogenetic phase
are represented by symmetric binary-valued cell connection matrices with
dimension growing from 4 to 385. These matrices can be interpreted as adjacency
matrix of an undirected graph, or network. The OdC approach allows to describe
quantitatively the complexity of the cell aggregate geometry.

Two recent streams of work suggest that pairwise interactions may be
sufficient to capture the complexity of biological systems ranging from protein
structure to networks of neurons. In one approach, possible amino acid
sequences in a family of proteins are generated by Monte Carlo annealing of a
"Hamiltonian" that forces pairwise correlations among amino acid substitutions
to be close to the observed correlations. In the other approach, the observed
correlations among pairs of neurons are used to construct a maximum entropy
model for the states of the network as a whole. We show that, in certain
limits, these two approaches are mathematically equivalent, and we comment on
open problems suggested by this framework

Given a metabolic network in terms of its metabolites and reactions, our goal
is to efficiently compute the minimal knock out sets of reactions required to
block a given behaviour. We describe an algorithm which improves the
computation of these knock out sets when the elementary modes (minimal
functional subsystems) of the network are given. We also describe an algorithm
which computes both the knock out sets and the elementary modes containing the
blocked reactions directly from the description of the network and whose
worst-case computational complexity is better than the algorithms currently in
use for these problems. Computational results are included.

Over the last decade, a large variety of clustering algorithms have been
developed to detect coregulatory relationships among genes from microarray gene
expression data. Model based clustering approaches have emerged as
statistically well grounded methods, but the properties of these algorithms
when applied to large-scale data sets are not always well understood. An
in-depth analysis can reveal important insights about the performance of the
algorithm, the expected quality of the output clusters, and the possibilities
for extracting more relevant information out of a particular data set. We have
extended an existing algorithm for model based clustering of genes to
simultaneously cluster genes and conditions, and used three large compendia of
gene expression data for S. cerevisiae to analyze its properties. The algorithm
uses a Bayesian approach and a Gibbs sampling procedure to iteratively update
the cluster assignment of each gene and condition. For large-scale data sets,
the posterior distribution is strongly peaked on a limited number of
equiprobable clusterings. A GO annotation analysis shows that these local
maxima are all biologically equally significant, and that simultaneously
clustering genes and conditions performs better than only clustering genes and
assuming independent conditions. A collection of distinct equivalent
clusterings can be summarized as a weighted graph on the set of genes, from
which we extract fuzzy, overlapping clusters using a graph spectral method. The
cores of these fuzzy clusters contain tight sets of strongly coexpressed genes,
while the overlaps exhibit relations between genes showing only partial
coexpression.

The G-protein coupled receptor (GPCR) superfamily is currently the largest
class of therapeutic targets. \textit{In silico} prediction of interactions
between GPCRs and small molecules is therefore a crucial step in the drug
discovery process, which remains a daunting task due to the difficulty to
characterize the 3D structure of most GPCRs, and to the limited amount of known
ligands for some members of the superfamily. Chemogenomics, which attempts to
characterize interactions between all members of a target class and all small
molecules simultaneously, has recently been proposed as an interesting
alternative to traditional docking or ligand-based virtual screening
strategies. We propose new methods for in silico chemogenomics and validate
them on the virtual screening of GPCRs. The methods represent an extension of a
recently proposed machine learning strategy, based on support vector machines
(SVM), which provides a flexible framework to incorporate various information
sources on the biological space of targets and on the chemical space of small
molecules. We investigate the use of 2D and 3D descriptors for small molecules,
and test a variety of descriptors for GPCRs. We show fo instance that
incorporating information about the known hierarchical classification of the
target family and about key residues in their inferred binding pockets
significantly improves the prediction accuracy of our model. In particular we
are able to predict ligands of orphan GPCRs with an estimated accuracy of
78.1%.

A composite, exponential relaxation function, modulated by a periodic
component, was used to fit to an experimental time series of blood glucose
levels. The 11 parameters function that allows for the detection of a possible
rhythm transition was fitted to the experimental time series using a genetic
algorithm. It has been found that the relaxation from a hyperglycemic condition
following a change in the anti-diabetic treatment, can be characterized by a
change from an initial 12 hours ultradian rhythm to a near-24 hours circadian
rhythm.

In many experiments, the aim is to deduce an underlying multi-substate on-off
kinetic scheme (KS) from the statistical properties of a two-state trajectory.
However, the mapping of a KS into a two-state trajectory leads to the loss of
information about the KS, and so, in many cases, more than one KS can be
associated with the data. We recently showed that the optimal way to solve this
problem is to use canonical forms of reduced dimensions (RD). RD forms are
on-off networks with connections only between substates of different states,
where the connections can have non-exponential waiting time probability density
functions (WT-PDFs). In theory, only a single RD form can be associated with
the data. To utilize RD forms in the analysis of the data, a RD form should be
associated with the data. Here, we give a toolbox for building a RD form from a
finite two-state trajectory. The methods in the toolbox are based on known
statistical methods in data analysis, combined with statistical methods and
numerical algorithms designed specifically for the current problem. Our toolbox
is self-contained - it builds a mechanism based only on the information it
extracts from the data, and its implementation on the data is fast (analyzing a
10^6 cycle trajectory from a thirty-parameter mechanism takes a couple of hours
on a PC with a 2.66 GHz processor). The toolbox is automated and is freely
available for academic research upon electronic request.

MOTIVATION: The use of oligonucleotide microarray technology requires a very
detailed attention to the design of specific probes spotted on the solid phase.
These problems are far from being commonplace since they refer to complex
physicochemical constraints. Whereas there are more and more publicly available
programs for microarray oligonucleotide design, most of them use the same
algorithm or criteria to design oligos, with only little variation. RESULTS: We
show that classical approaches used in oligo design software may be inefficient
under certain experimental conditions, especially when dealing with complex
target mixtures. Indeed, our biological model is a human obligate parasite, the
microsporidia Encephalitozoon cuniculi. Targets that are extracted from
biological samples are composed of a mixture of pathogen transcripts and host
cell transcripts. We propose a new approach to design oligonucleotides which
combines good specificity with a potentially high sensitivity. This approach is
original in the biological point of view as well as in the algorithmic point of
view. We also present an experimental validation of this new strategy by
comparing results obtained with standard oligos and with our composite oligos.
A specific E.cuniculi microarray will overcome the difficulty to discriminate
the parasite mRNAs from the host cell mRNAs demonstrating the power of the
microarray approach to elucidate the lifestyle of an intracellular pathogen
using mix mRNAs.

Living cells are the product of gene expression programs that involve the
regulated transcription of thousands of genes. The elucidation of
transcriptional regulatory networks in thus needed to understand the cell's
working mechanism, and can for example be useful for the discovery of novel
therapeutic targets. Although several methods have been proposed to infer gene
regulatory networks from gene expression data, a recent comparison on a
large-scale benchmark experiment revealed that most current methods only
predict a limited number of known regulations at a reasonable precision level.
We propose SIRENE, a new method for the inference of gene regulatory networks
from a compendium of expression data. The method decomposes the problem of gene
regulatory network inference into a large number of local binary classification
problems, that focus on separating target genes from non-targets for each TF.
SIRENE is thus conceptually simple and computationally efficient. We test it on
a benchmark experiment aimed at predicting regulations in E. coli, and show
that it retrieves of the order of 6 times more known regulations than other
state-of-the-art inference methods.

We define the complexity of DNA sequences as the information content per
nucleotide, calculated by means of some Lempel-Ziv data compression algorithm.
It is possible to use the statistics of the complexity values of the functional
regions of different complete genomes to distinguish among genomes of different
domains of life (Archaea, Bacteria and Eukarya). We shall focus on the
distribution function of the complexity of noncoding regions. We show that the
three domains may be plotted in separate regions within the two-dimensional
space where the axes are the skewness coefficient and the curtosis coefficient
of the aforementioned distribution. Preliminary results on 15 genomes are
introduced.

Models of the dynamics of cellular interaction networks have become
increasingly larger in recent years. Formal verification based on model
checking provides a powerful technology to keep up with this increase in scale
and complexity. The application of model-checking approaches is hampered,
however, by the difficulty for non-expert users to formulate appropriate
questions in temporal logic. In order to deal with this problem, we propose the
use of patterns, that is, high-level query templates that capture recurring
biological questions and that can be automatically translated into temporal
logic. The applicability of the developed set of patterns has been investigated
by the analysis of an extended model of the network of global regulators
controlling the carbon starvation response in Escherichia coli.

Combination therapies are often needed for effective clinical outcomes in the
management of complex diseases, but presently they are generally based on
empirical clinical experience. Here we suggest a novel application of search
algorithms, originally developed for digital communication, modified to
optimize combinations of therapeutic interventions. In biological experiments
measuring the restoration of the decline with age in heart function and
exercise capacity in Drosophila melanogaster, we found that search algorithms
correctly identified optimal combinations of four drugs with only one third of
the tests performed in a fully factorial search. In experiments identifying
combinations of three doses of up to six drugs for selective killing of human
cancer cells, search algorithms resulted in a highly significant enrichment of
selective combinations compared with random searches. In simulations using a
network model of cell death, we found that the search algorithms identified the
optimal combinations of 6-9 interventions in 80-90% of tests, compared with
15-30% for an equivalent random search. These findings suggest that modified
search algorithms from information theory have the potential to enhance the
discovery of novel therapeutic drug combinations. This report also helps to
frame a biomedical problem that will benefit from an interdisciplinary effort
and suggests a general strategy for its solution.

Any cutting-edge scientific research project requires a myriad of
computational tools for data generation, management, analysis and
visualization. Python is a flexible and extensible scientific programming
platform that offered the perfect solution in our recent comparative genomics
investigation (J. B. Lucks, D. R. Nelson, G. Kudla, J. B. Plotkin. Genome
landscapes and bacteriophage codon usage, PLoS Computational Biology, 4,
1000001, 2008). In this paper, we discuss the challenges of this project, and
how the combined power of Biopython, Matplotlib and SWIG were utilized for the
required computational tasks. We finish by discussing how python goes beyond
being a convenient programming language, and promotes good scientific practice
by enabling clean code, integration with professional programming techniques
such as unit testing, and strong data provenance.

Summary: In anticipation of the individualized proteomics era and the need to
integrate knowledge from disease studies, we have augmented our peptide
identification software RAId DbS to take into account annotated single amino
acid polymorphisms, post-translational modifications, and their documented
disease associations while analyzing a tandem mass spectrum. To facilitate new
discoveries, RAId DbS allows users to conduct searches permitting novel
polymorphisms. Availability: The webserver link is http://www.ncbi.nlm.nih.gov/
/CBBResearch/qmbp/raid dbs/index.html. The relevant databases and binaries of
RAId DbS for Linux, Windows, and Mac OS X are available from the same web page.
Contact: yyu@ncbi.nlm.nih.gov

Models of reaction chemistry based on the stochastic simulation algorithm
(SSA) have become a crucial tool for simulating complicated biological reaction
networks due to their ability to handle extremely complicated reaction networks
and to represent noise in small-scale chemistry. These methods can, however,
become highly inefficient for stiff reaction systems, those in which different
reaction channels operate on widely varying time scales. In this paper, we
develop two methods for accelerating sampling in SSA models: an exact method
and a scheme allowing for sampling accuracy up to any arbitrary error bound.
Both methods depend on analysis of the eigenvalues of continuous time Markov
model graphs that define the behavior of the SSA. We demonstrate these methods
for the specific application of sampling breakage times for multiply-connected
bond networks, a class of stiff system important to models of self-assembly
processes. We show theoretically and empirically that our eigenvalue methods
provide substantially reduced sampling times for a wide range of network
breakage models. These techniques are also likely to have broad use in
accelerating SSA models so as to apply them to systems and parameter ranges
that are currently computationally intractable.

Statistical inference of genetic regulatory networks is essential for
understanding temporal interactions of regulatory elements inside the cells.
For inferences of large networks, identification of network structure is
typical achieved under the assumption of sparsity of the networks.
  When the number of time points in the expression experiment is not too small,
we propose to infer the parameters in the ordinary differential equations using
the techniques from functional data analysis (FDA) by regarding the observed
time course expression data as continuous-time curves. For networks with a
large number of genes, we take advantage of the sparsity of the networks by
penalizing the linear coefficients with a L_1 norm. The ability of the
algorithm to infer network structure is demonstrated using the cell-cycle time
course data for Saccharomyces cerevisiae.

In Proteomics, only the de novo peptide sequencing approach allows a partial
amino acid sequence of a peptide to be found from a MS/MS spectrum. In this
article a preliminary work is presented to discover a complete protein sequence
from spectral data (MS and MS/MS spectra). For the moment, our approach only
uses MS spectra. A Genetic Algorithm (GA) has been designed with a new
evaluation function which works directly with a complete MS spectrum as input
and not with a mass list like the other methods using this kind of data. Thus
the mono isotopic peak extraction step which needs a human intervention is
deleted. The goal of this approach is to discover the sequence of unknown
proteins and to allow a better understanding of the differences between
experimental proteins and proteins from databases.

Some problems with the mathematical analysis on which the UK Non-Native
Organism Risk Assessment Scheme is based are outlined.

This report presents the implementation of a protein sequence comparison
algorithm specifically designed for speeding up time consuming part on parallel
hardware such as SSE instructions, multicore architectures or graphic boards.
Three programs have been developed: PLAST-P, TPLAST-N and PLAST-X. They provide
equivalent results compared to the NCBI BLAST family programs (BLAST-P,
TBLAST-N and BLAST-X) with a speed-up factor ranging from 5 to 10.

Information theory is a branch of probability and statistics involving the
analysis of communications. Information theory enables us to analyze and
quantify the information content of predictions made in the context of plant
disease management and related disciplines. In this article, some applications
of information theory in plant disease management are outlined.

The functioning of many biochemical networks is often robust -- remarkably
stable under changes in external conditions and internal reaction parameters.
Much recent work on robustness and evolvability has focused on the structure of
neutral spaces, in which system behavior remains invariant to mutations.
Recently we have shown that the collective behavior of multiparameter models is
most often 'sloppy': insensitive to changes except along a few 'stiff'
combinations of parameters, with an enormous sloppy neutral subspace.
Robustness is often assumed to be an emergent evolved property, but the
sloppiness natural to biochemical networks offers an alternative non-adaptive
explanation. Conversely, ideas developed to study evolvability in robust
systems can be usefully extended to characterize sloppy systems.

We review a recent trend in computational systems biology which aims at using
pattern recognition algorithms to infer the structure of large-scale biological
networks from heterogeneous genomic data. We present several strategies that
have been proposed and that lead to different pattern recognition problems and
algorithms. The strenght of these approaches is illustrated on the
reconstruction of metabolic, protein-protein and regulatory networks of model
organisms. In all cases, state-of-the-art performance is reported.

In this short note, we analyze the assumptions made by McDougal et al (2006),
both explicit and implicit, in their estimation of the proportion of "true
recent infections" using the BED CEIA. This enables us to write down
expressions for the sensitivity, short term specificity and long term
specificity of a test for recent infection defined by a BED ODn below a
threshold. We then derive an identity which shows the relationship between
these parameters, allowing the elimination of sensitivity and short term
specificity from an expression relating the proportion of "true recent
infections" to the proportion of seropositive individuals testing below
threshold. This has two important consequences. Firstly, the simplified formula
is substantially more amenable to calibration. Secondly, naively treating the
parameters as independent would lead to an incorrect estimate of uncertainty
due to imperfect calibration.

We provide a complete thermodynamic solution of a 1D hopping model in the
presence of a random potential by obtaining the density of states. Since the
partition function is related to the density of states by a Laplace transform,
the density of states determines completely the thermodynamic behavior of the
system. We have also shown that the transfer matrix technique, or the so-called
dynamic programming, used to obtain the density of states in the 1D hopping
model may be generalized to tackle a long-standing problem in statistical
significance assessment for one of the most important proteomic tasks - peptide
sequencing using tandem mass spectrometry data.

Statistically meaningful comparison/combination of peptide identification
results from various search methods is impeded by the lack of a universal
statistical standard. Providing an E-value calibration protocol, we
demonstrated earlier the feasibility of translating either the score or
heuristic E-value reported by any method into the textbook-defined E-value,
which may serve as the universal statistical standard. This protocol, although
robust, may lose spectrum-specific statistics and might require a new
calibration when changes in experimental setup occur. To mitigate these issues,
we developed a new MS/MS search tool, RAId_aPS, that is able to provide
spectrum-specific E-values for additive scoring functions. Given a selection of
scoring functions out of RAId score, K-score, Hyperscore and XCorr, RAId_aPS
generates the corresponding score histograms of all possible peptides using
dynamic programming. Using these score histograms to assign E-values enables a
calibration-free protocol for accurate significance assignment for each scoring
function. RAId_aPS features four different modes: (i) compute the total number
of possible peptides for a given molecular mass range, (ii) generate the score
histogram given a MS/MS spectrum and a scoring function, (iii) reassign
E-values for a list of candidate peptides given a MS/MS spectrum and the
scoring functions chosen, and (iv) perform database searches using selected
scoring functions. In modes (iii) and (iv), RAId_aPS is also capable of
combining results from different scoring functions using spectrum-specific
statistics. The web link is
http://www.ncbi.nlm.nih.gov/CBBresearch/Yu/raid_aps/index.html. Relevant
binaries for Linux, Windows, and Mac OS X are available from the same page.

Networks of person-person contacts form the substrate along which infectious
diseases spread. Most network-based studies of the spread focus on the impact
of variations in degree (the number of contacts an individual has). However,
other effects such as clustering, variations in infectiousness or
susceptibility, or variations in closeness of contacts may play a significant
role. We develop analytic techniques to predict how these effects alter the
growth rate, probability, and size of epidemics and validate the predictions
with a realistic social network. We find that (for given degree distribution
and average transmissibility) clustering is the dominant factor controlling the
growth rate, heterogeneity in infectiousness is the dominant factor controlling
the probability of an epidemic, and heterogeneity in susceptibility is the
dominant factor controlling the size of an epidemic. Edge weights (measuring
closeness or duration of contacts) have impact only if correlations exist
between different edges. Combined, these effects can play a minor role in
reinforcing one another, with the impact of clustering largest when the
population is maximally heterogeneous or if the closer contacts are also
strongly clustered. Our most significant contribution is a systematic way to
address clustering in infectious disease models, and our results have a number
of implications for the design of interventions.

The Tribolium genome contains 21 nuclear receptors, representing all of the
six known subfamilies. When compared to other species, this first complete set
for a Coleoptera reveals a strong conservation of the number and identity of
nuclear receptors in holometabolous insects. Two novelties are observed: the
atypical NR0 gene knirps is present only in brachyceran flies, while the NR2E6
gene is found only in Tribolium and in Apis. Using a quantitative analysis of
the evolutionary rate, we discovered that nuclear receptors could be divided
into two groups. In one group of 13 proteins, the rates follow the trend of the
Mecopterida genome-wide acceleration. In a second group of five nuclear
receptors, all acting together at the top of the ecdysone cascade, we observed
an overacceleration of the evolutionary rate during the early divergence of
Mecopterida. We thus extended our analysis to the twelve classic ecdysone
transcriptional regulators and found that six of them (ECR, USP, HR3, E75, HR4
and Kr-h1) underwent an overacceleration at the base of the Mecopterida
lineage. By contrast, E74, E93, BR, HR39, FTZ-F1 and E78 do not show this
divergence. We suggest that coevolution occurred within a network of regulators
that control the ecdysone cascade. The advent of Tribolium as a powerful model
should allow a better understanding of this evolution.

In this report we review modern nonlinearity methods that can be used in the
preterm birth analysis. The nonlinear analysis of uterine contraction signals
can provide information regarding physiological changes during the menstrual
cycle and pregnancy. This information can be used both for the preterm birth
prediction and the preterm labor control.
  Keywords: preterm birth, complex data analysis, nonlinear methods

Clustering is a concept used in a huge variety of applications. We review a
conceptually very simple algorithm for hierarchical clustering called in the
following the {\it mutual information clustering} (MIC) algorithm. It uses
mutual information (MI) as a similarity measure and exploits its grouping
property: The MI between three objects X, Y, and Z is equal to the sum of the
MI between X and Y, plus the MI between Z and the combined object (XY). We use
MIC both in the Shannon (probabilistic) version of information theory, where
the "objects" are probability distributions represented by random samples, and
in the Kolmogorov (algorithmic) version, where the "objects" are symbol
sequences. We apply our method to the construction of phylogenetic trees from
mitochondrial DNA sequences and we reconstruct the fetal ECG from the output of
independent components analysis (ICA) applied to the ECG of a pregnant woman.

We discuss the property of a.e. and in mean convergence of the Kohonen
algorithm considered as a stochastic process. The various conditions ensuring
the a.e. convergence are described and the connection with the rate decay of
the learning parameter is analyzed. The rate of convergence is discussed for
different choices of learning parameters. We proof rigorously that the rate of
decay of the learning parameter which is most used in the applications is a
sufficient condition for a.e. convergence and we check it numerically. The aim
of the paper is also to clarify the state of the art on the convergence
property of the algorithm in view of the growing number of applications of the
Kohonen neural networks. We apply our theorem and considerations to the case of
genetic classification which is a rapidly developing field.

We propose that certain patterns (scars) -- theoretically and numerically
predicted to be formed by electrons arranged on a sphere to minimize the
repulsive Coulomb potential (the Thomson problem) and experimentally found in
spherical crystals formed by self-assembled polystyrene beads (an instance of
the {\it generalized} Thomson problem) -- could be relevant to extend the
classic Caspar and Klug construction for icosahedrally-shaped virus capsids.
The main idea is that scars could be produced on the capsid at an intermediate
stage of its evolution and the release of the bending energy present in scars
into stretching energy could allow for shape-changes. The conjecture can be
tested in experiments and/or in numerical simulations.

We apply Markov chain lumping techniques to aggregate codons from an
empirical substitution matrix. The standard genetic code as well as higher
order amino acid substitution groups are identified. Since the aggregates are
derived from first principles they do not rely on system dependent assumptions
made beforehand, e.g. regarding criteria on what should constitute an amino
acid group. We therefore argue that the acquired aggregations more accurately
capture the multi-level structure of the substitution dynamics than alternative
techniques.

We apply the concept of subset seeds proposed in [1] to similarity search in
protein sequences. The main question studied is the design of efficient seed
alphabets to construct seeds with optimal sensitivity/selectivity trade-offs.
We propose several different design methods and use them to construct several
alphabets.We then perform an analysis of seeds built over those alphabet and
compare them with the standard Blastp seeding method [2,3], as well as with the
family of vector seeds proposed in [4]. While the formalism of subset seed is
less expressive (but less costly to implement) than the accumulative principle
used in Blastp and vector seeds, our seeds show a similar or even better
performance than Blastp on Bernoulli models of proteins compatible with the
common BLOSUM62 matrix.

Molecular docking is an essential tool for drug design. It helps the
scientist to rapidly know if two molecules, respectively called ligand and
receptor, can be combined together to obtain a stable complex. We propose a new
multi-objective model combining an energy term and a surface term to gain such
complexes. The aim of our model is to provide complexes with a low energy and
low surface. This model has been validated with two multi-objective genetic
algorithms on instances from the literature dedicated to the docking
benchmarking.

Recent advances in experimental neuroscience allow, for the first time,
non-invasive studies of the white matter tracts in the human central nervous
system, thus making available cutting-edge brain anatomical data describing
these global connectivity patterns. This new, non-invasive, technique uses
magnetic resonance imaging to construct a snap-shot of the cortical network
within the living human brain. Here, we report on the initial success of a new
weighted network communicability measure in distinguishing local and global
differences between diseased patients and controls. This approach builds on
recent advances in network science, where an underlying connectivity structure
is used as a means to measure the ease with which information can flow between
nodes. One advantage of our method is that it deals directly with the
real-valued connectivity data, thereby avoiding the need to discretise the
corresponding adjacency matrix, that is, to round weights up to 1 or down to 0,
depending upon some threshold value. Experimental results indicate that the new
approach is able to highlight biologically relevant features that are not
immediately apparent from the raw connectivity data.

An approach for multiplex qualitative and quantitative microarray-based PCR
analysis has been proposed. The characteristics of PCR executed on a gel-based
oligonucleotide microarray with immobilized forward primers and a single common
reverse primer in solution were investigated for several DNA targets. One-stage
multiplex on-chip PCR was studied for simultaneous amplification of herpes
simplex viruses types 1 and 2, cytomegalovirus DNA, and bacteriophage lambda
DNA as an internal control. Additionally the joint analysis of increased number
of targets (with addition of Chlamydia trachomatis, Mycoplasma hominis, and
Ureaplasma urealyticum DNA) was done in two-stage version of assay: first stage
was in-tube PCR with target-specific primers, while the reverse ones contained
5'-adapter region; the second stage was on-chip amplification with immobilized
target-specific forward primers and adapter as common reverse primer in
solution. The possible application of one-stage reaction for human cDNA
analysis was additionally demonstrated with utilization of a common
poly-T-containing primer in solution. SYBR green I; and Cy-5 labeled dUTP were
used for real-time and end-point detection of specific PCR products. The
efficiencies of both one-stage and two-stage reactions was shown to be strongly
dependent on magnesium and primers concentrations. Quantitative PCR in the both
versions was studied with 10-fold serial dilutions of phage lambda DNA. The
method enabled detection of 6 DNA copies per reaction for both versions of
assay. The quantitative interval for one-stage reaction covered eight orders of
concentration. The revealed significant effect of gel pad size on microarray
PCR effectiveness has been discussed.

The Automated Protein Structure Analysis (APSA) method is used for the
classification of supersecondary structures. Basis for the classification is
the encoding of three-dimensional (3D) residue conformations into a 16-letter
code (3D-1D projection). It is shown that the letter code of the protein makes
it possible to reconstruct its overall shape without ambiguity (1D-3D
translation). Accordingly, the letter code is used for the development of
classification rules that distinguish supersecondary structures by the
properties of their turns and the orientation of the flanking helix or strand
structures. The orientations of turn and flanking structures are collected in
an octant system that helps to specify 196 supersecondary groups for
(alpha,alpha)-, (alpha,beta)-, (beta,alpha)-, (beta,beta)-class. 391 protein
chains leading to 2499 super secondary structures were analyzed. Frequently
occurring super secondary structures are identified with the help of the octant
classification system and explained on the basis of their letter and
classification codes.

A new method for the Automated Protein Structure Analysis (APSA) is derived,
which simplifies the protein backbone to a smooth curve in 3-dimensional space.
For the purpose of obtaining this smooth line each amino acid is represented by
its C$_{\alpha}$ atom, which serves as suitable anchor point for a cubic spline
fit. The backbone line is characterized by arc length $s$, curvature
$\kappa(s)$, and torsion $\tau(s)$. The $\kappa(s)$ and $\tau(s)$ diagrams of
the protein backbone suppress, because of the level of coarse graining applied,
details of the bond framework of the backbone, however reveal accurately all
secondary structure features of a protein. Advantages of APSA are its
quantitative representation and analysis of 3-dimensional structure in form of
2-dimensional curvature and torsion patterns, its easy visualization of
complicated conformational features, and its general applicability. Typical
differences between 3$_{10}$-,$\alpha$-, $\pi$-helices, and $\beta$-strands are
quantified with the help of the $\kappa(s)$ and $\tau(s)$ diagrams. For a test
set of 20 proteins, 63 % of all helical residues and 48.5 % of all extended
residues are identified to be in ideal conformational environments with the
help of APSA. APSA is compared with other methods for protein structure
analysis and its applicability to higher levels of protein structure is
discussed.

We have investigated the binding interaction between the bacteriophage lambda
repressor CI and its target DNA using total internal reflection fluorescence
microscopy. Large, step-wise changes in the intensity of the red fluorescent
protein fused to CI were observed as it associated and dissociated from
individually labeled single molecule DNA targets. The stochastic association
and dissociation were characterized by Poisson statistics. Dark and bright
intervals were measured for thousands of individual events. The exponential
distribution of the intervals allowed direct determination of the association
and dissociation rate constants, ka and kd respectively. We resolved in detail
how ka and kd varied as a function of 3 control parameters, the DNA length L,
the CI dimer concentration, and the binding affinity. Our results show that
although interaction with non-operator DNA sequences are observable, CI binding
to the operator site is not dependent on the length of flanking non-operator
DNA.

This note studies feedforward circuits as models for perfect adaptation to
step signals in biological systems. A global convergence theorem is proved in a
general framework, which includes examples from the literature as particular
cases. A notable aspect of these circuits is that they do not adapt to pulse
signals, because they display a memory phenomenon. Estimates are given of the
magnitude of this effect.

This article is addressing a recurrent problem in biology: mining newly built
large scale networks. Our approach consists in comparing these new networks to
well known ones. The visual backbone of this comparative analysis is provided
by a network classification hierarchy. This method makes sense when dealing
with metabolic networks since comparison could be done using pathways
(clusters). Moreover each network models an organism and it exists organism
classification such as taxonomies. Video demonstration:
http://www.labri.fr/perso/bourqui/video.wmv

Random Threshold Networks (RTNs) are an idealized model of diluted, non
symmetric spin glasses, neural networks or gene regulatory networks. RTNs also
serve as an interesting general example of any coordinated causal system. Here
we study the conditions for maximal information transfer and behavior diversity
in RTNs. These conditions are likely to play a major role in physical and
biological systems, perhaps serving as important selective traits in biological
systems. We show that the pairwise mutual information is maximized in
dynamically critical networks. Also, we show that the correlated behavior
diversity is maximized for slightly chaotic networks, close to the critical
region. Importantly, critical networks maximize coordinated, diverse dynamical
behavior across the network and across time: the information transmission
between source and receiver nodes and the diversity of dynamical behaviors,
when measured with a time delay between the source and receiver, are maximized
for critical networks.

We apply the concept of subset seeds proposed in [1] to similarity search in
protein sequences. The main question studied is the design of efficient seed
alphabets to construct seeds with optimal sensitivity/selectivity trade-offs.
We propose several different design methods and use them to construct several
alphabets. We then perform a comparative analysis of seeds built over those
alphabets and compare them with the standard BLASTP seeding method [2], [3], as
well as with the family of vector seeds proposed in [4]. While the formalism of
subset seeds is less expressive (but less costly to implement) than the
cumulative principle used in BLASTP and vector seeds, our seeds show a similar
or even better performance than BLASTP on Bernoulli models of proteins
compatible with the common BLOSUM62 matrix. Finally, we perform a large-scale
benchmarking of our seeds against several main databases of protein alignments.
Here again, the results show a comparable or better performance of our seeds
vs. BLASTP.

We study a method of seed-based lossless filtration for approximate string
matching and related bioinformatics applications. The method is based on a
simultaneous use of several spaced seeds rather than a single seed as studied
by Burkhardt and K\"arkk\"ainen [1]. We present algorithms to compute several
important parameters of seed families, study their combinatorial properties,
and describe several techniques to construct efficient families. We also report
a large-scale application of the proposed technique to the problem of
oligonucleotide selection for an EST sequence database.

A basic assumption of molecular biology is that proteins sharing close
three-dimensional (3D) structures are likely to share a common function and in
most cases derive from a same ancestor. Computing the similarity between two
protein structures is therefore a crucial task and has been extensively
investigated. Evaluating the similarity of two proteins can be done by finding
an optimal one-to-one matching between their components, which is equivalent to
identifying a maximum weighted clique in a specific "alignment graph". In this
paper we present a new integer programming formulation for solving such clique
problems. The model has been implemented using the ILOG CPLEX Callable Library.
In addition, we designed a dedicated branch and bound algorithm for solving the
maximum cardinality clique problem. Both approaches have been integrated in
VAST (Vector Alignment Search Tool) - a software for aligning protein 3D
structures largely used in NCBI (National Center for Biotechnology
Information). The original VAST clique solver uses the well known Bron and
Kerbosh algorithm (BK). Our computational results on real life protein
alignment instances show that our branch and bound algorithm is up to 116 times
faster than BK for the largest proteins.

CoPreTHi is a Java based web application, which combines the results of
methods that predict the location of transmembrane segments in protein
sequences into a joint prediction histogram. Clearly, the joint prediction
algorithm, produces superior quality results than individual prediction
schemes. The program is available at http://o2.db.uoa.gr/CoPreTHi

We present a novel method that predicts transmembrane domains in proteins
using solely information contained in the sequence itself. The PRED-TMR
algorithm described, refines a standard hydrophobicity analysis with a
detection of potential termini ('edges', starts and ends) of transmembrane
regions. This allows one both to discard highly hydrophobic regions not
delimited by clear start and end configurations and to confirm putative
transmembrane segments not distinguishable by their hydrophobic composition.
The accuracy obtained on a test set of 101 non-homologous transmembrane
proteins with reliable topologies compares well with that of other popular
existing methods. Only a slight decrease in prediction accuracy was observed
when the algorithm was applied to all transmembrane proteins of the SwissProt
database (release 35). A WWW server running the PRED-TMR algorithm is available
at http://o2.db.uoa. gr/PRED-TMR/

Summary : FT is a tool written in C++, which implements the Fourier analysis
method to locate periodicities in aminoacid or DNA sequences. It is provided
for free public use on a WWW server with a Java interface. Availability : The
server address is http://o2.db.uoa.gr/FT Contact : shamodr@atlas.uoa.gr

A cascading system of hierarchical, artificial neural networks (named
PRED-CLASS) is presented for the generalized classification of proteins into
four distinct classes-transmembrane, fibrous, globular, and mixed-from
information solely encoded in their amino acid sequences. The architecture of
the individual component networks is kept very simple, reducing the number of
free parameters (network synaptic weights) for faster training, improved
generalization, and the avoidance of data overfitting. Capturing information
from as few as 50 protein sequences spread among the four target classes (6
transmembrane, 10 fibrous, 13 globular, and 17 mixed), PRED-CLASS was able to
obtain 371 correct predictions out of a set of 387 proteins (success rate
approximately 96%) unambiguously assigned into one of the target classes. The
application of PRED-CLASS to several test sets and complete proteomes of
several organisms demonstrates that such a method could serve as a valuable
tool in the annotation of genomic open reading frames with no functional
assignment or as a preliminary step in fold recognition and ab initio structure
prediction methods. Detailed results obtained for various data sets and
completed genomes, along with a web sever running the PRED-CLASS algorithm, can
be accessed over the World Wide Web at http://o2.biol.uoa.gr/PRED-CLASS

Current research in biology heavily depends on the availability and efficient
use of information. In order to build new knowledge, various sources of
biological data must often be combined. Semantic Web technologies, which
provide a common framework allowing data to be shared and reused between
applications, can be applied to the management of disseminated biological data.
However, due to some specificities of biological data, the application of these
technologies to life science constitutes a real challenge. Through a use case
of biological data integration, we show in this paper that current Semantic Web
technologies start to become mature and can be applied for the development of
large applications. However, in order to get the best from these technologies,
improvements are needed both at the level of tool performance and knowledge
modeling.

This work presents a simple artificial neural network which classifies
proteins into two classes from their sequences alone: the membrane protein
class and the non-membrane protein class. This may be important in the
functional assignment and analysis of open reading frames (ORF's) identified in
complete genomes and, especially, those ORF's that correspond to proteins with
unknown function. The network described here has a simple hierarchical
feed-forward topology and a limited number of neurons which makes it very fast.
By using only information contained in 11 protein sequences, the method was
able to identify, with 100% accuracy, all membrane proteins with reliable
topologies collected from several papers in the literature. Applied to a test
set of 995 globular, water-soluble proteins, the neural network classified
falsely 23 of them in the membrane protein class (97.7% of correct assignment).
The method was also applied to the complete SWISS-PROT database with
considerable success and on ORF's of several complete genomes. The neural
network developed was associated with the PRED-TMR algorithm (Pasquier,C.,
Promponas,V.J., Palaios,G.A., Hamodrakas,J.S. and Hamodrakas,S.J., 1999) in a
new application package called PRED-TMR2. A WWW server running the PRED-TMR2
software is available at http://o2.db.uoa.gr/PRED-TMR2

We propose two ways of estimating the current source density (CSD) from
measurements of voltage on a Cartesian grid with missing recording points using
the inverse CSD method. The simplest approach is to substitute local averages
(LA) in place of missing data. A more elaborate alternative is to estimate a
smaller number of CSD parameters than the actual number of recordings and to
take the least-squares fit (LS). We compare the two approaches in the three
dimensional case on several sets of surrogate and experimental data, for
varying numbers of missing data points, and discuss their advantages and
drawbacks. One can construct CSD distributions for which one or the other
approach is better. However, in general, LA method is to be recommended being
more stable and more robust to variations in the recorded fields.

Graphical analysis methods are widely used in positron emission tomography
quantification because of their simplicity and model independence. But they
may, particularly for reversible kinetics, lead to bias in the estimated
parameters. The source of the bias is commonly attributed to noise in the data.
Assuming a two-tissue compartmental model, we investigate the bias that
originates from model error. This bias is an intrinsic property of the
simplified linear models used for limited scan durations, and it is exaggerated
by random noise and numerical quadrature error. Conditions are derived under
which Logan's graphical method either over- or under-estimates the distribution
volume in the noise-free case. The bias caused by model error is quantified
analytically. The presented analysis shows that the bias of graphical methods
is inversely proportional to the dissociation rate. Furthermore, visual
examination of the linearity of the Logan plot is not sufficient for
guaranteeing that equilibrium has been reached. A new model which retains the
elegant properties of graphical analysis methods is presented, along with a
numerical algorithm for its solution. We perform simulations with the fibrillar
amyloid-beta radioligand [11C] benzothiazole-aniline using published data from
the University of Pittsburgh and Rotterdam groups. The results show that the
proposed method significantly reduces the bias due to model error. Moreover,
the results for data acquired over a 70 minutes scan duration are at least as
good as those obtained using existing methods for data acquired over a 90
minutes scan duration.

Logan's graphical analysis (LGA) is a widely-used approach for quantification
of biochemical and physiological processes from Positron emission tomography
(PET) image data. A well-noted problem associated with the LGA method is the
bias in the estimated parameters. We recently systematically evaluated the bias
associated with the linear model approximation and developed an alternative to
minimize the bias due to model error. In this study, we examined the noise
structure in the equations defining linear quantification methods, including
LGA. The noise structure conflicts with the conditions given by the
Gauss-Markov theorem for the least squares (LS) solution to generate the best
linear unbiased estimator. By carefully taking care of the data error
structure, we propose to use structured total least squares (STLS) to obtain
the solution using a one-dimensional optimization problem. Simulations of PET
data for [11C] benzothiazole-aniline (Pittsburgh Compound-B [PIB]) show that
the proposed method significantly reduces the bias. We conclude that the bias
associated with noise is primarily due to the unusual structure of he
correlated noise and it can be reduced with the proposed STLS method.

Parametric imaging of the cerebral metabolic rate for glucose (CMRGlc) using
[18F]-fluorodeoxyglucose positron emission tomography is considered.
Traditional imaging is hindered due to low signal to noise ratios at individual
voxels. We propose to minimize the total variation of the tracer uptake rates
while requiring good fit of traditional Patlak equations. This minimization
guarantees spatial homogeneity within brain regions and good distinction
between brain regions. Brain phantom simulations demonstrate significant
improvement in quality of images by the proposed method as compared to Patlak
images with post-filtering using Gaussian or median filters.

Knowing which mode of combinatorial regulation (typically, AND or OR logic
operation) that a gene employs is important for determining its function in
regulatory networks. Here, we introduce a dynamic cross-correlation function
between the output of a gene and its upstream regulator concentrations for
signatures of combinatorial regulation in gene expression noise. We find that
the correlation function is always upwards convex for the AND operation whereas
downwards convex for the OR operation, whichever sources of noise (intrinsic or
extrinsic or both). In turn, this fact implies a means for inferring regulatory
synergies from available experimental data. The extensions and applications are
discussed.

The social networks that infectious diseases spread along are typically
clustered. Because of the close relation between percolation and epidemic
spread, the behavior of percolation in such networks gives insight into
infectious disease dynamics. A number of authors have studied clustered
networks, but the networks often contain preferential mixing between high
degree nodes. We introduce a class of random clustered networks and another
class of random unclustered networks with the same preferential mixing. We
analytically show that percolation in the clustered networks reduces the
component sizes and increases the epidemic threshold compared to the
unclustered networks.

Experimental data regarding auxin and venation formation exist at both
macroscopic and molecular scales, and we attempt to unify them into a
comprehensive model for venation formation. We begin with a set of principles
to guide an abstract model of venation formation, from which we show how
patterns in plant development are related to the representation of global
distance information locally as cellular-level signals. Venation formation, in
particular, is a function of distances between cells and their locations. The
first principle, that auxin is produced at a constant rate in all cells, leads
to a (Poisson) reaction-diffusion equation. Equilibrium solutions uniquely
codify information about distances, thereby providing cells with the signal to
begin differentiation from ground to vascular. A uniform destruction hypothesis
and scaling by cell size leads to a more biologically-relevant (Helmholtz)
model, and simulations demonstrate its capability to predict leaf and root
auxin distributions and venation patterns. The mathematical development is
centered on properties of the distance map, and provides a mechanism by which
global information about shape can be presented locally to individual cells.
The principles provide the foundation for an elaboration of these models in a
companion paper \cite{plos-paper2}, and together they provide a framework for
understanding organ- and plant-scale organization.

To support and guide an extensive experimental research into systems biology
of signaling pathways, increasingly more mechanistic models are being developed
with hopes of gaining further insight into biological processes. In order to
analyse these models, computational and statistical techniques are needed to
estimate the unknown kinetic parameters. This chapter reviews methods from
frequentist and Bayesian statistics for estimation of parameters and for
choosing which model is best for modeling the underlying system. Approximate
Bayesian Computation (ABC) techniques are introduced and employed to explore
different hypothesis about the JAK-STAT signaling pathway.

The principles underlying plant development are extended to allow a more
molecular mechanism to elaborate the schema by which ground cells differentiate
into vascular cells. Biophysical considerations dictate that linear dynamics
are not sufficent to capture facilitated auxin transport (e.g., through PIN).
We group these transport facilitators into a non-linear model under the
assumption that they attempt to minimize certain {\em differences} of auxin
concentration. This Constant Gradient Hypothesis greatly increases the
descriptive power of our model to include complex dynamical behaviour.
Specifically, we show how the early pattern of PIN1 expression appears in the
embryo, how the leaf primordium emerges, how convergence points arise on the
leaf margin, how the first loop is formed, and how the intricate pattern of PIN
shifts during the early establishment of vein patterns in incipient leaves of
Arabidopsis. Given our results, we submit that the model provides evidence that
many of the salient structural characteristics that have been described at
various stages of plant development can arise from the uniform application of a
small number of abstract principles.

We introduce an alternative formulation of the exact stochastic simulation
algorithm (SSA) for sampling trajectories of the chemical master equation for a
well-stirred system of coupled chemical reactions. Our formulation is based on
factored-out, partial reaction propensities. This novel exact SSA, called the
partial propensity direct method (PDM), is highly efficient and has a
computational cost that scales at most linearly with the number of chemical
species, irrespective of the degree of coupling of the reaction network. In
addition, we propose a sorting variant, SPDM, which is especially efficient for
multiscale reaction networks.

New technologies and equipment allow for mass treatment of samples and
research teams share acquired data on an always larger scale. In this context
scientists are facing a major data exploitation problem. More precisely, using
these data sets through data mining tools or introducing them in a classical
experimental approach require a preliminary understanding of the information
space, in order to direct the process. But acquiring this grasp on the data is
a complex activity, which is seldom supported by current software tools. The
goal of this paper is to introduce a solution to this scientific data grasp
problem. Illustrated in the Tissue MicroArrays application domain, the proposal
is based on the synthesis notion, which is inspired by Information Retrieval
paradigms. The envisioned synthesis model gives a central role to the study the
researcher wants to conduct, through the task notion. It allows for the
implementation of a task-oriented Information Retrieval prototype system. Cases
studies and user studies were used to validate this prototype system. It opens
interesting prospects for the extension of the model or extensions towards
other application domains.

Fluorescent and luminescent gene reporters allow us to dynamically quantify
changes in molecular species concentration over time on the single cell level.
The mathematical modeling of their interaction through multivariate dynamical
models requires the development of effective statistical methods to calibrate
such models against available data. Given the prevalence of stochasticity and
noise in biochemical systems inference for stochastic models is of special
interest. In this paper we present a simple and computationally efficient
algorithm for the estimation of biochemical kinetic parameters from gene
reporter data. We use the linear noise approximation to model biochemical
reactions through a stochastic dynamic model which essentially approximates a
diffusion model by an ordinary differential equation model with an
appropriately defined noise process. An explicit formula for the likelihood
function can be derived allowing for computationally efficient parameter
estimation. The proposed algorithm is embedded in a Bayesian framework and
inference is performed using Markov chain Monte Carlo. The major advantage of
the method is that in contrast to the more established diffusion approximation
based methods the computationally costly methods of data augmentation are not
necessary. Our approach also allows for unobserved variables and measurement
error. The application of the method to both simulated and experimental data
shows that the proposed methodology provides a useful alternative to diffusion
approximation based methods.

We study the correlation of the occurrence of coronary heart disease (CHD)
with the presence of the single-nucleotide polymorphism (SNP) at the -308
position of the tumor necrosis factor alpha (TNF-$\alpha$) gene. We also
consider the influence of the occurrence of type 2 diabetes (t2DM). Using
Bayesian inference, we first pursue a bottom-up approach to compute the working
hypothesis and the probabilities derivable from the data. We then pursue a
top-down approach by modelling the signal pathway that causally connects the
SNP with the emergence of CHD. We compute the functional form of the
probability of CHD conditional on the presence of the SNP in terms of both the
statistical and biochemical properties of the system. From the probability of
occurrence of a disease conditional on a given risk factor, we explore the
possibility of extracting information on the pathways involved in the
occurrence of the disease. This is a first study that we want to systematise
into a comprehensive formalism to be applied to the inference of the mechanism
connecting the risk factors to the disease.

The animals, in particular insects (Drosophila melanogaster), response
towards odor stimuli in nature can be established by measuring the dynamic of
the odor response. Such an approach is innovative since responses to odors were
tested only at certain time point so far, not in hour intervals for several
hours. The odor attraction to 14 natural and ecologically relevant odor stimuli
such as fruits- ripe and rotten, yeast and vinegar was tested. A mathematical
model to evaluate obtained data is proposed in this study in which the number
of flies caught over several time points is presented as one simple parameter
showing trapping potential of the trap housing particular odor stimuli. The
knowledge concerning dynamic of the odor response in Drosophila melanogaster
may enlighten the principles of flies behavior in context of exposure towards
odor stimulus.

A real-time recording setup combining exhaled breath VOC measurements by
proton transfer reaction mass spectrometry (PTR-MS) with hemodynamic and
respiratory data is presented. Continuous automatic sampling of exhaled breath
is implemented on the basis of measured respiratory flow: a flow-controlled
shutter mechanism guarantees that only end-tidal exhalation segments are drawn
into the mass spectrometer for analysis.
  Exhaled breath concentration profiles of two prototypic compounds, isoprene
and acetone, during several exercise regimes were acquired, reaffirming and
complementing earlier experimental findings regarding the dynamic response of
these compounds reported by Senthilmohan et al. [1] and Karl et al. [2]. While
isoprene tends to react very sensitively to changes in pulmonary ventilation
and perfusion due to its lipophilic behavior and low Henry constant,
hydrophilic acetone shows a rather stable behavior. Characteristic (median)
values for breath isoprene concentration and molar flow, i.e., the amount of
isoprene exhaled per minute are 100 ppb and 29 nmol/min, respectively, with
some intra-individual day-to-day variation. At the onset of exercise breath
isoprene concentration increases drastically, usually by a factor of ~3-4
within about one minute. Due to a simultaneous increase in ventilation, the
associated rise in molar flow is even more pronounced, leading to a ratio
between peak molar flow and molar flow at rest of ~11.
  Our setup holds great potential in capturing continuous dynamics of
non-polar, low-soluble VOCs over a wide measurement range with simultaneous
appraisal of decisive physiological factors affecting exhalation kinetics.

The purpose of this Note is twofold: First, we introduce the general
formalism of evolutionary genetics dynamics involving fitnesses, under both the
deterministic and stochastic setups, and chiefly in discrete-time. In the
process, we particularize it to a one-parameter model where only a selection
parameter is unknown. Then and in a parallel manner, we discuss the estimation
problems of the selection parameter based on a single-generation frequency
distribution shift under both deterministic and stochastic evolutionary
dynamics. In the stochastics, we consider both the celebrated Wright-Fisher and
Moran models.

Calibration of the self-thinning frontier in even-aged monocultures is
hampered by scarce data and by subjective decisions about the proximity of data
to the frontier. We present a simple model that applies to observations of the
full trajectory of stand mean diameter across a range of densities not close to
the frontier. Development of the model is based on a consideration of the slope
s=ln(Nt/Nt 1)/ln(Dt/Dt 1) of a log-transformed plot of stocking Nt and mean
stem diameter Dt at time t. This avoids the need for subjective decisions about
limiting density and allows the use of abundant data further from the
self-thinning frontier. The model can be solved analytically and yields
equations for the stocking and the stand basal area as an explicit function of
stem diameter. It predicts that self-thinning may be regulated by the maximum
basal area with a slope of -2. The significance of other predictor variables
offers an effective test of competing self-thinning theories such Yoda's -3/2
power rule and Reineke's stand density index.

Array-Based Comparative Genomic Hybridization (aCGH) is a method used to
search for genomic regions with copy numbers variations. For a given aCGH
profile, one challenge is to accurately segment it into regions of constant
copy number. Subjects sharing the same disease status, for example a type of
cancer, often have aCGH profiles with similar copy number variations, due to
duplications and deletions relevant to that particular disease. We introduce a
constrained optimization algorithm that jointly segments aCGH profiles of many
subjects. It simultaneously penalizes the amount of freedom the set of profiles
have to jump from one level of constant copy number to another, at genomic
locations known as breakpoints. We show that breakpoints shared by many
different profiles tend to be found first by the algorithm, even in the
presence of significant amounts of noise. The algorithm can be formulated as a
group LARS problem. We propose an extremely fast way to find the solution path,
i.e., a sequence of shared breakpoints in order of importance. For no extra
cost the algorithm smoothes all of the aCGH profiles into piecewise-constant
regions of equal copy number, giving low-dimensional versions of the original
data. These can be shown for all profiles on a single graph, allowing for
intuitive visual interpretation. Simulations and an implementation of the
algorithm on bladder cancer aCGH profiles are provided.

Gene regulatory circuits show significant stochastic fluctuations in their
circuit signals due to the low copy number of transcription factors. When a
gene circuit component is connected to an existing circuit, the dynamic
properties of the existing circuit can be affected by the connected component.
In this paper, we investigate modularity in the dynamics of the gene circuit
based on stochastic fluctuations in the circuit signals. We show that the noise
in the output signal of the existing circuit can be affected significantly when
the output is connected to the input of another circuit component. More
specifically, the output signal noise can show significantly longer
correlations when the two components are connected. This equivalently means
that the noise power spectral density becomes narrower. We define the relative
change in the correlation time or the spectrum bandwidth by stochastic
retroactivity, which is shown to be directly related to the retroactivity
defined in the deterministic framework by del Vecchio et al. This provides an
insight on how to measure retroactivity, by investigating stochastic
fluctuations in gene expression levels, more specifically, by obtaining an
autocorrelation function of the fluctuations. We also provide an interesting
aspect of the frequency response of the circuit. We show that depending on the
magnitude of operating frequencies, different kinds of signals need to be
preferably chosen for circuit description in a modular fashion: at low enough
frequency, expression level of transcription factor that are not bound to their
specific promoter region needs to be chosen, and at high enough frequency, that
of the total transcription factor, both bound and unbound, does.

We define new profiles based on hydropathy properties and point out specific
profiles for regions surrounding splice sites. We built a set T of flanking
regions of genes with 1-3 introns from 21st and 22nd chromosomes. These genes
contained 313 introns and 385 exons and were extracted from GenBank. They were
used in order to define hydropathy profiles. Most human introns, around 99.66%,
are likely to be U2- type introns. They have highly degenerate sequence motifs
and many different sequences can function as U2-type splice sites. Our new
profiles allow to identify regions which have conservative biochemical features
that are essential for recognition by spliceosome. We have also found
differences between hydropathy profiles for U2 or U12-types of introns on sets
of spice sites extracted from SpliceRack database in order to distinguish GT?AG
introns belonging to U2 and U12-types. Indeed, intron type cannot be simply
determined by the dinucleotide termini. We show that there is a similarity of
hydropathy profiles inside intron types. On the one hand, GT?AG and GC?AG
introns belonging to U2-type have resembling hydropathy profiles as well as
AT?AC and GT?AG introns belonging to U12-type. On the other hand, hydropathy
profiles of U2 and U12-types GT?AG introns are completely different. Finally,
we define and compute a pvalue; we compare our profiles with the profiles
provided by a classical method, Pictogram.

One important preprocessing step in the analysis of microarray data is
background subtraction. In high-density oligonucleotide arrays this is
recognized as a crucial step for the global performance of the data analysis
from raw intensities to expression values.
  We propose here an algorithm for background estimation based on a model in
which the cost function is quadratic in a set of fitting parameters such that
minimization can be performed through linear algebra. The model incorporates
two effects: 1) Correlated intensities between neighboring features in the chip
and 2) sequence-dependent affinities for non-specific hybridization fitted by
an extended nearest-neighbor model.
  The algorithm has been tested on 360 GeneChips from publicly available data
of recent expression experiments. The algorithm is fast and accurate. Strong
correlations between the fitted values for different experiments as well as
between the free-energy parameters and their counterparts in aqueous solution
indicate that the model captures a significant part of the underlying physical
chemistry.

We present an approach to computing spatial information based on Fourier
coefficient distributions. The Fourier transform (FT) of an image contains a
complete description of the image, and the values of the FT coefficients are
uniquely associated with that image. For an image where the distribution of
pixels is uncorrelated, the FT coefficients are normally distributed and
uncorrelated. Further, the probability distribution for the FT coefficients of
such an image can readily be obtained by Parseval's theorem. We take advantage
of these properties to compute the spatial information in an image by
determining the probability of each coefficient (both real and imaginary parts)
in the FT, then using the Shannon formalism to calculate information. By using
the probability distribution obtained from Parseval's theorem, an effective
distance from the completely uncorrelated or most uncertain case is obtained.
The resulting quantity is an information computed in k-space (kSI). This
approach provides a robust, facile and highly flexible framework for
quantifying spatial information in images and other types of data (of arbitrary
dimensions). The kSI metric is tested on a 2D Ising ferromagnet, and the
temperature-dependent phase transition is accurately determined from the
spatial information in configurations of the system.

In this work, we introduce the novel technique of in-chip drop on demand,
which consists in dispensing picoliter to nanoliter drops on demand directly in
the liquid-filled channels of a polymer microfluidic chip, at frequencies up to
2.5 kHz and with precise volume control. The technique involves a PDMS chip
with one or several microliter-size chambers driven by piezoelectric actuators.
Individual aqueous microdrops are dispensed from the chamber to a main
transport channel filled with an immiscible fluid, in a process analogous to
atmospheric drop on demand dispensing. In this article, the drop formation
process is characterized with respect to critical dispense parameters such as
the shape and duration of the driving pulse, and the size of both the fluid
chamber and the nozzle. Several features of the in-chip drop on demand
technique with direct relevance to lab on a chip applications are presented and
discussed, such as the precise control of the dispensed volume, the ability to
merge drops of different reagents and the ability to move a drop from the
shooting area of one nozzle to another for multi-step reactions. The
possibility to drive the microfluidic chip with inexpensive audio electronics
instead of research-grade equipment is also examined and verified. Finally, we
show that the same piezoelectric technique can be used to generate a single gas
bubble on demand in a microfluidic chip.

Risk stratification is most directly and informatively summarized as a risk
distribution curve. From this curve the ROC curve, predictiveness curve, and
other curves depicting risk stratification can be derived, demonstrating that
they present similar information. A mathematical expression for the ROC curve
AUC is derived which clarifies how this measure of discrimination quantifies
the overlap between patients who have and don't have events. This expression is
used to define the positive correlation between the dispersion of the risk
distribution curve and the ROC curve AUC. As more disperse risk distributions
and greater separation between patients with and without events characterize
superior risk stratification, the ROC curve AUC provides useful information.

High-throughput data analyses are becoming common in biology, communications,
economics and sociology. The vast amounts of data are usually represented in
the form of matrices and can be considered as knowledge networks. Spectra-based
approaches have proved useful in extracting hidden information within such
networks and for estimating missing data, but these methods are based
essentially on linear assumptions. The physical models of matching, when
applicable, often suggest non-linear mechanisms, that may sometimes be
identified as noise. The use of non-linear models in data analysis, however,
may require the introduction of many parameters, which lowers the statistical
weight of the model. According to the quality of data, a simpler linear
analysis may be more convenient than more complex approaches.
  In this paper, we show how a simple non-parametric Bayesian model may be used
to explore the role of non-linearities and noise in synthetic and experimental
data sets.

Multivariate methods that relate outcomes to risk factors have been adopted
clinically to individualize treatment. This has promoted the belief that
individuals have a true or unique risk.
  The logic of assigning an individual a single risk value has been criticized
since 1866. The reason is that any individual can be simultaneously considered
a member of different groups, with each group having its own risk level (the
reference class problem).
  Lemeshow et al. provided well-documented examples of remarkable discordance
between predictions for an individual by different valid predictive methods
utilizing different risk factors. The prevalence of such discordance is unknown
as it is rarely evaluated, but must be substantial due to the abundance of risk
factors.
  Lemeshow et al. cautioned against using ICU mortality predictions for the
provision of care to individual patients. If individual risk estimates are used
clinically, users should be aware that valid methods may give very different
results.

Frameshift mutations in protein-coding DNA sequences produce a drastic change
in the resulting protein sequence, which prevents classic protein alignment
methods from revealing the proteins' common origin. Moreover, when a large
number of substitutions are additionally involved in the divergence, the
homology detection becomes difficult even at the DNA level. To cope with this
situation, we propose a novel method to infer distant homology relations of two
proteins, that accounts for frameshift and point mutations that may have
affected the coding sequences. We design a dynamic programming alignment
algorithm over memory-efficient graph representations of the complete set of
putative DNA sequences of each protein, with the goal of determining the two
putative DNA sequences which have the best scoring alignment under a powerful
scoring system designed to reflect the most probable evolutionary process. This
allows us to uncover evolutionary information that is not captured by
traditional alignment methods, which is confirmed by biologically significant
examples.

We combine stroboscopic laser excitation with stochastic photoactivation and
super-resolution fluorescence imaging. This makes it possible to record
hundreds of diffusion trajectories of small protein molecules in single
bacterial cells with millisecond time resolution and sub-diffraction limited
spatial precision. We conclude that the small protein mEos2 exhibits normal
diffusion in the bacterial cytoplasm with a diffusion coefficient of 13.1 -+
1.2 \mu m^2 s^(-1). This investigation lays the groundwork for studying
single-molecule binding and dissociation events for a wide range of
intracellular processes.

We describe the fundamental difference between the nature of problems in
traditional physics and that of many problems arising today in systems biology
and other complex settings. The difference hinges on the much larger number of
a priori plausible alternative laws for explaining the phenomena at hand in the
latter case. An approach and a mathematical framework for prediction in this
hypothesis-rich regime are introduced.

Recommended standardized procedures for determining exhaled lower respiratory
nitric oxide and nasal nitric oxide have been developed by task forces of the
European Respiratory Society and the American Thoracic Society. These
recommendations have paved the way for the measurement of nitric oxide to
become a diagnostic tool for specific clinical applications. It would be
desirable to develop similar guidelines for the sampling of other trace gases
in exhaled breath, especially volatile organic compounds (VOCs) which reflect
ongoing metabolism. The concentrations of water-soluble, blood-borne substances
in exhaled breath are influenced by: (i) breathing patterns affecting gas
exchange in the conducting airways; (ii) the concentrations in the
tracheo-bronchial lining fluid; (iii) the alveolar and systemic concentrations
of the compound. The classical Farhi equation takes only the alveolar
concentrations into account. Real-time measurements of acetone in end-tidal
breath under an ergometer challenge show characteristics which cannot be
explained within the Farhi setting. Here we develop a compartment model that
reliably captures these profiles and is capable of relating breath to the
systemic concentrations of acetone. By comparison with experimental data it is
inferred that the major part of variability in breath acetone concentrations
(e.g., in response to moderate exercise or altered breathing patterns) can be
attributed to airway gas exchange, with minimal changes of the underlying blood
and tissue concentrations. Moreover, it is deduced that measured end-tidal
breath concentrations of acetone determined during resting conditions and free
breathing will be rather poor indicators for endogenous levels. Particularly,
the current formulation includes the classical Farhi and the Scheid series
inhomogeneity model as special limiting cases.

In multicellular organisms, patterns of gene expression are established in
response to gradients of signaling molecules. During fly development in early
Drosophila embryos, the Bicoid (Bcd) morphogen gradient is established within
the first hour after fertilization. Bcd acts as a transcription factor,
initiating the expression of a cascade of genes that determine the segmentation
pattern of the embryo, which serves as a blueprint for the future adult
organism. A robust understanding of the mechanisms that govern this
segmentation cascade is still lacking, and a new generation of quantitative
measurements of the spatio-temporal concentration dynamics of the individual
players of this cascade are necessary for further progress. Here we describe a
series of methods that are meant to represent a start of such a quantification
using Bcd as an example. We describe the generation of a transgenic fly line
expressing a Bcd-eGFP fusion protein, and we use this line to carefully analyze
the Bcd concentration dynamics and to measure absolute Bcd expression levels in
living fly embryos using two-photon microscopy. These experiments have proven
to be a fruitful tool generating new insights into the mechanisms that lead to
the establishment and the readout of the Bcd gradient. Generalization of these
methods to other genes in the Drosophila segmentation cascade is
straightforward and should further our understanding of the early patterning
processes and the architecture of the underlying genetic network structure.

Term enrichment analysis facilitates biological interpretation by assigning
to experimentally/computationally obtained data annotation associated with
terms from controlled vocabularies. This process usually involves obtaining
statistical significance for each vocabulary term and using the most
significant terms to describe a given set of biological entities, often
associated with weights. Many existing enrichment methods require selections of
(arbitrary number of) the most significant entities and/or do not account for
weights of entities. Others either mandate extensive simulations to obtain
statistics or assume normal weight distribution. In addition, most methods have
difficulty assigning correct statistical significance to terms with few
entities. Implementing the well-known Lugananni-Rice formula, we have developed
a novel approach, called SaddleSum, that is free from all the aforementioned
constraints and evaluated it against several existing methods. With entity
weights properly taken into account, SaddleSum is internally consistent and
stable with respect to the choice of number of most significant entities
selected. Making few assumptions on the input data, the proposed method is
universal and can thus be applied to areas beyond analysis of microarrays.
Employing asymptotic approximation, SaddleSum provides a term-size dependent
score distribution function that gives rise to accurate statistical
significance even for terms with few entities. As a consequence, SaddleSum
enables researchers to place confidence in its significance assignments to
small terms that are often biologically most specific.

Investigating the relation between the structure and behavior of complex
biological networks often involves posing the following two questions: Is a
hypothesized structure of a regulatory network consistent with the observed
behavior? And can a proposed structure generate a desired behavior? Answering
these questions presupposes that we are able to test the compatibility of
network structure and behavior. We cast these questions into a parameter search
problem for qualitative models of regulatory networks, in particular
piecewise-affine differential equation models. We develop a method based on
symbolic model checking that avoids enumerating all possible parametrizations,
and show that this method performs well on real biological problems, using the
IRMA synthetic network and benchmark experimental data sets. We test the
consistency between the IRMA network structure and the time-series data, and
search for parameter modifications that would improve the robustness of the
external control of the system behavior.

Simulated evolution of biological networks can be used to generate functional
networks as well as investigate hypotheses regarding natural evolution. A
handful of studies have shown how simulated evolution can be used for studying
the functional space spanned by biochemical networks, studying natural
evolution, or designing new synthetic networks. If there was a method for
easily performing such studies, it can allow the community to further
experiment with simulated evolution and explore all of its uses. As a result,
we have developed a library written in the C language that performs all the
basic functions needed to carry out simulated evolution of biological networks.
The library comes with a generic genetic algorithm as well as genetic
algorithms for specifically evolving genetic networks, protein networks, or
mass-action networks. The library also comes with functions for simulating
these networks. A user needs to specify a desired function. A GUI is provided
for users to become oriented with all the options available in the library. The
library is free and open source under the BSD lisence and can be obtained at
evolvenetworks.sourceforge.net. It can be built on all major platforms. The
code can be most conveniently compiled using cross-platform make (CMake).

We introduce the software tool NTRFinder to find the complex repetitive
structure in DNA we call a nested tandem repeat (NTR). An NTR is a recurrence
of two or more distinct tandem motifs interspersed with each other. We propose
that nested tandem repeats can be used as phylogenetic and population markers.
We have tested our algorithm on both real and simulated data, and present some
real nested tandem repeats of interest. We discuss how the NTR found in the
ribosomal DNA of taro (Colocasia esculenta) may assist in determining the
cultivation prehistory of this ancient staple food crop. NTRFinder can be
downloaded from http://www.maths.otago.ac.nz/? aamatroud/.

Although computationally aligning sequence is a crucial step in the vast
majority of comparative genomics studies our understanding of alignment biases
still needs to be improved. To infer true structural or homologous regions
computational alignments need further evaluation. It has been shown that the
accuracy of aligned positions can drop substantially in particular around gaps.
Here we focus on re-evaluation of score-based alignments with affine gap
penalty costs. We exploit their relationships with pair hidden Markov models
and develop efficient algorithms by which to identify gaps which are
significant in terms of length and multiplicity. We evaluate our statistics
with respect to the well-established structural alignments from SABmark and
find that indel reliability substantially increases with their significance in
particular in worst-case twilight zone alignments. This points out that our
statistics can reliably complement other methods which mostly focus on the
reliability of match positions.

We consider here the problem of chaining seeds in ordered trees. Seeds are
mappings between two trees Q and T and a chain is a subset of non overlapping
seeds that is consistent with respect to postfix order and ancestrality. This
problem is a natural extension of a similar problem for sequences, and has
applications in computational biology, such as mining a database of RNA
secondary structures. For the chaining problem with a set of m constant size
seeds, we describe an algorithm with complexity O(m2 log(m)) in time and O(m2)
in space.

We consider the optimal strategy for laboratory testing of biological samples
when we wish to know the results for each sample rather than the average
prevalence of positive samples. If the proportion of positive samples is low
considerable resources may be devoted to testing samples most of which are
negative. An attractive strategy is to pool samples. If the pooled samples test
positive one must then test the individual samples, otherwise they can all be
assumed to be negative. The pool should be big enough to reduce the number of
tests but not so big that the pooled samples are almost all positive. We show
that if the prevalence of positive samples is greater than 30% it is never
worth pooling. From 30% down to 1% pools of size 4 are close to optimal. Below
1% substantial gains can be made by pooling, especially if the samples are
pooled twice. However, with large pools the sensitivity of the test will fall
correspondingly and this must be taken into consideration. We derive simple
expressions for the optimal pool size and for the corresponding proportion of
samples tested.

We consider novel phylogenetic models with rate matrices that arise via the
embedding of a progenitor model on a small number of character states, into a
target model on a larger number of character states. Adapting
representation-theoretic results from recent investigations of Markov
invariants for the general rate matrix model, we give a prescription for
identifying and counting Markov invariants for such `symmetric embedded'
models, and we provide enumerations of these for low-dimensional cases. The
simplest example is a target model on 3 states, constructed from a general 2
state model; the `2->3' embedding. We show that for 2 taxa, there exist two
invariants of quadratic degree, that can be used to directly infer pairwise
distances from observed sequences under this model. A simple simulation study
verifies their theoretical expected values, and suggests that, given the
appropriateness of the model class, they have greater statistical power than
the standard (log) Det invariant (which is of cubic degree for this case).

Yeast glycolysis is considered the prototype of dissipative biochemical
oscillators. In cellular conditions, under sinusoidal source of glucose, the
activity of glycolytic enzymes can display either periodic, quasiperiodic or
chaotic behavior.
  In order to quantify the functional connectivity for the glycolytic enzymes
in dissipative conditions we have analyzed different catalytic patterns using
the non-linear statistical tool of Transfer Entropy. The data were obtained by
means of a yeast glycolytic model formed by three delay differential equations
where the enzymatic speed functions of the irreversible stages have been
explicitly considered. These enzymatic activity functions were previously
modeled and tested experimentally by other different groups. In agreement with
experimental conditions, the studied time series corresponded to a
quasi-periodic route to chaos. The results of the analysis are three-fold:
first, in addition to the classical topological structure characterized by the
specific location of enzymes, substrates, products and feedback regulatory
metabolites, an effective functional structure emerges in the modeled
glycolytic system, which is dynamical and characterized by notable variations
of the functional interactions. Second, the dynamical structure exhibits a
metabolic invariant which constrains the functional attributes of the enzymes.
Finally, in accordance with the classical biochemical studies, our numerical
analysis reveals in a quantitative manner that the enzyme phosphofructokinase
is the key-core of the metabolic system, behaving for all conditions as the
main source of the effective causal flows in yeast glycolysis.

The goal of the work is to implement molecular phylogenetic calculations
using the Grid paradigm by means of the MrBayes software using Directed Acyclic
Graphs (DAG) jobs. In this method, a set of jobs depends on the input or the
output of other jobs. Once the runs have been successfully done, all the
results can be collected by a specific Perl script inside the defined DAG job.
For testing this methodology, we calculate the evolution of papillomavirus with
121 sequences.

This document is an introduction to the use of the point-centered quarter
method. It briefly outlines its history, its methodology, and some of the
practical issues (and modifications) that inevitably arise with its use in the
field. Additionally this paper shows how data collected using point-centered
quarter method sampling may be used to determine importance values of different
species of trees and describes and derives several methods of estimating plant
density and corresponding confidence intervals. New to this revision is an
appendix of R functions to carry out these calculations.

We present a new method for inferring hidden Markov models from noisy time
sequences without the necessity of assuming a model architecture, thus allowing
for the detection of degenerate states. This is based on the statistical
prediction techniques developed by Crutchfield et al., and generates so called
causal state models, equivalent to hidden Markov models. This method is
applicable to any continuous data which clusters around discrete values and
exhibits multiple transitions between these values such as tethered particle
motion data or Fluorescence Resonance Energy Transfer (FRET) spectra. The
algorithms developed have been shown to perform well on simulated data,
demonstrating the ability to recover the model used to generate the data under
high noise, sparse data conditions and the ability to infer the existence of
degenerate states. They have also been applied to new experimental FRET data of
Holliday Junction dynamics, extracting the expected two state model and
providing values for the transition rates in good agreement with previous
results and with results obtained using existing maximum likelihood based
methods.

Background: The vast computational resources that became available during the
past decade enabled the development and simulation of increasingly complex
mathematical models of cancer growth. These models typically involve many free
parameters whose determination is a substantial obstacle to model development.
Direct measurement of biochemical parameters in vivo is often difficult and
sometimes impracticable, while fitting them under data-poor conditions may
result in biologically implausible values.
  Results: We discuss different methodological approaches to estimate
parameters in complex biological models. We make use of the high computational
power of the Blue Gene technology to perform an extensive study of the
parameter space in a model of avascular tumor growth. We explicitly show that
the landscape of the cost function used to optimize the model to the data has a
very rugged surface in parameter space. This cost function has many local
minima with unrealistic solutions, including the global minimum corresponding
to the best fit.
  Conclusions: The case studied in this paper shows one example in which model
parameters that optimally fit the data are not necessarily the best ones from a
biological point of view. To avoid force-fitting a model to a dataset, we
propose that the best model parameters should be found by choosing, among
suboptimal parameters, those that match criteria other than the ones used to
fit the model. We also conclude that the model, data and optimization approach
form a new complex system, and point to the need of a theory that addresses
this problem more generally.

In this Chapter, we ask questions (1) What is the right way to measure the
quality of information processing in a biological system? and (2) What can
real-life organisms do in order to improve their performance in
information-processing tasks? We then review the body of work that investigates
these questions experimentally, computationally, and theoretically in
biological domains as diverse as cell biology, population biology, and
computational neuroscience

Conan is a C++ library created for the accurate and efficient modelling,
inference and analysis of complex networks. It implements the generation and
modification of graphs according to several published models, as well as the
unexpensive computation of global and local network properties. Other features
include network inference and community detection. Furthermore, Conan provides
a Python interface to facilitate the use of the library and its integration in
currently existing applications.
  Conan is available at http://github.com/rhz/conan/.

We have shown elsewhere that the presence of mixed-culture growth of
microbial species in fermentation processes can be detected with high accuracy
by employing the wavelet transform. This is achieved because the crosses in the
different growth processes contributing to the total biomass signal appear as
singularities that are very well evidenced through their singularity cones in
the wavelet transform. However, we used very simple two-species cases. In this
work, we extend the wavelet method to a more complicated illustrative
fermentation case of three microbial species for which we employ several
wavelets of different number of vanishing moments in order to eliminate
possible numerical artifacts. Working in this way allows to filter in a more
precise way the numerical values of the H\"older exponents. Therefore, we were
able to determine the characteristic H\"older exponents for the corresponding
crossing singularities of the microbial growth processes and their stability
logarithmic scale ranges up to the first decimal in the value of the
characteristic exponents. Since calibrating the mixed microbial growth by means
of their H\"older exponents could have potential industrial applications, the
dependence of the H\"older exponents on the kinetic and physical parameters of
the growth models remains as a future experimental task

The microscopic green alga Ostreococcus tauri is rapidly emerging as a
promising model organism in the green lineage. In particular, recent results by
Corellou et al. [Plant Cell, 21, 3436 (2009)] and Thommen et al. [PLoS Comput.
Biol. 6, e1000990 (2010)] strongly suggest that its circadian clock is a
simplified version of Arabidopsis thaliana clock, and that it is architectured
so as to be robust to natural daylight fluctuations. In this work, we analyze
time series data from luminescent reporters for the two central clock genes
TOC1 and CCA1 and correlate them with microarray data previously analyzed. Our
mathematical analysis strongly supports both the existence of a simple two-gene
oscillator at the core of Ostreococcus tauri clock and the fact that its
dynamics is not affected by light in normal entrainment conditions, a signature
of its robustness.

This work emphasizes the assets of implementing the distributed computing for
the intensive use in computational science devoted to the search of new
medicines that could be applied in public healthy problems.

There are many instances in genetics in which we wish to determine whether
two candidate populations are distinguishable on the basis of their genetic
structure. Examples include populations which are geographically separated,
case--control studies and quality control (when participants in a study have
been genotyped at different laboratories). This latter application is of
particular importance in the era of large scale genome wide association
studies, when collections of individuals genotyped at different locations are
being merged to provide increased power. The traditional method for detecting
structure within a population is some form of exploratory technique such as
principal components analysis. Such methods, which do not utilise our prior
knowledge of the membership of the candidate populations. are termed
\emph{unsupervised}. Supervised methods, on the other hand are able to utilise
this prior knowledge when it is available.
  In this paper we demonstrate that in such cases modern supervised approaches
are a more appropriate tool for detecting genetic differences between
populations. We apply two such methods, (neural networks and support vector
machines) to the classification of three populations (two from Scotland and one
from Bulgaria). The sensitivity exhibited by both these methods is considerably
higher than that attained by principal components analysis and in fact
comfortably exceeds a recently conjectured theoretical limit on the sensitivity
of unsupervised methods. In particular, our methods can distinguish between the
two Scottish populations, where principal components analysis cannot. We
suggest, on the basis of our results that a supervised learning approach should
be the method of choice when classifying individuals into pre-defined
populations, particularly in quality control for large scale genome wide
association studies.

Nonlinear mixed effects models represent a powerful tool to simultaneously
analyze data from several individuals. In this study a compartmental model of
leucine kinetics is examined and extended with a stochastic differential
equation to model non-steady state concentrations of free leucine in the
plasma. Data obtained from tracer/tracee experiments for a group of healthy
control individuals and a group of individuals suffering from diabetes mellitus
type 2 are analyzed. We find that the interindividual variation of the model
parameters is much smaller for the nonlinear mixed effects models, compared to
traditional estimates obtained from each individual separately. Using the mixed
effects approach, the population parameters are estimated well also when only
half of the data are used for each individual. For a typical individual the
amount of free leucine is predicted to vary with a standard deviation of 8.9%
around a mean value during the experiment. Moreover, leucine degradation and
protein uptake of leucine is smaller, proteolysis larger, and the amount of
free leucine in the body is much larger for the diabetic individuals than the
control individuals. In conclusion nonlinear mixed effects models offers
improved estimates for model parameters in complex models based on
tracer/tracee data and may be a suitable tool to reduce data sampling in
clinical studies.

We report the key findings from numerical solutions of a model of transport
within an established perfusion bioreactor design. The model includes a
complete formulation of transport with fully coupled convection-diffusion and
scaffold cell attachment. It also includes the experimentally determined
internal (Poly-L-Lactic Acid (PLLA)) scaffold boundary, together with the
external vessel and flow-port boundaries. Our findings, obtained using parallel
lattice Boltzmann equation method, relate to (i) whole-device, steady-state
flow and species distribution and (ii) the properties of the scaffold. In
particular the results identify which elements of the problem may be addressed
by coarse grained methods such as the Darcy approximation and those which
require a more complete description. The work demonstrates that appropriate
numerical modelling will make a key contribution to the design and development
of large scale bioreactors.

We propose a novel two-stage Gene Set Gibbs Sampling (GSGS) framework, to
reverse engineer signaling pathways from gene sets inferred from molecular
profiling data. We hypothesize that signaling pathways are structurally an
ensemble of overlapping linear signal transduction events which we encode as
Information Flow Gene Sets (IFGS's). We infer pathways from gene sets
corresponding to these events subjected to a random permutation of genes within
each set. In Stage I, we use a source separation algorithm to derive unordered
and overlapping IFGS's from molecular profiling data, allowing cross talk among
IFGS's. In Stage II, we develop a Gibbs sampling like algorithm, Gene Set Gibbs
Sampler, to reconstruct signaling pathways from the latent IFGS's derived in
Stage I. The novelty of this framework lies in the seamless integration of the
two stages and the hypothesis of IFGS's as the basic building blocks for signal
pathways. In the proof-of-concept studies, our approach is shown to outperform
the existing Bayesian network approaches using both continuous and discrete
data generated from benchmark networks in the DREAM initiative. We perform a
comprehensive sensitivity analysis to assess the robustness of the approach.
Finally, we implement the GSGS framework to reconstruct signaling pathways in
breast cancer cells.

I derive formulas for the electrostatic potential of a charge in or near a
membrane modeled as one or more dielectric slabs lying between two
semi-infinite dielectrics. One can use these formulas in Monte Carlo codes to
compute the distribution of ions near cell membranes more accurately than by
using Poisson-Boltzmann theory or its linearized version. Here I use them to
discuss the electric field of a uniformly charged membrane, the image charges
of an ion, the distribution of salt ions near a charged membrane, the energy of
a zwitterion near a lipid slab, and the effect of including the phosphate head
groups as thin layers of high electric permittivity.

The quasi-steady state assumption (QSSA) forms the basis for rigorous
mathematical justification of the Michaelis-Menten formalism commonly used in
modeling a broad range of intracellular phenomena. A critical supposition of
QSSA-based analyses is that the underlying biochemical reaction is
enzymatically "closed," so that free enzyme is neither added to nor removed
from the reaction over the relevant time period. Yet there are multiple
circumstances in living cells under which this assumption may not hold, e.g.
during translation of genetic elements or metabolic regulatory events. Here we
consider a modified version of the most basic enzyme-catalyzed reaction which
incorporates enzyme input and removal. We extend the QSSA to this enzymatically
"open" system, computing inner approximations to its dynamics, and we compare
the behavior of the full open system, our approximations, and the closed system
under broad range of kinetic parameters. We also derive conditions under which
our new approximations are provably valid; numerical simulations demonstrate
that our approximations remain quite accurate even when these conditions are
not satisfied. Finally, we investigate the possibility of damped oscillatory
behavior in the enzymatically open reaction.

The overwhelming amount of available scholarly literature in the life
sciences poses significant challenges to scientists wishing to keep up with
important developments related to their research, but also provides a useful
resource for the discovery of recent information concerning genes, diseases,
compounds and the interactions between them. In this paper, we describe an
algorithm called Bio-LDA that uses extracted biological terminology to
automatically identify latent topics, and provides a variety of measures to
uncover putative relations among topics and bio-terms. Relationships identified
using those approaches are combined with existing data in life science datasets
to provide additional insight. Three case studies demonstrate the utility of
the Bio-LDA model, including association predication, association search and
connectivity map generation. This combined approach offers new opportunities
for knowledge discovery in many areas of biology including target
identification, lead hopping and drug repurposing.

Synthetic Biology is the new engineering-based approach to biology that
includes applications of designing complex biological devices. At present, it
is not yet clear what will emerge as the defining principles of Synthetic
Biology. One proposed approach is to build Synthetic Biology around the
classical engineering principles of standardization, modularity/decoupling and
abstraction/modeling to facilitate component-based design. In this article we
suggest and discuss an alternative paradigm, which we call High-throughput
Biologically Optimized Search Engineering (HT-BOSE). Stemming from directed
evolution, in HT-BOSE the focal point is a biological knowledge based rational
optimization of the search process in the space of device design possibilities.
The HT-BOSE approach may also be relevant in other contexts and we briefly
highlight how it could be applicable to the development of multi-drug cocktails
in a biomedical setting.

Periodic patterns play the important regulatory and structural roles in
genomic DNA sequences. Commonly, the underlying periodicities should be
understood in a broad statistical sense, since the corresponding periodic
patterns have been strongly distorted by the random point mutations and
insertions/deletions during molecular evolution. The latent periodicities in
DNA sequences can be efficiently displayed by Fourier transform. The criteria
of significance for observed periodicities are obtained via the comparison
versus the counterpart characteristics of the reference random sequences. We
show that the restrictions imposed on the significance criteria by the rigorous
spectral sum rules can be rationally described with De Finetti distribution.
This distribution provides the convenient intermediate asymptotic form between
Rayleigh distribution and exact combinatoric theory.

We examine how the shape of cells and the geometry of experiment affect the
reaction-diffusion kinetics at the binding between target and probe molecules
on molecular biochips. In particular, we compare the binding kinetics for the
probes immobilized on surface of the semispherical and flat circular cells, the
limit of thin slab of analyte solution over probe cell as well as hemispherical
gel pads and cells printed in gel slab over a substrate. It is shown that
hemispherical geometry provides significantly faster binding kinetics and
ensures more spatially homogeneous distribution of local (from a pixel) signals
over a cell in the transient regime. The advantage of using thin slabs with
small volume of analyte solution may be hampered by the much longer binding
kinetics needing the auxiliary mixing devices. Our analysis proves that the
shape of cells and the geometry of experiment should be included to the list of
essential factors at biochip designing.

Protein structural alignment is an important problem in computational
biology. In this paper, we present first successes on provably optimal pairwise
alignment of protein inter-residue distance matrices, using the popular Dali
scoring function. We introduce the structural alignment problem formally, which
enables us to express a variety of scoring functions used in previous work as
special cases in a unified framework. Further, we propose the first
mathematical model for computing optimal structural alignments based on dense
inter-residue distance matrices. We therefore reformulate the problem as a
special graph problem and give a tight integer linear programming model. We
then present algorithm engineering techniques to handle the huge integer linear
programs of real-life distance matrix alignment problems. Applying these
techniques, we can compute provably optimal Dali alignments for the very first
time.

Irregular bone remodeling is associated with a number of bone diseases such
as osteoporosis and multiple myeloma.
  Computational and mathematical modeling can aid in therapy and treatment as
well as understanding fundamental biology. Different approaches to modeling
give insight into different aspects of a phenomena so it is useful to have an
arsenal of various computational and mathematical models.
  Here we develop a mathematical representation of bone remodeling that can
effectively describe many aspects of the complicated geometries and spatial
behavior observed.
  There is a sharp interface between bone and marrow regions. Also the surface
of bone moves in and out, i.e. in the normal direction, due to remodeling.
Based on these observations we employ the use of a level-set function to
represent the spatial behavior of remodeling. We elaborate on a temporal model
for osteoclast and osteoblast population dynamics to determine the change in
bone mass which influences how the interface between bone and marrow changes.
  We exhibit simulations based on our computational model that show the motion
of the interface between bone and marrow as a consequence of bone remodeling.
The simulations show that it is possible to capture spatial behavior of bone
remodeling in complicated geometries as they occur \emph{in vitro} and \emph{in
vivo}.
  By employing the level set approach it is possible to develop computational
and mathematical representations of the spatial behavior of bone remodeling. By
including in this formalism further details, such as more complex cytokine
interactions and accurate parameter values, it is possible to obtain
simulations of phenomena related to bone remodeling with spatial behavior much
as \emph{in vitro} and \emph{in vivo}. This makes it possible to perform
\emph{in silica} experiments more closely resembling experimental observations.

Motivation: Capillary electrophoresis (CE) of nucleic acids is a workhorse
technology underlying high-throughput genome analysis and large-scale chemical
mapping for nucleic acid structural inference. Despite the wide availability of
CE-based instruments, there remain challenges in leveraging their full power
for quantitative analysis of RNA and DNA structure, thermodynamics, and
kinetics. In particular, the slow rate and poor automation of available
analysis tools have bottlenecked a new generation of studies involving hundreds
of CE profiles per experiment.
  Results: We propose a computational method called high-throughput robust
analysis for capillary electrophoresis (HiTRACE) to automate the key tasks in
large-scale nucleic acid CE analysis, including the profile alignment that has
heretofore been a rate-limiting step in the highest throughput experiments. We
illustrate the application of HiTRACE on thirteen data sets representing 4
different RNAs, three chemical modification strategies, and up to 480 single
mutant variants; the largest data sets each include 87,360 bands. By applying a
series of robust dynamic programming algorithms, HiTRACE outperforms prior
tools in terms of alignment and fitting quality, as assessed by measures
including the correlation between quantified band intensities between replicate
data sets. Furthermore, while the smallest of these data sets required 7 to 10
hours of manual intervention using prior approaches, HiTRACE quantitation of
even the largest data sets herein was achieved in 3 to 12 minutes. The HiTRACE
method therefore resolves a critical barrier to the efficient and accurate
analysis of nucleic acid structure in experiments involving tens of thousands
of electrophoretic bands.

Many cellular behaviors are regulated by gene regulation networks, kinetics
of which is one of the main subjects in the study of systems biology. Because
of the low number molecules in these reacting systems, stochastic effects are
significant. In recent years, stochasticity in modeling the kinetics of gene
regulation networks have been drawing the attention of many researchers. This
paper is a self contained review trying to provide an overview of stochastic
modeling. I will introduce the derivation of the main equations in modeling the
biochemical systems with intrinsic noise (chemical master equation, Fokker-Plan
equation, reaction rate equation, chemical Langevin equation), and will discuss
the relations between these formulations. The mathematical formulations for
systems with fluctuations in kinetic parameters are also discussed. Finally, I
will introduce the exact stochastic simulation algorithm and the approximate
explicit tau-leaping method for making numerical simulations.

A theory for direct quantitative analysis of an antigen is proposed. It is
based on a potential homogenous immunoreaction system. It establishes an
equation to describe the concentration change of the antigen and antibody
complex. A maximum point is found in the concentration profile of the complex
which can be used to calculate the concentration of the antigen. An
experimental scheme was designed for a commercial time-resolved
fluoroimmunoassay kit for HBsAg, which is based heterogeneous immunoreaction.
The results showed that the theory is practically applicable.

To investigate possible errors, length-weight parameters from FishBase.org
were used to graph length-weight curves for six different species: channel
catfish, black crappie, largemouth bass, rainbow trout, flathead catfish, and
lake trout along with the standard weight curves (Anderson and Neumann 1996,
Bister et al. 2000). Parameters noted as doubtful by FishBase were excluded.
For each species, variations in curves were noted, and the minimum and maximum
predicted weights for a 30 cm long fish were compared with each other and with
the standard weight for that length. For lake trout, additional comparisons
were made between the parameters and study details reported in FishBase.org for
6 of 8 length-weight relationships and those reported in the reference
(Carlander 1969) for those 6 relationships. In all species studied, minimum and
maximum curves produced with the length-weight parameters at FishBase.org are
notably different from each other, and in many cases predict weights that are
clearly absurd. For example, one set of parameters predicts a 30 cm rainbow
trout weighing 44 g. For 30 cm length, the range of weights (relative to the
standard weight) for each species are: channel catfish (31.4% to 193.1%), black
crappie (54.0% to 149.0%), largemouth bass (28.8% to 130.4%), rainbow trout
(14.9% to 113.4%), flathead catfish (29.3% to 250.7%), and lake trout (44.0% to
152.7%). Length-weight tables at FishBase.org are not generally reliable and
the on-line database contains dubious parameters. Assurance of quality probably
will require a systematic review with more careful and comprehensive methods
than those currently employed.

Cellular populations are typically heterogenous collections of cells at
different points in their respective cell cycles, each with a cell cycle time
that varies from individual to individual. As a result, true single-cell
behavior, particularly that which is cell-cycle--dependent, is often obscured
in population-level (averaged) measurements. We have developed a simple
deconvolution method that can be used to remove the effects of asynchronous
variability from population-level time-series data. In this paper, we summarize
some recent progress in the development and application of our approach, and
provide technical updates that result in increased biological fidelity. We also
explore several preliminary validation results and discuss several ongoing
applications that highlight the method's usefulness for estimating parameters
in differential equation models of single-cell gene regulation.

In a study of the heterogeneity in malaria infection rates among children
Smith et al.1 fitted several mathematical models to data from community studies
in Africa. They concluded that 20% of children receive 80% of infections, that
infections last about six months on average, that children who clear infections
are not immune to new infections, and that the sensitivity and specificity of
microscopy for the detection of malaria parasites are 95.8% and 88.4%,
respectively. These findings would have important implications for disease
control, but we show here that the statistical analysis is unsound and that the
data do not support their conclusions.

At present, the best hope for eliminating HIV transmission and bringing the
epidemic of HIV to an end lies in the use of anti-retroviral therapy for
prevention, a strategy referred to variously as Test and Treat (T&T), Treatment
as Prevention (TasP) or Treatment centred Prevention (TcP). One of the key
objections to the use of T&T to stop transmission concerns the role of the
acute phase in HIV transmission. The acute phase of infection lasts for one to
three months after HIV-seroconversion during which time the risk of
transmission may be ten to twenty times higher, per sexual encounter, than it
is during the chronic phase which lasts for the next ten years. Regular testing
for HIV is more likely to miss people who are in the acute phase than in the
chronic phase and it is essential to determine the extent to which this might
compromise the impact of T&T on HIV-transmission.
  Here we show that 1) provided the initial epidemic doubling time is about 1.0
to 1.5 years, as observed in South Africa, random testing with an average test
interval of one year will still bring the epidemic close to elimination even if
the acute phase lasts for 3 months during which time transmission is 26 times
higher than in the chronic phase; 2) testing people regularly at yearly
intervals is significantly more effective then testing them randomly; 3)
testing people regularly at six monthly intervals and starting them on ART
immediately, will almost certainly guarantee elimination.
  In general it seems unlikely that elevated transmission during the acute
phase is likely to change predictions of the impact of treatment on
transmission significantly. Other factors, in particular age structure, the
structure of sexual networks and variation in set-point viral load are likely
to be more important and should be given priority in further analyses.

We extend an hypergraph representation, introduced by Finkelstein and
Roytberg, to unify dynamic programming algorithms in the context of RNA folding
with pseudoknots. Classic applications of RNA dynamic programming energy
minimization, partition function, base-pair probabilities...) are reformulated
within this framework, giving rise to very simple algorithms. This
reformulation allows one to conceptually detach the conformation space/energy
model -- captured by the hypergraph model -- from the specific application,
assuming unambiguity of the decomposition. To ensure the latter property, we
propose a new combinatorial methodology based on generating functions. We
extend the set of generic applications by proposing an exact algorithm for
extracting generalized moments in weighted distribution, generalizing a prior
contribution by Miklos and al. Finally, we illustrate our full-fledged
programme on three exemplary conformation spaces (secondary structures,
Akutsu's simple type pseudoknots and kissing hairpins). This readily gives sets
of algorithms that are either novel or have complexity comparable to classic
implementations for minimization and Boltzmann ensemble applications of dynamic
programming.

Wood-decay fungi decompose their substrate by extracellular, degradative
enzymes and play an important role in natural ecosystems by recycling carbon
and minerals fixed in plants. Thereby, they cause significant damage to the
wood structure and limit the use of wood as building material. Besides their
role as biodeteriorators wood-decay fungi can be used for biotechnological
purposes, e.g. the white-rot fungus Physisporinus vitreus for improving the
uptake of preservatives and wood-modification substances of refractory wood.
Therefore, the visualization and the quantification of microscopic decay
patterns are important for the study of the impact of wood-decay fungi in
general, as well as for wood-decay fungi and microorganisms with possible
applications in biotechnology. In the present work, we developed a method for
the automated localization and quantification of microscopic cell wall elements
(CWE) of Norway spruce wood such as bordered pits, intrinsic defects, hyphae or
alterations induced by P. vitreus using high resolution X-ray computed
tomographic microscopy. In addition to classical destructive wood anatomical
methods such as light or laser scanning microscopy, our method allows for the
first time to compute the properties (e.g. area, orientation and
size-distribution) of CWE of the tracheids in a sample. This is essential for
modeling the influence of microscopic CWE to macroscopic properties such as
wood strength and permeability.

We consider a mathematical model comprising of four coupled ordinary
differential equations (ODEs) for studying the hepatitis C (HCV) viral
dynamics. The model embodies the efficacies of a combination therapy of
interferon and ribavirin. A condition for the stability of the uninfected and
the infected steady states is presented. A large number of sample points for
the model parameters (which were physiologically feasible) were generated using
Latin hypercube sampling. Analysis of our simulated values indicated
approximately 24% cases as having an uninfected steady state. Statistical tests
like the chi-square-test and the Spearman's test were also done on the sample
values. The results of these tests indicate a distinctly differently
distribution of certain parameter values and not in case of others, vis-a-vis,
the stability of the uninfected and the infected steady states.

The traditional power law model, W(L) = aL^b, is widely applied to describe
weight (W) vs. length (L) in fish. The model, W(L) = (L/L1)^b, is proposed as
an improvement. The Levenberg-Marquardt non-linear least squares technique is
used to determine the best-fit parameters L1 and b. This model has the
advantages that L1 has the same units (length) independent of the value of the
exponent and has an easily interpreted physical meaning as the typical length
of a fish with one unit of weight. This proposed model is compared with the
traditional model on length-weight data sets for black crappie, largemouth
bass, chain pickerel, yellow perch, and brown bullhead obtained from Stilwell
Reservoir, West Point, New York. The resulting best-fit parameters, parameter
standard errors, and covariances are compared between the two models. The
average relative weight for these species is determined, along with typical
meat yields for four species. For the five species, using the logarithmic
approach and a linear least-squares, standard errors in the coefficient, a,
range from 60.2% to 136.5% for the traditional model. Using a non-linear least
squares technique to determine best fit parameters, the standard errors for the
coefficient, a, range from 68.5% to 164.0% in the traditional model. In the
improved model, standard errors in the parameter L1 range from 0.94% to 15.0%.
The covariance between a and b in the traditional model has a magnitude between
0.999 and 1.000 in both linear and non-linear parameter estimation methods. In
the improved model, the covariances between L1 and b are smaller. The improved
model, W(L) = (L/L1)^b, is preferable for weight vs. length in fish, because
the estimated parameter uncertainties and covariances are smaller in magnitude.
Furthermore, the parameters both have consistent units and an easily
interpreted physical meaning.

Mathematical models of stem cell differentiation are commonly based upon the
concept of subsequent cell fate decisions, each controlled by a gene regulatory
network. These networks exhibit a multistable behavior and cause the system to
switch between qualitatively distinct stable steady states. However, the
network structure of such a switching module is often uncertain, and there is
lack of knowledge about the exact reaction kinetics. In this paper, we
therefore perform an elementary study of small networks consisting of three
interacting transcriptional regulators responsible for cell differentiation: We
investigate which network structures can reproduce a certain multistable
behavior, and how robustly this behavior is realized by each network. In order
to approach these questions, we use a modeling framework which only uses
qualitative information about the network, yet allows model discrimination as
well as to evaluate the robustness of the desired multistability properties. We
reveal structural network properties which are necessary and sufficient to
realize distinct steady state patterns required for cell differentiation. Our
results also show that structural and robustness properties of the networks are
related to each other.

Motivated by the biologically important and complex phenomena of A\beta\
peptide aggregation in Alzheimer's disease, we introduce a model and simulation
methodology for studying protein aggregation that includes extra-cellular
aggregation, aggregation on the cell-surface assisted by a membrane bound
protein, and in addition, supply, clearance, production and sequestration of
peptides and proteins. The model is used to produce equilibrium and
kinetic-aggregation phase diagrams for aggregation onset and of reduced stable
A\beta\ monomer concentrations due to aggregation. The methodology we
implemented permits modeling of a phenomenon involving orders of magnitude
differences in time scales and concentrations which can be retained in the
simulation. We demonstrate how to identify ranges of parameter values that give
monomer concentration depletion upon aggregation similar to that observed in
Alzheimer's disease. We show how very different behavior can be obtained as
reaction parameters and protein concentrations vary, and discuss the difficulty
reconciling results of experiments from two vastly different concentration
regimes. The latter is an important general issue in relating in-vitro and mice
based experiments to humans.

Carlander's Handbook of Freshwater Fishery Biology (1969) contains life
history data from many species of freshwater fish found in North America. It
has been cited over 1200 times and used to produce standard-weight curves for
some species. Recent work (Cole-Fletcher et al. 2011) suggests Carlander (1969)
contains numerous errors in listed weight-length equations. This paper assesses
the weight-length relationships listed in Carlander for muskellunge, northern
pike, and chain pickerel by comparing graphs of the weight vs. length equations
with other data listed and with standard weight curves published by independent
sources. A number of discrepancies are identified through this analysis and new
weight-length relationships are produced from listed data.

We analyzed the periodic patterns in E. coli promoters and compared the
distributions of the corresponding patterns in promoters and in the complete
genome to elucidate their function. Except the three-base periodicity,
coincident with that in the coding regions and growing stronger in the region
downstream from the transcriptions start (TS), all other salient periodicities
are peaked upstream of TS. We found that helical periodicities with the lengths
about B-helix pitch ~10.2-10.5 bp and A-helix pitch ~10.8-11.1 bp coexist in
the genomic sequences. We mapped the distributions of stretches with A-, B-,
and Z- like DNA periodicities onto E.coli genome. All three periodicities tend
to concentrate within non-coding regions when their intensity becomes stronger
and prevail in the promoter sequences. The comparison with available
experimental data indicates that promoters with the most pronounced
periodicities may be related to the supercoiling-sensitive genes.

For velocity-jump Markov processes with equivariant internal dynamics, we
remark that population distributions are invariant. This provides a
formalization of the fact that FCD (scale) and other symmetry invariant systems
perform identical spatial searches under input transformations.

We propose an Individual-Based Model of ant-trail formation. The ants are
modeled as self-propelled particles which deposit directed pheromones and
interact with them through alignment interaction. The directed pheromones
intend to model pieces of trails, while the alignment interaction translates
the tendency for an ant to follow a trail when it meets it. Thanks to adequate
quantitative descriptors of the trail patterns, the existence of a phase
transition as the ant-pheromone interaction frequency is increased can be
evidenced. Finally, we propose both kinetic and fluid descriptions of this
model and analyze the capabilities of the fluid model to develop trail
patterns. We observe that the development of patterns by fluid models require
extra trail amplification mechanisms that are not needed at the
Individual-Based Model level.

We examine two models for hepatitis C viral (HCV) dynamics, one for
monotherapy with interferon (IFN) and the other for combination therapy with
IFN and ribavirin. Optimal therapy for both the models is determined using the
steepest gradient method, by defining an objective functional which minimizes
the infected hepatocyte levels, virion population and the side-effects of the
drug(s). The optimal therapy for both the models shows an initial period of
high efficacy, followed by a gradual decline. The period of high efficacy
coincides with a significant decrease in the infected hepatocyte levels as well
as viral load, whereas the efficacy drops after liver regeneration through
restored hepatocyte levels. The period of high efficacy is not altered
significantly when the cost coefficients are varied, as long as the side
effects are relatively small. This suggests a higher dependence of the optimal
therapy on the model parameters in case of drugs with minimal side effects.
  We use the Latin hypercube sampling technique to randomly generate a large
number of patient scenarios (i.e, model parameter sets) and study the dynamics
of each set under the optimal therapy already determined. Results show an
increase in the percentage of responders (as indicated by drop in viral load
below detection levels) in case of combination therapy as compared to
monotherapy. Statistical tests performed to study the correlations between
sample parameters and the time required for the viral load to fall below
detection level, show a strong monotonic correlation with the death rate of
infected hepatocytes, identifying it to be an important factor in deciding
individual drug regimens.

Within the preprocessing pipeline of a Next Generation Sequencing sample, its
set of Single-Base Mismatches is one of the first outcomes, together with the
number of correctly aligned reads. The union of these two sets provides a 4x4
matrix (called Single Base Indicator, SBI in what follows) representing a
blueprint of the sample and its preprocessing ingredients such as the
sequencer, the alignment software, the pipeline parameters. In this note we
show that, under the same technological conditions, there is a strong relation
between the SBI and the biological nature of the sample. To reach this goal we
need to introduce a similarity measure between SBIs: we also show how two
measures commonly used in machine learning can be of help in this context.

In several countries in southern Africa, including South Africa, the
prevalence of HIV remains stubbornly high in spite of considerable efforts to
reduce transmission and to provide anti-retroviral therapy (ART). It is
important to know the extent to which the high prevalence of HIV reflects the
increasing number of people on ART in which case the prevalence of those not on
ART may be falling. Unfortunately, direct measures of the proportion of
HIV-positive people who are on ART are lacking in most countries and we need to
use dynamical models to estimate the impact of ART on the prevalence of HIV. In
this paper we show that the current level of ART provision in South Africa has
probably reduced the prevalence of HIV among those not on ART by 1.9 million,
averted 259 thousand new infections and 428 thousand deaths.

The magnitude of traction forces exerted by living animal cells on their
environment is a monotonically increasing and approximately sigmoidal function
of the stiffness of the external medium. This observation is rationalized using
active matter theory: adaptation to substrate rigidity results from an
interplay between passive elasticity and active contractility.

Genotyping errors are known to influence the power of both family-based and
case-control studies in the genetics of complex disease. Estimating genotyping
error rate in a given dataset can be complex, but when family information is
available error rates can be inferred from the patterns of Mendelian
inheritance between parents and offspring. I introduce a novel likelihood-based
method for calculating error rates from family data, given known allele
frequencies. I apply this to an example dataset, demonstrating a low genotyping
error rate in genotyping data from a personal genomics company.

We derive an exact Green's function of the diffusion equation for a pair of
spherical interacting particles in 2D subject to a back-reaction boundary
condition.

The paper presents an algorithm for syndromic surveillance of an epidemic
outbreak formulated in the context of stochastic nonlinear filtering. The
dynamics of the epidemic is modeled using a generalized compartmental
epidemiological model with inhomogeneous mixing. The syndromic (typically
non-medical) observations of the number of infected people (e.g. visits to
pharmacies, sale of certain products, absenteeism from work/study etc.) are
used for estimation. The state of the epidemic, including the number of
infected people and the unknown parameters of the model, are estimated via a
particle filter. The numerical results indicate that the proposed framework can
provide useful early prediction of the epidemic peak if the uncertainty in
prior knowledge of model parameters is not excessive.

Summary: CytoSaddleSum provides Cytoscape users with access to the
functionality of SaddleSum, a functional enrichment tool based on sum-of-weight
scores. It operates by querying SaddleSum locally (using the standalone
version) or remotely (through an HTTP request to a web server). The functional
enrichment results are shown as a term relationship network, where nodes
represent terms and edges show term relationships. Furthermore, query results
are written as Cytoscape attributes allowing easy saving, retrieval and
integration into network-based data analysis workflows.
  Availability: www.ncbi.nlm.nih.gov/CBBresearch/Yu/downloads The source code
is placed in Public Domain.

The toxins associated with infectious diseases are potential targets for
inhibitors which have the potential for prophylactic or therapeutic use. Many
antibodies have been generated for this purpose, and the objective of this
study was to develop a simple mathematical model that may be used to evaluate
the potential protective effect of antibodies. This model was used to evaluate
the contributions of antibody affinity and concentration to reducing
antibody-receptor complex formation and internalization. The model also enables
prediction of the antibody kinetic constants and concentration required to
provide a specified degree of protection. We hope that this model, once
validated experimentally, will be a useful tool for in vitro selection of
potentially protective antibodies for progression to in vivo evaluation.

Several authors have hypothesized that ecological systems are subject to
thermodynamic optimization, which, if proven correct, could represent a long
sought general principle of organization in ecology. Although there have been
recent advances, this still remains as an unresolved topic, and ecologists lack
a general method to test thermodynamic optimization hypotheses in specific
systems. Here we present a general, novel approach that allows generating a
null model for testing thermodynamic optimization on ecological systems. We
first describe the general methodology, which is based in the analysis of a
parametrized mathematical model of the system and the explicit consideration of
constraints. Next we present an application example to an animal population
using a general age-structured population model and physiological parameters
from the literature. We finalize discussing the relevance of this work in the
context of the current state of ecology, and implications for the further
development of a thermodynamic ecological theory.

We present a numerically efficient method to reconstruct a disordered network
of thin biopolymers, such as collagen gels, from three-dimensional (3D) image
stacks recorded with a confocal microscope. Our method is based on a template
matching algorithm that simultaneously performs a binarization and
skeletonization of the network. The size and intensity pattern of the template
is automatically adapted to the input data so that the method is scale
invariant and generic. Furthermore, the template matching threshold is
iteratively optimized to ensure that the final skeletonized network obeys a
universal property of voxelized random line networks, namely, solid-phase
voxels have most likely three solid-phase neighbors in a $3\times3$
neighborhood. This optimization criterion makes our method free of user-defined
parameters and the output exceptionally robust against imaging noise.

We propose a quantitative method to estimate the statistical properties of
sets of genes for which expression data are available and co-registered to a
reference atlas of the brain. It is based on graph-theoretic properties of
co-expression coefficients between pairs of genes. We apply this method to
mouse genes from the Allen Gene Expression Atlas. Co-expression patterns of a
list of several hundreds of genes related to addiction are analyzed, using ISH
data produced for the mouse brain at the Allen Institute. It appears that large
subsets of this set of genes are much more highly co-expressed than expected by
chance.

We consider a mathematical model that describes the release of
heparin-binding growth factors from an affinity-based delivery system. In the
delivery system, heparin binds to a peptide which has been covalently
cross-linked to a fibrin matrix. Growth factor in turn binds to the heparin,
and growth factor release is governed by both binding and diffusion mechanisms,
the purpose of the binding being to slow growth factor release. The governing
mathematical model, which in its original formulation consists of five partial
differential equations, is reduced to a system of just two equations. We
identify the governing non-dimensional parameters that can be varied to tune
the growth factor release rate. In particular, we identify a parameter regime
that ensures slow passive release (usually desirable) of at least a fraction of
the growth factor. It is found that slow release is assured if the matrix is
prepared with the concentration of cross-linked peptide greatly exceeding the
dissociation constant of heparin from the peptide, and with the concentration
of heparin greatly exceeding the dissociation constant of the growth factor
from heparin. Also, for the first time, in vitro experimental release data is
directly compared with theoretical release profiles generated by the model. We
propose that the two stage release behaviour frequently seen in experiments is
due to an initial rapid out-diffusion of free growth factor over a diffusion
time scale (typically days), followed by a much slower release of the bound
fraction over a time scale depending on both diffusion and binding parameters
(frequently months).

Randomising networks using a naive `accept-all' edge-swap algorithm is
generally biased. Building on recent results for nondirected graphs, we
construct an ergodic detailed balance Markov chain with non-trivial acceptance
probabilities for directed graphs, which converges to a strictly uniform
measure and is based on edge swaps that conserve all in- and out-degrees. The
acceptance probabilities can also be generalized to define Markov chains that
target any alternative desired measure on the space of directed graphs, in
order to generate graphs with more sophisticated topological features. This is
demonstrated by defining a process tailored to the production of directed
graphs with specified degree-degree correlation functions. The theory is
implemented numerically and tested on synthetic and biological network
examples.

Cre-lox and other systems are used as genetic tools to control site-specific
recombination (SSR) events in genomic DNA. If multiple recombination sites are
organized in a compact cluster within the same genome, a series of random
recombination events may generate substantial cell specific genomic diversity.
This diversity is used, for example, to distinguish neurons in the brain of the
same multicellular mosaic organism, within the brainbow approach to neuronal
connectome. In this paper we study an exactly solvable statistical model for
SSR operating on a cluster of recombination sites. We consider two types of
recombination events: inversions and excisions. Both of these events are
available in the Cre-lox system. We derive three properties of the sequences
generated by multiple recombination events. First, we describe the set of
sequences that can in principle be generated by multiple inversions operating
on the given initial sequence. We call this description the ergodicity theorem.
On the basis of this description we calculate the number of sequences that can
be generated from an initial sequence. This number of sequences is
experimentally testable. Second, we demonstrate that after a large number of
random inversions every sequence that can be generated is generated with equal
probability. Lastly, we derive the equations for the probability to find a
sequence as a function of time in the limit when excisions are much less
frequent than inversions, such as in shufflon sequences.

CSA is a web server for the comprehensive comparison of pairwise protein
structure alignments. Its exact alignment engine computes either optimal,
top-scoring alignments or heuristic alignments with quality guarantee for the
inter-residue distance based scorings of contact map overlap, PAUL, DALI and
MATRAS. These and additional, uploaded alignments are compared using a number
of quality measures and intuitive visualizations. CSA brings new insight into
the structural relationship of the protein pairs under investigation and is a
valuable tool for studying structural similarities. It is available at
http://csa.project.cwi.nl

It is well known that individuals who abuse drugs usually use more than one
substance. Toxic consequences of single and multiple drug use are well
documented in the Treatment Episodes Data Set that lists combinations that
result in hospital admissions. Using this list as a guide, we focused our
attention on combinations that result in the most hospital admissions and
searched the PubMed database to determine the number of publications dealing
with these toxic combinations. Of special interest were those publications that
looked for or used the term synergism in their titles or abstracts, a search
that produced an extensive list of published articles. However, a further
intersection of these with the term isobole revealed a surprisingly small
number of literature reports. Because the method of isoboles is the most common
quantitative method for distinguishing between drug synergism and simple
additivity, the small number of investigations that actually employed this
quantitation suggests that the term synergism is not properly documented in
describing the toxicity among these abused substances. The possible reasons for
this lack of quantitation may be related to a misunderstanding of the modeling
equations. The theory and modeling are discussed here.

Euclidean distance geometry is the study of Euclidean geometry based on the
concept of distance. This is useful in several applications where the input
data consists of an incomplete set of distances, and the output is a set of
points in Euclidean space that realizes the given distances. We survey some of
the theory of Euclidean distance geometry and some of the most important
applications: molecular conformation, localization of sensor networks and
statics.

Here are presenting the blank based time-alignment (BBTA) as a strong
analytical approach for treatment of non-linear shift in time occurring in
HPLC-MS data. Need of such tool in recent large dataset produced by analytical
chemistry and so-called omics studies is evident. Proposed approach is based on
measurement and comparison of blank and analyzed sample evident features. In
the first step of BBTA procedure, the number of compounds is reduced by
max-to-mean ratio thresholding, which extensively reduce the computational
time. Simple thresholding is followed by selection of time markers defined from
blank inflex points which are then used for the transformation function,
polynomial of second degree, in the example. BBTA approach was compared on real
HPLC-MS measurement with Correlation Optimized Warping (COW) method. It was
proved to have distinctively shorter computational time as well as lower level
of mathematical presumptions. The BBTA is computationally much easier, quicker
(more then 1000x) and accurate in comparison with warping. Moreover, markers
selection works efficiently without any peak detection. It is sufficient to
analyze only baseline contribution in the analyte measurement with sparse
knowledge of blank behavior. Finally, BBTA does not required usage of extra
internal standards and due to its simplicity it has a potential to be
widespread tool in HPLC-MS data treatment.

A/H1N1 epidemic data from Istanbul, Turkey during the period June
2009-February 2010 is analyzed with SEIR (Susceptible-Exposed-Infected-Removed)
model. The data consist of the daily adult hospitalization numbers and
fatalities recorded in various state hospitals serving an adult population of
about 1.5-2 million. June 2009-August 2009 period corresponds to the initial
stage of the epidemic where the hospitalization rate is nearly %100 and it is
excluded from further consideration. The analysis covers the September
2009-February 2010 period, the total number of hospitalizations and fatalities
being respectively 869 and 46. It is shown that the maximum correlation between
the number of fatalities and hospitalizations occur with a time shift of 9 days
and the proportionality constant is {\delta}=0.0537. The SEIR epidemic model is
applied to the data by back-shifting the number of fatalities. The
determination of the best fitting model is based on the L2 norms of errors
between the model and the data and the errors are around %10 and %2.6 for the
number of hospitalizations and fatalities, respectively. The parameters in the
model are I0, {\eta}, {\epsilon} and {\beta}, where I0 is the percentage of
people infected initially, {\eta} and {\epsilon} are related to the inverses of
the infection and incubation periods and {\beta}/{\eta} is the representative
of the basic reproduction number. These parameters are determined as
{\eta}=0.09 (1/{\eta} =11.11days), I0=10^-7.4, {\epsilon}=0.32 (1/{\epsilon}
=3.125 days), {\beta}=0.585, {\beta}/{\eta}=6.5.

The three-dimensional data-driven Allen Gene Expression Atlas of the adult
mouse brain consists of numerized in-situ hybridization data for thousands of
genes, co-registered to the Allen Reference Atlas. We propose quantitative
criteria to rank genes as markers of a brain region, based on the localization
of the gene expression and on its functional fitting to the shape of the
region. These criteria lead to natural generalizations to sets of genes. We
find sets of genes weighted with coefficients of both signs with almost perfect
localization in all major regions of the left hemisphere of the brain, except
the pallidum. Generalization of the fitting criterion with positivity
constraint provides a lesser improvement of the markers, but requires sparser
sets of genes.

Amphiphilic peptide conjugation affords a significant increase in sensitivity
with protein quantification by electrospray-ionization mass spectrometry. This
has been demonstrated here for human growth hormone in serum using
N-(3-iodopropyl)-N,N,N-dimethyloctylammonium iodide (IPDOA-iodide) as
derivatizing reagent. The signal enhancement achieved in comparison to the
method without derivatization enables extension of the applicable concentration
range down to the very low concentrations as encountered with clinical glucose
suppression tests for patients with acromegaly. The method has been validated
using a set of serum samples spiked with known amounts of recombinant 22 kDa
growth hormone in the range of 0.48 to 7.65 \mug/L. The coefficient of
variation (CV) calculated, based on the deviation of results from the expected
concentrations, was 3.5% and the limit of quantification (LoQ) was determined
as 0.4 \mug/L. The potential of the method as a tool in clinical practice has
been demonstrated with patient samples of about 1 \mug/L.

Background: Psychedelic drugs facilitate profound changes in consciousness
and have potential to provide insights into the nature of human mental
processes and their relation to brain physiology. Yet published scientific
literature reflects a very limited understanding of the effects of these drugs,
especially for newer synthetic compounds. The number of clinical trials and
range of drugs formally studied is dwarfed by the number of written
descriptions of the many drugs taken by people. Analysis of these descriptions
using machine-learning techniques can provide a framework for learning about
these drug use experiences. Methods: We collected 1000 reports of 10 drugs from
the drug information website Erowid.org and formed a term-document frequency
matrix. Using variable selection and a random-forest classifier, we identified
a subset of words that differentiated between drugs. Results: A random forest
using a subset of 110 predictor variables classified with accuracy comparable
to a random forest using the full set of 3934 predictors. Our estimated
accuracy was 51.1%, which compares favorably to the 10% expected from chance.
Reports of MDMA had the highest accuracy at 86.9%; those describing DPT had the
lowest at 20.1%. Hierarchical clustering suggested similarities between certain
drugs, such as DMT and Salvia divinorum. Conclusion: Machine-learning
techniques can reveal consistencies in descriptions of drug use experiences
that vary by drug class. This may be useful for developing hypotheses about the
pharmacology and toxicity of new and poorly characterized drugs.

Many stochastic systems in physics and biology are investigated by recording
the two-dimensional (2D) positions of a moving test particle in regular time
intervals. The resulting sample trajectories are then used to induce the
properties of the underlying stochastic process. Often, it can be assumed a
priori that the underlying discrete-time random walk model is independent from
absolute position (homogeneity), direction (isotropy) and time (stationarity),
as well as ergodic. In this article we first review some common statistical
methods for analyzing 2D trajectories, based on quantities with built-in
rotational invariance. We then discuss an alternative approach in which the
two-dimensional trajectories are reduced to one dimension by projection onto an
arbitrary axis and rotational averaging. Each step of the resulting 1D
trajectory is further factorized into sign and magnitude. The statistical
properties of the signs and magnitudes are mathematically related to those of
the step lengths and turning angles of the original 2D trajectories,
demonstrating that no essential information is lost by this data reduction. The
resulting binary sequence of signs lends itself for a pattern counting
analysis, revealing temporal properties of the random process that are not
easily deduced from conventional measures such as the velocity autocorrelation
function. In order to highlight this simplified 1D description, we apply it to
a 2D random walk with restricted turning angles (RTA model), defined by a
finite-variance distribution $p(L)$ of step length and a narrow turning angle
distribution $p(\phi)$, assuming that the lengths and directions of the steps
are independent.

Many stochastic time series can be modelled by discrete random walks in which
a step of random sign but constant length $\delta x$ is performed after each
time interval $\delta t$. In correlated discrete time random walks (CDTRWs),
the probability $q$ for two successive steps having the same sign is unequal
1/2. The resulting probability distribution $P(\Delta x,\Delta t)$ that a
displacement $\Delta x$ is observed after a lagtime $\Delta t$ is known
analytically for arbitrary persistence parameters $q$. In this short note we
show how a CDTRW with parameters $[\delta t, \delta x, q]$ can be mapped onto
another CDTRW with rescaled parameters $[\delta t/s, \delta x\cdot g(q,s),
q^{\prime}(q,s)]$, for arbitrary scaling parameters $s$, so that both walks
have the same displacement distributions $P(\Delta x,\Delta t)$ on long time
scales. The nonlinear scaling functions $g(q,s)$ and $q^{\prime}(q,s)$ and
derived explicitely. This scaling method can be used to model time series
measured at discrete sample intervals $\delta t$ but actually corresponding to
continuum processes with variations occuring on a much shorter time scale
$\delta t/s$.

We have developed a method combining microfluidics, time-lapsed
single-molecule microscopy and automated image analysis allowing for the
observation of an excess of 3000 complete cell cycles of exponentially growing
Escherichia coli cells per experiment. The method makes it possible to analyze
the rate of gene expression at the level of single proteins over the bacterial
cell cycle. We also demonstrate that it is possible to count the number of
non-specifically DNA binding LacI-Venus molecules using short excitation light
pulses. The transcription factors are localized on the nucleoids in the cell
and appear to be uniformly distributed on chromosomal DNA. An increase of the
expression of LacI is observed at the beginning of the cell cycle, possibly
because some gene copies are de-repressed as a result of partitioning
inequalities at cell division. Finally, observe a size-growth rate uncertainty
relation where cells living in rich media vary more in the length at birth than
in generation time and the opposite is true for cells living in poorer media.

The evolution of a continuous time Markov process with a finite number of
states is usually calculated by the Master equation - a linear differential
equations with a singular generator matrix. We derive a general method for
reducing the dimensionality of the Master equation by one by using the
probability normalization constraint, thus obtaining a affine differential
equation with a (non-singular) stable generator matrix. Additionally, the
reduced form yields a simple explicit expression for the stationary probability
distribution, which is usually derived implicitly. Finally, we discuss the
application of this method to stochastic differential equations.

We study kinetic models of reversible enzyme reactions and compare two
techniques for analytic approximate solutions of the model. Analytic
approximate solutions of non-linear reaction equations for reversible enzyme
reactions are calculated using the Homotopy Perturbation Method (HPM) and the
Simple Iteration Method (SIM). The results of the approximations are similar.
The Matlab programs are included in appendices.

Stochastic rearrangement of germline DNA by VDJ recombination is at the
origin of immune system diversity. This process is implemented via a series of
stochastic molecular events involving gene choices and random nucleotide
insertions between, and deletions from, genes. We use large sequence
repertoires of the variable CDR3 region of human CD4+ T-cell receptor beta
chains to infer the statistical properties of these basic biochemical events.
Since any given CDR3 sequence can be produced in multiple ways, the probability
distribution of hidden recombination events cannot be inferred directly from
the observed sequences; we therefore develop a maximum likelihood inference
method to achieve this end. To separate the properties of the molecular
rearrangement mechanism from the effects of selection, we focus on
non-productive CDR3 sequences in T-cell DNA. We infer the joint distribution of
the various generative events that occur when a new T-cell receptor gene is
created. We find a rich picture of correlation (and absence thereof), providing
insight into the molecular mechanisms involved. The generative event statistics
are consistent between individuals, suggesting a universal biochemical process.
Our distribution predicts the generation probability of any specific CDR3
sequence by the primitive recombination process, allowing us to quantify the
potential diversity of the T-cell repertoire and to understand why some
sequences are shared between individuals. We argue that the use of formal
statistical inference methods, of the kind presented in this paper, will be
essential for quantitative understanding of the generation and evolution of
diversity in the adaptive immune system.

export const DadosPais = styled.View`
    
    /* position:absolute; */
    /* top:-10px; */
`;
/* export const Texto = styled.Text`
font-size:16px;
    font-family:"Poppins-Bold";
    color:${props=>props.theme.color};
    margin-left:4px;
    background-color:${props=>props.theme.container};;
`; */

export const Titulo = styled.View`
    flex-direction:row;
    align-items:center;
    justify-content:space-between;
`;
export const TextoPais = styled.Text`
    font-size:18px;
    font-family:"Poppins-Bold";
    color:${props=>props.theme.color};
    margin-left:4px;
`;
export const Flag = styled.Image`
`;
export const TextoContinente = styled.View`
    flex-direction:row;
    margin-top:20px;
`;
export const TextoContinenteTexto = styled.Text`
    font-size:12px;
    font-family:"Poppins-Medium";
    color:${props=>props.theme.color};
`;
export const DadosDetalhes = styled.View`
    width:100%;
    margin:1px 1px 20px 1px;
    background-color:${props=>props.theme.container};;
    elevation:2;
    border-radius:8px;
    padding:10px;
    margin-top: 20px;
`;
export const MapaContainer = styled.View`
    margin-top:20px;
    width:100%;
`;
export const Botao = styled.TouchableOpacity`
    justify-content:center;
    width:100%;
    align-items:center;
`;
export const BotaoText = styled.Text`
    font-family:"Poppins-Bold";
    font-size:12px;
    color:${props=>props.theme.background};
    background-color:${props=>props.theme.color};
    padding:4px 30px;
    border-radius:4px;
    letter-spacing:1px;
`;
/**
 * Created by terminator10 on 2/11/15.
 */

//Create variables Global
var contador = 1;
//End Variables Global
function main () {
    $('.menu_bar').click(function(){
        if (contador == 1) {
            $('nav').animate({
                left: '0'
            });
            $('.menu_bar span').css({
               'background':'rgb(248,248,248)',
            });
            contador = 0;
        } else {
            $('.menu_bar span').css({
                'background':'#fff'
            });
            contador = 1;
            $('nav').animate({
                left: '100%'
            });

        }
    });
    // Mostramos y ocultamos submenus
    $('.submenu').click(function(){
        $(this).children('.children').slideToggle();
    });
}
/*Funciones para validar usuarios y email*/
function Validador(email){
    var tester = /^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-]+)\.)+([a-zA-Z0-9]{2,4})+$/;
    return tester.test(email);
}
function caracter(username){
    var caract = /^([a-zA-Z0-9_-])/;
    return caract.test(username)
}
function pass(password){
    var pass = /(^(?=.*[a-z])(?=.*[A-Z])(?=.*\d){7,20}.+$)/;
    return pass.test(password)
}

$(document).ready(function(){
    main();
    /*Verificacion de usurios   $(document).ready(main);*/
    /*Validacion el password*/
   document.getElementById('password').addEventListener('blur',function(){
        var password = document.getElementById('password').value;
        if(pass(password) == false){
            $('.password-validate').css({
                'color': '#fff'
            });
            $('.validate-pass').html('<i class="icon-warning"></i>').show();
            $('.validate-pass').css({
                'color': '#b20000'
            });
            return false;
        }else{
            $('.password-validate').css({
                'color': '#8c8c8c'
            });
            $('.validate-pass').html('<i class="icon-checkmark"></i>').show();
            $('.validate-pass').css({
                'color': 'rgba(72, 130, 255, 1)'
            });
        }
    });
    document.getElementById('username').addEventListener('blur',function(){
        var username = document.getElementById('username').value;
        if (username.length > 0) {
            if (caracter(username) == false) {
                $('.loader').html("<i class='icon-user'></i> Nombre de usuario no es válido o ya adoptadas.").show().delay(2000).hide(200);
                $('.validate-user').css({
                    'color': '#b20000'
                });
                $('.validate-user').html('<i class="icon-warning"></i>').show();
                return false;
            }else {
                $('.loader').html('').hide();
                $.ajax({
                    type:'POST',
                    url:'server/app_server_whereis.php',
                    data:{username:username, wis:'verify_user'},
                    success: function (data) {
                        if (data == 0) {
                            $('.validate-user').css({
                                'color': '#b20000'
                            });
                            $('.validate-user').html('<i class="icon-warning"></i>').show();
                            $('.loader').html("<i class='icon-user'></i> Nombre de usuario no es válido o ya adoptadas.").show().delay(2000).hide(200);
                        } else if (data == 1) {
                            $('.validate-user').css({
                                'color': 'rgba(72, 130, 255, 1)'
                            });
                            $('.validate-user').html('<i class="icon-checkmark"></i>').show();
                        }
                    }
                });
            }
        }
    });
    document.getElementById('email').addEventListener('blur',function(){
        var email = document.getElementById('email').value;
        if (email.length > 0) {
            if (Validador(email) == false) {
                $('.loader').html("<i class='icon-mail2'></i> Correo electronico no es válido o ya adoptadas.").show().delay(2000).hide(200);
                $('.validate-email').css({
                    'color': '#b20000'
                });
                $('.validate-email').html('<i class="icon-warning"></i>').show();
                return false;
            } else {
                $('.loader').html('').hide();
                $.ajax({
                    type: 'POST',
                    url: 'server/app_server_whereis.php',
                    data: {email: email, wis: 'verify_email'},
                    success: function (data) {

                        if (data == 0) {
                            $('.validate-email').css({
                                'color': '#b20000'
                            });
                            $('.validate-email').html('<i class="icon-warning"></i>').show();
                            $('.loader').html("<i class='icon-mail2'></i> Correo electronico no es válido o ya adoptadas.").show().delay(2000).hide(200);
                        }else if (data == 1) {
                            $('.validate-email').css({
                                'color': 'rgba(72, 130, 255, 1)'
                            });
                            $('.validate-email').html('<i class="icon-checkmark"></i>').show();
                        }
                    }
                });

            }
        }
    });
});

function login_data_user(){
    var username = document.getElementById('username').value;
    var email = document.getElementById('email').value;
    var password = document.getElementById('password').value;
    var len = username.length * email.length * password.length;
    if(len == "" && Validador(email) == false && caracter(username) == false && pass(password) == false){
        $('.loader').html('<i class="icon-warning"></i> Ohh! Datos introducidos incorrectos o campos estan vacios.').show().delay(2000).hide(200);
        return false;
    }else {
        $.ajax({
            type: 'POST',
            url: 'server/app_server_whereis.php',
            data: {username: username, email: email, password: password, wis: 'login_whereis'},
            success: function (data) {
                if (data == 1) {
                    $('.register-button').html("Creando su cuenta").show();
                    $('.loader').html('<div class="loader-inner ball-pulse-sync"><div></div><div></div><div></div></div>').show();
                    setTimeout(function () {
                        window.location = "inicio";
                    }, 3000);
                } else if (data == 2) {
                    $('.loader').html('<i class="icon-shocked"></i> Ohh! Hubo problemas para crear tu cuenta o datos ya adoptados. ').show().delay(2000).hide(200);
                } else if (data == 3) {
                    $('.loader').html('<i class="icon-sad"></i> Ohh! Asegurate de que tu usuario y email son correctos.').show().delay(2000).hide(200);
                }
            }
        });
    }
}







﻿// License
// --------------------------------------------------------------------------------------------------------------------
// (C) Copyright 2021 Cato Léan Trütschel and contributors
// (github.com/CatoLeanTruetschel/AsyncQueryableAdapterPrototype)
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// --------------------------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace AsyncQueryableAdapter.Sample
{
    internal static class Program
    {
        private static Repository Repository { get; } = new Repository();

#pragma warning disable CS1998, IDE0060
        private static async Task Main(string[] args)
#pragma warning restore CS1998, IDE0060
        {
            var lastNamesSync = from person in Repository.People
                                where person.Age > 25 && person.LastName != "Adams" && person.Gender != Gender.Unknown
                                select person.LastName;

            lastNamesSync = lastNamesSync.Where(p => p.Length > 6);

            Console.WriteLine("Last names: " + string.Join(", ", lastNamesSync));

            var lastNamesAsync = from person in Repository.QueryAdapter.GetAsyncQueryable<Person>()
                                 where person.Age > 25 && person.LastName != "Adams" && person.Gender != Gender.Unknown
                                 select person.LastName;

            var lastNames = await lastNamesAsync.WhereAwait(p => new ValueTask<bool>(p.Length > 6)).ToArrayAsync();

            Console.WriteLine("Last names: " + string.Join(", ", lastNames));
            Console.WriteLine("Last names count: " + await lastNamesAsync.CountAsync());
            Console.WriteLine("Last names max length: " + await lastNamesAsync.Select(p => p.Length).MaxAsync());
        }
    }

    internal sealed class Repository
    {
        private readonly List<Person> _people;
        private readonly List<Relationship> _relationships;

        public Repository()
        {
            QueryAdapter = new RepositoryQueryAdapter(this);
            (_people, _relationships) = SeedData();
        }

        private static (List<Person> people, List<Relationship> relationships) SeedData()
        {
            var relationships = new List<Relationship>();

            var christopherWagner = new Person("Christopher", "Wagner", 22, Gender.Male);
            var juanaMartinez = new Person("Juana", "Martinez", 30);
            var davidEstes = new Person("David", "Estes", 53, Gender.Male);
            var ashSapp = new Person("Ash", "Sapp", 21, Gender.Diverse);

            var jasonRandolph = new Person("Jason", "Randolph", 46, Gender.Male);
            var patriciaStone = new Person("Patricia", "Stone", 48, Gender.Female);
            relationships.Add(new Relationship(jasonRandolph, patriciaStone));

            var julieDaniels = new Person("Julie", "Daniels", 29, Gender.Female);
            var deborahFerguson = new Person("Deborah", "Ferguson", 31, Gender.Female);
            relationships.Add(new Relationship(julieDaniels, deborahFerguson));

            var lewisAdams = new Person("Lewis", "Adams", 46, Gender.Male);
            var rondaBelle = new Person("Ronda", "Belle", 41, Gender.Diverse);
            relationships.Add(new Relationship(lewisAdams, rondaBelle));

            var robertPhillips = new Person("Robert", "Phillips", 36, Gender.Male);
            var meghanPhillips = new Person("Meghan", "Phillips", 34, Gender.Female);
            relationships.Add(new Relationship(robertPhillips, meghanPhillips));

            var people = new List<Person>
            {
                christopherWagner,
                juanaMartinez,
                davidEstes,
                ashSapp,
                jasonRandolph,
                patriciaStone,
                julieDaniels,
                deborahFerguson,
                lewisAdams,
                rondaBelle,
                robertPhillips,
                meghanPhillips
            };

            return (people, relationships);
        }

        public IQueryable<Person> People => _people.AsQueryable();
        public IQueryable<Relationship> Relationships => _relationships.AsQueryable();

        public RepositoryQueryAdapter QueryAdapter { get; }
    }

    internal sealed class RepositoryQueryAdapter : QueryAdapterBase
    {
        private readonly Repository _repository;

        public RepositoryQueryAdapter(Repository repository)
            : base(Microsoft.Extensions.Options.Options.Create(new AsyncQueryableOptions()))
        {
            if (repository is null)
                throw new ArgumentNullException(nameof(repository));

            _repository = repository;
        }

        protected override IQueryable<T> GetQueryable<T>()
        {
            if (typeof(T) == typeof(Person))
            {
                return (IQueryable<T>)_repository.People;
            }

            if (typeof(T) == typeof(Relationship))
            {
                return (IQueryable<T>)_repository.Relationships;
            }

            return Enumerable.Empty<T>().AsQueryable();
        }

        protected override IAsyncEnumerable<T> EvaluateAsync<T>(
            IQueryable<T> queryable,
            CancellationToken cancellation)
        {
            return queryable.ToAsyncEnumerable();
        }
    }

    internal record Person(string FirstName, string LastName, int Age, Gender Gender = Gender.Unknown);

    internal record Relationship(Person Partner1, Person Pertner2);

    internal enum Gender
    {
        Unknown,
        Female,
        Male,
        Diverse,
        Other,
        None
    }
}

from core.terraform.resources import BaseTerraformVariable, TerraformData, TerraformResource
from core.config import Settings
from core.terraform.utils import get_terraform_resource_path, get_terraform_latest_output_file, get_terraform_status_file
from core.log import SysLog
from core import constants as K
from core.lib.python_terraform import *
from datetime import datetime
from core.utils import exists_teraform_lock
import inspect
import json


class PyTerraform():
    log_obj = SysLog()

    def terraform_init(self):
        if exists_teraform_lock():
            raise Exception(K.ANOTHER_PROCESS_RUNNING)

        terraform = Terraform(
            working_dir=Settings.TERRAFORM_DIR,
        )
        self.log_obj.write_debug_log(K.TERRAFORM_INIT_STARTED)
        response = terraform.init()

        if response[0] == 1:
            self.log_obj.write_debug_log(K.TERRAFORM_INIT_ERROR)
            raise Exception(response[2])

        self.log_obj.write_terraform_init_log(response)

        return response

    def terraform_plan(self, resources=None):
        if exists_teraform_lock():
            raise Exception(K.ANOTHER_PROCESS_RUNNING)

        terraform = Terraform(
            working_dir=Settings.TERRAFORM_DIR,
            targets=self.get_target_resources(resources)
        )

        self.log_obj.write_debug_log(K.TERRAFORM_PLAN_STARTED)
        response = terraform.plan()

        if response[0] == 1:
            self.log_obj.write_debug_log(K.TERRAFORM_PLAN_ERROR)
            raise Exception(response[2])

        self.log_obj.write_terraform_plan_log(response)

        return response

    def terraform_apply(self, resources=None):
        if exists_teraform_lock():
            raise Exception(K.ANOTHER_PROCESS_RUNNING)

        CMD = Settings.get('running_command', "Terraform Apply")
        terraform = Terraform(
            working_dir=Settings.TERRAFORM_DIR,
            targets=self.get_target_resources(resources),
            stdout_log_file=self.log_obj.get_terraform_install_log_file()
        )

        self.log_obj.write_terraform_apply_log_header()
        # In order to -auto-approve we need to pass skip_plan=True for python3
        response = terraform.apply(skip_plan=True)

        if response[0] == 1:
            self.log_obj.write_debug_log(K.TERRAFORM_APPLY_ERROR)
            self.write_current_status(CMD, K.APPLY_STATUS_ERROR, response[2])
            raise Exception(response[2])

        self.write_current_status(CMD, K.APPLY_STATUS_COMPLETED, K.TERRAFORM_APPLY_COMPLETED)
        return response

    def terraform_destroy(self, resources=None):
        if exists_teraform_lock():
            raise Exception(K.ANOTHER_PROCESS_RUNNING)

        CMD = Settings.get('running_command', "Terraform Destroy")
        terraform = Terraform(
            working_dir=Settings.TERRAFORM_DIR,
            targets=self.get_target_resources(resources),
            stdout_log_file=self.log_obj.get_terraform_destroy_log_file()
        )

        self.log_obj.write_terraform_destroy_log_header()
        kwargs = {"auto_approve": True}
        response = terraform.destroy(**kwargs)

        if response[0] == 1:
            self.log_obj.write_debug_log(K.TERRAFORM_DESTROY_ERROR)
            self.write_current_status(CMD, K.DESTROY_STATUS_ERROR, response[2])
            raise Exception(response[2])

        self.write_current_status(CMD, K.DESTROY_STATUS_COMPLETED, K.TERRAFORM_DESTROY_COMPLETED)
        return response

    def process_destroy_result(self, p):
        response = Terraform().return_process_result(p)
        CMD = Settings.get('running_command', "Terraform Destroy")

        if response[0] == 1:
            self.log_obj.write_debug_log(K.TERRAFORM_DESTROY_ERROR)
            self.write_current_status(CMD, K.DESTROY_STATUS_ERROR, response[2])
            raise Exception(response[2])

        self.write_current_status(CMD, K.DESTROY_STATUS_COMPLETED, K.TERRAFORM_DESTROY_COMPLETED)

    def terraform_taint(self, resources):
        if exists_teraform_lock():
            raise Exception(K.ANOTHER_PROCESS_RUNNING)

        terraform = Terraform(
            working_dir=Settings.TERRAFORM_DIR,
        )

        taint_resources = self.get_taint_resources(resources)

        self.log_obj.write_debug_log(K.TERRAFORM_TAINT_STARTED)

        for resource_name in taint_resources:
            response = terraform.cmd("taint", resource_name)
            if response[0] == 1:
                self.log_obj.write_debug_log(K.TERRAFORM_TAINT_ERROR)
                raise Exception(response[2])

        self.log_obj.write_debug_log(K.TERRAFORM_TAINT_COMPLETED)

        return response

    def get_target_resources(self, resources):
        if resources:
            targets = []
            for resource in resources:
                # DO NOT process this resource as its definiiton asked to skip
                if resource.PROCESS is False:
                    continue

                if BaseTerraformVariable not in inspect.getmro(resource.__class__) and TerraformData not in inspect.getmro(resource.__class__):
                    targets.append(get_terraform_resource_path(resource))

            return targets

        return None

    def get_taint_resources(self, resources):
        taint_resources = []
        for resource in resources:
            if TerraformResource in inspect.getmro(resource.__class__):
                taint_resources.append(get_terraform_resource_path(resource))

        return taint_resources

    @classmethod
    def save_terraform_output(cls):
        tf_output_file = get_terraform_latest_output_file()
        output_dict = cls.load_terraform_output()

        with open(tf_output_file, 'w') as jsonfile:
            json.dump(output_dict, jsonfile, indent=4)
        cls.log_obj.write_debug_log(K.TERRAFORM_OUTPUT_STORED)

        return output_dict

    @classmethod
    def load_terraform_output(cls):
        output_dict = {}

        terraform = Terraform(
            working_dir=Settings.TERRAFORM_DIR,
        )
        response = terraform.output()
        if response:
            for key, item in response.items():
                key_splitted = key.split('-')
                resource_key = '-'.join(key_splitted[0:-1])

                if resource_key in output_dict:
                    output_dict[resource_key][key_splitted[-1]] = item['value']
                else:
                    output_dict[resource_key] = {key_splitted[-1]: item['value']}

        return output_dict

    @classmethod
    def load_terraform_output_from_json_file(cls):
        tf_output_file = get_terraform_latest_output_file()
        output_dict = {}
        if os.path.exists(tf_output_file):
            with open(tf_output_file) as jsonfile:
                output_dict = json.load(jsonfile)

        return output_dict

    def write_current_status(self, command, status_code, description=""):
        current_status = self.get_current_status()
        prev_status = None

        if current_status:
            prev_status = {
                'status_code': current_status['status_code'],
                'description': current_status['description'],
                'last_exec_command': current_status['last_exec_command'],
                'executed_time': current_status['executed_time']
            }

        current_status['status_code'] = status_code
        current_status['description'] = description
        current_status['last_exec_command'] = command
        current_status['executed_time'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        if prev_status:  # FIrst time previous status won't be available
            current_status[prev_status['executed_time']] = prev_status

        status_file = get_terraform_status_file()
        with open(status_file, 'w') as jsonfile:
            json.dump(current_status, jsonfile, indent=4)

    @classmethod
    def get_current_status(self):
        status_file = get_terraform_status_file()
        status_dict = {}
        if os.path.exists(status_file):
            with open(status_file) as jsonfile:
                status_dict = json.load(jsonfile)

        return status_dict

import UIKit

class HSUserProtocalController: UIViewController {
    
      let  webView : UIWebView = UIWebView.init(frame: CGRectMake(0, 0, UIScreen.mainScreen().bounds.size.width, UIScreen.mainScreen().bounds.size.height-64));

    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.backgroundColor = UIColor.init(red: 0xf3/255.0, green: 0xf3/255.0, blue: 0xf3/255.0, alpha: 1.0);
        self.title = "用户许可协议";
        self.webView.scalesPageToFit = true;
        self.view.addSubview(self.webView);
        
        let url = NSURL.init(string: "http://www.elitez.cn/html/user_agreement");
        let request = NSURLRequest.init(URL: url!);
        self.webView.loadRequest(request);
    }
    
    
    
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    

    /*
    // MARK: - Navigation

    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */

}
---
title: 基于报表生成数据馈送（报表生成器和 SSRS）| Microsoft Docs
ms.custom: ''
ms.date: 05/30/2017
ms.prod: reporting-services
ms.prod_service: reporting-services-sharepoint, reporting-services-native
ms.component: report-builder
ms.reviewer: ''
ms.suite: pro-bi
ms.technology: ''
ms.tgt_pltfrm: ''
ms.topic: conceptual
ms.assetid: 4e00789f-6967-42e5-b2b4-03181fdb1e2c
caps.latest.revision: 12
author: maggiesMSFT
ms.author: maggies
manager: kfile
ms.openlocfilehash: 394a6ddd55d78615894b42a983f523827bafa27b
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/03/2018
---
# <a name="generating-data-feeds-from-reports-report-builder-and-ssrs"></a>基于报表生成数据馈送（报表生成器和 SSRS）

  [!INCLUDE[ssRSnoversion](../../includes/ssrsnoversion-md.md)] Atom 呈现扩展插件可生成 Atom 服务文档，该文档列出分页报表中可用的数据馈送以及来自报表中的数据区域的数据馈送。 使用此扩展插件生成与 Atom 兼容的数据馈送，这些馈送是可读的，并可以与使用从报表生成的数据馈送的应用程序进行交换。 例如，可以使用 Atom 呈现扩展插件生成随后可用在 Power Pivot 或 Power BI 中的数据馈送。  
  
 Atom 服务文档为报表中的每个数据区域至少列出一个数据馈送。 根据数据区域的类型以及数据区域显示的数据， [!INCLUDE[ssRSnoversion](../../includes/ssrsnoversion-md.md)] 可以自数据区域生成多个数据馈送。 例如，矩阵或图表可以提供多个数据馈送。 Atom 呈现扩展插件创建 Atom 服务文档时，将为每个数据馈送创建一个唯一标识符，在 URL 中使用该标识符可以访问数据馈送的内容。  
  
 Atom 呈现扩展插件为数据馈送生成数据的方式类似于逗号分隔值 (CSV) 呈现扩展插件将数据呈现到 CSV 文件的方式。 类似于 CSV 文件，数据馈送是报表数据的平展表示形式。 例如，表中有一个行组对某组中的销售额进行加总时，会对每个数据行重复加总，并没有单独的行仅包含总和。  
  
 可以使用 [!INCLUDE[ssRSnoversion](../../includes/ssrsnoversion-md.md)] Web 门户、Report Server 或与 [!INCLUDE[ssRSnoversion](../../includes/ssrsnoversion-md.md)]集成的 SharePoint 站点来生成 Atom 服务文档和数据馈送。  
  
 Atom 应用于一对相关标准。 Atom 服务文档符合 RFC 5023 Atom 发布协议规范，数据馈送符合 RFC 4287 Atom 联合格式协议规范。  
  
 以下各节提供有关如何使用 Atom 呈现扩展插件的附加信息：  
  
 [!INCLUDE[ssRBRDDup](../../includes/ssrbrddup-md.md)]  
  
##  <a name="ReportDataAsDataFeeds"></a> 作为数据馈送的报表  
 可以将生产报表作为数据馈送导出，或者可以创建主要目的是以数据馈送的形式向应用程序提供数据的报表。 将报表用作数据馈送为您在以下情况下提供了另一种向应用程序提供数据的方式：当数据不易通过客户端数据访问接口访问时，或者您更喜欢隐藏数据源的复杂性以使数据的使用更为简便时。 还可以使用 [!INCLUDE[ssRSnoversion](../../includes/ssrsnoversion-md.md)] 功能（如安全、计划和报表快照）管理用来提供数据馈送的报表，这是将报表用作数据馈送的另一个优点。  
  
 若要充分利用 Atom 呈现扩展插件，您应该理解报表是如何呈现到数据馈送中的。 如果使用现有报表，则若能预测这些报表能够生成的数据馈送将很有用；如果编写报表的目的是专门用作数据馈送，则重要的是能够包括数据并优化报表布局以充分利用数据馈送。  
  
 有关详细信息，请参阅[从报表生成数据馈送（报表生成器和 SSRS）](../../reporting-services/report-builder/generate-data-feeds-from-a-report-report-builder-and-ssrs.md)。  
  
  
##  <a name="AtomServiceDocument"></a> Atom 服务文档（.atomsvc 文件）  
 Atom 服务文档指定针对一个或多个数据馈送的连接。 该连接至少是指向生成馈送的数据服务的简单 URL。  
  
 使用 Atom 呈现扩展插件呈现报表数据时，Atom 服务文档将列出可用于报表的数据馈送。 该文档为报表中的每个数据区域至少列出一个数据馈送。 表和仪表都只生成一个数据馈送；但矩阵、列表和图表可能生成多个数据馈送，具体取决于它们所显示的数据。  
  
 下图显示了使用两个表和一个图表的报表。  
  
 ![RS_Atom_TableAndChartDataFeeds](../../reporting-services/report-builder/media/rs-atom-tableandchartdatafeeds.gif "RS_Atom_TableAndChartDataFeeds")  
  
 从此报表生成的 Atom 服务文档包括三个数据馈送：两个表各对应一个数据馈送，图表对应一个数据馈送。  
  
 矩阵数据区域可能包括多个数据馈送，这取决于该矩阵的结构。 下图显示的报表使用生成两个数据馈送的矩阵。  
  
 ![RS_Atom_PeerDynamicColumns](../../reporting-services/report-builder/media/rs-atom-peerdynamiccolumns.gif "RS_Atom_PeerDynamicColumns")  
  
 从此报表生成的 Atom 服务文档包括两个数据馈送：两个动态对等列（Territory 和 Year）各对应一个数据馈送。 下图显示了每个数据馈送的内容。  
  
 ![RS_Atom_PeerDynamicDataFeeds](../../reporting-services/report-builder/media/rs-atom-peerdynamicdatafeeds.gif "RS_Atom_PeerDynamicDataFeeds")  
  
  
##  <a name="DataFeeds"></a> 数据馈送  
 数据馈送是一个 XML 文件，它具有一致的不随时间变化的表格格式，以及在每次运行报表时都可能不同的可变数据。 [!INCLUDE[ssRSnoversion](../../includes/ssrsnoversion-md.md)] 生成的数据馈送采用与 ADO.NET Data Services 生成的数据馈送相同的格式。  
  
 数据馈送包含两部分：标题和数据。 Atom 规范中定义了各部分中的元素。 标题包括用于数据馈送的字符编码架构之类的信息。  
  
### <a name="header-section"></a>标题部分  
 以下 XML 代码显示数据馈送的标题部分。  
  
 `<?xml version="1.0" encoding="utf-8" standalone="yes"?><feed xmlns:d="http://schemas.microsoft.com/ado/2007/08/dataservices" xmlns:m="http://schemas.microsoft.com/ado/2007/08/dataservices/metadata" xmlns="http://www.w3.org/2005/Atom">`  
  
 `<title type="text"></title>`  
  
 `<id>uuid:1795992c-a6f3-40ec-9243-fbfd0b1a5be3;id=166321</id>`  
  
 `<updated>2009-05-08T23:09:58Z</updated>`  
  
### <a name="data-section"></a>数据部分  
 数据馈送的数据部分为 Atom 呈现扩展插件生成的平展行集中的每一行都包含一个 \<entry> 元素。  
  
 下图显示了使用组和总计的报表。  
  
 ![RS_Atom_ProductSalesSummaryCircledValues](../../reporting-services/report-builder/media/rs-atom-productsalessummarycircledvalues.gif "RS_Atom_ProductSalesSummaryCircledValues")  
  
 下面的 XML 在数据馈送中显示了来自该报表的 \<entry> 元素。 请注意，\<entry> 元素包含该组的销售和订单的总计以及所有组的销售和订单的总计。 \<entry> 元素包含报表中的所有值。  
  
 `<entry><id>uuid:1795992c-a6f3-40ec-9243-fbfd0b1a5be3;id=166322</id><title type="text"></title><updated>2009-05-08T23:09:58Z</updated><author /><content type="application/xml"><m:properties>`  
  
 `<d:ProductCategory_Value>Accessories</d:ProductCategory_Value>`  
  
 `<d:OrderYear_Value m:type="Edm.Int32">2001</d:OrderYear_Value>`  
  
 `<d:SumLineTotal_Value m:type="Edm.Decimal">20235.364608</d:SumLineTotal_Value>`  
  
 `<d:SumOrderQty_Value m:type="Edm.Int32">1003</d:SumOrderQty_Value>`  
  
 `<d:SumLineTotal_Total_2_1 m:type="Edm.Decimal">1272072.883926</d:SumLineTotal_Total_2_1>`  
  
 `<d:SumOrderQty_Total_2_1 m:type="Edm.Double">61932</d:SumOrderQty_Total_2_1>`  
  
 `<d:SumLineTotal_Total_2_2 m:type="Edm.Decimal">109846381.399888</d:SumLineTotal_Total_2_2>`  
  
 `<d:SumOrderQty_Total_2_2 m:type="Edm.Double">274914</d:SumOrderQty_Total_2_2></m:properties></content>`  
  
 `</entry>`  
  
### <a name="working-with-data-feeds"></a>使用数据馈送  
 由报表生成的所有数据馈送都包括生成数据馈送的数据区域父级范围内的报表项。 集成的 SharePoint 站点来生成 Atom 服务文档和数据馈送。 设想有一个报表包含若干表和一个图表。 报表正文中的文本框提供有关每个数据区域的说明性文本。 该报表生成的每个数据馈送中的每个条目都包括该文本框的值。 例如，如果文本为“Chart displays monthly sales averages by sales region”，则所有三个数据馈送都会在每一行中包括此文本。  
  
 如果报表布局包括分层数据关系，如嵌套数据区域，这些关系将包括在报表数据的平展行集中。  
  
 嵌套数据区域的数据行通常较宽，特别是在嵌套表和矩阵包括组和总计的情况下。 您可能会发现，将报表导出到数据馈送并且查看数据馈送以确定生成的数据就是所需数据，这会很有帮助。  
  
 当 Atom 呈现扩展插件创建 Atom 服务文档时，将为数据馈送创建一个唯一标识符，在 URL 中使用该标识符可以查看数据馈送的内容。 示例 Atom 服务文档（如上所示）包括 URL `http://ServerName/ReportServer?%2fProduct+Sales+Summary&rs%3aCommand=Render&rs%3aFormat=ATOM&rc%3aDataFeed=xAx0x1`。 该 URL 标识报表 (Product Sales Summary)、Atom 呈现格式 (ATOM) 以及数据馈送的名称 (xAx0x1)。  
  
 报表项名称默认为报表项的报表定义语言 (RDL) 元素名称，这些名称经常较为直观或容易记忆。 例如，放入报表的第一个矩阵的默认名称为 Tablix 1。 数据馈送使用这些名称。  
  
 若要令数据馈送易于使用，可以使用数据区域的 DataElementName 属性来提供友好名称。 如果为 DataElementName 提供值，数据馈送子元素 \<d> 将使用该值，而不是使用默认的数据区域名称。 例如，如果数据区域的默认名称为 Tablix1，而 DataElementName 设置为 SalesByTerritoryYear，则数据馈送中的 \<d> 将使用 SalesByTerritoryYear。 如果数据区域具有两个数据馈送（类似上述矩阵报表），则数据馈送中使用的名称为 SalesByTerritoryYear _Territory 和 SalesByTerritoryYear _Year。  
  
 如果对报表显示的数据和数据馈送中的数据进行比较，则可能发现一些差异。 报表经常显示格式化的数值和时间/日期数据，但数据馈送包含非格式化的数据。  
  
 数据馈送用 .atom 文件扩展名保存。 可以使用文本或 XML 编辑器（如记事本或 XML 编辑器）来查看文件结构和内容。  
  
  
##  <a name="FlatteningReportData"></a> 平展报表数据  
 Atom 呈现器将报表数据提供为 XML 格式的平展行集。 用于平展数据表的规则与用于 CSV 呈现器的规则相同，只有以下几点例外：  
  
-   范围中的项平展到详细信息级别。 不同于 CSV 呈现器，顶级文本框显示在写入数据馈送的每个条目中。  
  
-   在输出的每一行上呈现报表参数值。  
  
 分层数据和分组数据必须进行平展才能以与 Atom 兼容的格式表示。 呈现扩展插件可将报表平展为用于表示数据区域中嵌套组的树结构。 要平展报表：  
  
-   行层次结构在列层次结构之前进行平展。  
  
-   行层次结构的成员在列层次结构的成员之前呈现到数据馈送。  
  
-   列按照以下顺序排序：表体中的文本框的顺序为从左到右，从上到下，后面紧跟数据区域，后者顺序为从左到右，从上到下。  
  
-   在数据区域中，列按照以下顺序排序：角成员、行层次结构成员、列层次结构成员，然后是单元。  
  
-   对等数据区域是一些共享一个公共数据区域或动态祖先的数据区域或动态组。 对等数据通过平展后的树的分支进行标识。  
  
 有关详细信息，请参阅 [表、矩阵和列表（报表生成器和 SSRS）](../../reporting-services/report-design/tables-matrices-and-lists-report-builder-and-ssrs.md)。  
  
  
##  <a name="AtomRendering"></a> Atom 呈现规则  
 Atom 呈现扩展插件在呈现数据馈送时忽略以下信息：  
  
-   格式设置和布局  
  
-   页眉  
  
-   页脚  
  
-   自定义报表项  
  
-   矩形  
  
-   线条  
  
-   映像  
  
-   自动小计  
  
 对其余的报表项进行排序，先从上到下排，再从左到右排。 之后，每一项将呈现到一列中。 如果报表有嵌套数据项（如列表或表），则会在每一行中重复它的父项。  
  
 下表说明了呈现报表项时这些报表项的外观：  
  
|项|呈现行为|  
|----------|------------------------|  
|表|呈现方式为扩展该表，在只保留最起码的格式的情况下为每一行和每一列都分别创建行和列。 小计行和小计列没有列标题或行标题。 不支持钻取报表。|  
|矩阵|呈现方式为扩展该矩阵，在只保留最起码的格式的情况下为每一行和每一列都分别创建行和列。 小计行和小计列没有列标题或行标题。|  
|列表|为列表中每一明细行或实例呈现一个记录。|  
|子报表|对于内容的每个实例，都会重复它的父项。|  
|图表|为每个图表值呈现具有所有图表标签的记录。 来自系列和类别的标签采用平展的层次结构，并包含在图表值的行中。|  
|数据条|像图表一样呈现。 通常，数据条并不包括层次结构或标签。|  
|迷你图|像图表一样呈现。 通常，迷你图并不包括层次结构或标签。|  
|测量|作为单个记录呈现，具有线性刻度的最小值和最大值、范围的起始和终止值，以及指针的值。|  
|指示器|作为单个记录呈现，具有活动状态名称、可用状态以及数据值。|  
|地图|为每个地图数据区域生成数据馈送。 如果多个地图层使用相同数据区域，数据馈送将包含所有层的数据。 该数据馈送包含一个记录，该记录包含地图层的每个地图成员的标签和值。|  
  
  
##  <a name="DeviceInfo"></a> 设备信息设置  
 您可以更改此呈现器的某些默认设置，包括要使用的编码架构。 有关详细信息，请参阅 [ATOM Device Information Settings](../../reporting-services/atom-device-information-settings.md)。  

## <a name="next-steps"></a>后续步骤

[导出到 CSV 文件](../../reporting-services/report-builder/exporting-to-a-csv-file-report-builder-and-ssrs.md)   
[导出报表](../../reporting-services/report-builder/export-reports-report-builder-and-ssrs.md)  

更多疑问？ [请访问 Reporting Services 论坛](http://go.microsoft.com/fwlink/?LinkId=620231)

namespace backend\assets;

use yii\web\AssetBundle;

/**
 * @author Qiang Xue <qiang.xue@gmail.com>
 * @since 2.0
 */
class AppAsset extends AssetBundle {

    public $basePath = '@webroot';
    public $baseUrl = '@web';
    public $css = [
        'css/AdminLTE.min.css',
        'css/font-awesome.min.css',
        'css/skins/_all-skins.min.css',
        'css/bootstrap3-wysihtml5.min.css',
        'css/morris.css',
        'css/css.css',
    ];
    public $js = [
        'js/library/jquery-ui.min.js',
        'js/library/morris.min.js',
        'js/library/jquery.slimscroll.min.js',
        'js/library/popup/ejs.js',
        'js/library/popup/tmpl.js',
        'js/library/popup/popup.js',
        'js/library/popup/ajax.js',
        'js/library/fastclick.min.js',
        'js/library/bootstrap.min.js',
        'js/library/bootstrap3-wysihtml5.all.min.js',
        'js/library/base64.js',
        'js/library/textutils.js',
        'js/layout/app.min.js',
        'js/layout/demo.js',
        'js/dev/administrator.js',
        'js/dev/main.js',
        'js/dev/image.js',
        'js/dev/items.js',
        'js/dev/auth.js',
        'js/dev/itemscate.js',
        'js/dev/property.js',
        'js/dev/hotdeal.js',
        'js/dev/search.js',
    ];
    public $depends = [
        'yii\web\YiiAsset',
        'yii\bootstrap\BootstrapAsset',
    ];

}
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import datetime as dt

from main_functions import readFile, getData, plotGraph

gpppath = 'all_daily_model_results'
region = 'WI'
site = 'BRW'
start_date = dt.datetime.strptime('2017-01-01', '%Y-%m-%d')   #2017-01-01
end_date = dt.datetime.strptime('2017-12-29', '%Y-%m-%d')   #2017-12-29

doing_GPP = True    #whether or not we're plotting GPP or one of the other variables

mygpp = pd.read_csv("all_daily_model_results.csv", sep=',', skiprows=[1], parse_dates=['year', 'solar_date'], dtype={'GPP':np.float64, 'GPP_lower':np.float64,
                                                                        'GPP_upper':np.float64, 'ER':np.float64, 'ER_lower':np.float64,
                                                                        'ER_upper':np.float64, 'K600':np.float64, 'K600_lower':np.float64,
                                                                        'K600_upper':np.float64}, na_values=['\\N'])
mygpp = mygpp.loc[(mygpp['region']==region) & (mygpp['site']==site)]
mygpp = mygpp.loc[(mygpp['solar_date'] >= start_date) & (mygpp['solar_date'] <= end_date)]
mygpp = mygpp[['solar_date','GPP']]
mygpp.columns = ['DateTime_UTC','value']
READINGS = len(mygpp['value'])      #number of readings of gpp from river! from OC is 687
FRAMESIZE = 1          #how slow we're going through, when one, we go 1frame/0.1sec
#optimal frame for discharge (lightning and pinknoises) is 20 (1frame/2sec)
#for all others, frame=1 is great

path = region + '_' + site + '_' + "sensorData"
variable = "DO_mgL"

myfile = pd.read_csv('csv_files/' + 'Complete_Sensor_Data/' + path + '.csv', sep=',')
myfile['DateTime_UTC'] = pd.to_datetime(myfile['DateTime_UTC'], format='%Y-%m-%d %H:%M:%S')
myfile['value'] = pd.to_numeric(myfile['value'])
myfile = myfile.loc[(myfile['DateTime_UTC'] >= start_date) & (myfile['DateTime_UTC'] <= end_date)]
myfile = myfile.loc[myfile['variable'] == variable]
myfile = myfile[['DateTime_UTC','value']]

myvalues = pd.DataFrame()
skipby = 1

if(doing_GPP):
    myvalues = mygpp
    variable = 'GPP'
    skipby = 1
else:
    myvalues = myfile
    skipby = myvalues.size / READINGS * FRAMESIZE


title = region + ', ' + site + ', ' + variable
y = np.array(myvalues['value'])
x = np.array(myvalues['DateTime_UTC'])
varplot = pd.DataFrame(y,x)

Writer = animation.writers['ffmpeg']
writer = Writer(fps=10, metadata=dict(artist='Me'), bitrate=1800)

fig = plt.figure(figsize=(10,6))
plt.title(title)
plt.plot_date(x,y)
plt.xlabel(variable)
plt.ylabel('Time Stamp')
plt.title(variable + ' over time', fontsize=22)

#plt.clf()

#def init():
#    scat.set_offsets([])
#    return scat

def animate(i):
    data = myvalues.iloc[:int((i+1) * skipby)] #select data range
    p = sns.lineplot(x=data['DateTime_UTC'], y=data['value'], data=data, color="r")
    p.tick_params(labelsize=17)
    plt.setp(p.lines,linewidth=7)

#def animate(i):
#    data = np.hstack((x[:i,np.newaxis], y[:i, np.newaxis]))
#    scat.set_offsets(data)
#    return scat

#init_func=init,
ani = matplotlib.animation.FuncAnimation(fig, animate, frames=int(READINGS/FRAMESIZE),
                               interval=100, blit=False, repeat=True)

ani.save('mp4_files/' + region + '_' + site + '_' + variable + '_animation.mp4', writer=writer)

# ἐπίνοια -ας, ἡ

<!-- Status: S2=NeedsEdits -->
<!-- Lexica used for edits:   -->

## Word data

* Strongs: G19630

* Alternate spellings:



* Principle Parts: 


* Part of speech: 


* Instances in Scripture: 1

* All Scriptures cited: Yes

## Etymology: 

[ἐπινοέω](), to contrive

* LXX/Hebrew glosses: 


* Time Period/Ancient Authors: 


* Related words: 

* Antonyms for all senses

* Synonyms for all senses: 


## Senses 


### Sense  1.0: 

#### Definition: 

#### Glosses: 

a thought, design; 

#### Explanation: 


#### Citations: 

a thought, design: [Ac 8:22](Act 8:22).†

#include <debug.h>
#include <arch.h>
#include <arch/ops.h>
#include <arch/arm64.h>
#include <arch/arm64/mmu.h>
#include <platform.h>

void arch_early_init(void)
{
    /* set the vector base */
    ARM64_WRITE_SYSREG(VBAR_EL1, (uint64_t)&arm64_exception_base);

    /* switch to EL1 */
    unsigned int current_el = ARM64_READ_SYSREG(CURRENTEL) >> 2;
    if (current_el > 1) {
        arm64_el3_to_el1();
    }

    platform_init_mmu_mappings();
}

void arch_init(void)
{
}

void arch_quiesce(void)
{
}

void arch_idle(void)
{
    __asm__ volatile("wfi");
}

void arch_chain_load(void *entry, ulong arg0, ulong arg1, ulong arg2, ulong arg3)
{
    PANIC_UNIMPLEMENTED;
}
<!DOCTYPE HTML>
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%>
<%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags"%>

<html lang="en" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"><head>

	<!-- common -->
	<title>Heatbud | Social Blogging for Bloggers and Businesses</title>
	<meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
	<link rel="alternate" type="application/rss+xml" href="https://www.heatbud.com/do/rss" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<!-- icons -->
	<link rel="shortcut icon" href="/resources/images/favicon.ico" type="image/x-icon"/>
    <link rel="apple-touch-icon" href="/resources/images/apple-touch-icon.png"/>
	<link rel="apple-touch-icon" sizes="152x152" href="/resources/images/apple-touch-icon-152x152.png"/>
	<link rel="apple-touch-icon" sizes="144x144" href="/resources/images/apple-touch-icon-144x144.png"/>
	<link rel="apple-touch-icon" sizes="120x120" href="/resources/images/apple-touch-icon-120x120.png"/>
	<link rel="apple-touch-icon" sizes="114x114" href="/resources/images/apple-touch-icon-114x114.png"/>
	<link rel="apple-touch-icon" sizes="76x76" href="/resources/images/apple-touch-icon-76x76.png"/>
	<link rel="apple-touch-icon" sizes="72x72" href="/resources/images/apple-touch-icon-72x72.png"/>
	<link rel="apple-touch-icon" sizes="57x57" href="/resources/images/apple-touch-icon-57x57.png"/>
    <link rel="apple-touch-icon-precomposed" href="/resources/images/apple-touch-icon-76x76.png">
    <link rel="icon" sizes="32x32" href="/resources/images/favicon.ico">
    <meta name="msapplication-TileColor" content="#d3ede7">
	<meta name="msapplication-TileImage" content="/resources/images/apple-touch-icon-114x114.png">

	<!-- for Open Graph (facebook) -->
	<meta property="og:type" content="website"/>
	<meta property="og:title" content="Heatbud | Social Blogging for Businesses"/>
    <meta property="og:description" content="Create Social Blog for your business starting $29 a month. OR, Add Social Blogging to your Business starting $29 a month!"/>
	<meta property="og:url" content="https://www.heatbud.com/top/posts-trending-now"/>
	<meta property="og:image" content="https://www.heatbud.com/resources/images/fb-share-picture.png"/>
	<meta property="og:site_name" content="Heatbud"/>
	<meta property="fb:app_id" content="1444142922465514"/>

	<!-- for Google -->
    <meta name="description" content="Heatbud helps you write sophisticated posts and share them with the world instantly."/>
    <meta name="keywords" content="Social Blogging, Blogging, Business Website, Business, Website, Business Traffic, Traffic"/>
	<meta name="application-name" content="Heatbud"/>
	<link rel="publisher" href="https://plus.google.com/+Heatbud"/>
	<link rel="canonical" href="https://www.heatbud.com/top/posts-trending-now"/>

	<!-- JS includes -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script src="/resources/js/heatbud-top-charts-min.js?20180530"></script>

    <!-- CSS includes -->
	<link type='text/css' rel='stylesheet' href="https://fonts.googleapis.com/css?family=Arvo%7CDroid+Sans+Mono%7CFauna+One%7CImprima%7CLato%7CMarvel%7COffside%7COpen+Sans%7COxygen+Mono%7CPermanent+Marker%7CRaleway%7CRoboto+Mono%7CScope+One%7CText+Me+One%7CUbuntu">
	<link type="text/css" href="/resources/css/main-min.css?20180530" media="screen" rel="stylesheet"/>

</head><body style="position:relative; background-color:rgb(248, 250, 252)">

	<%-- Begin pretty number --%>
	<script>
	function prettyNumber(n) {
		if ( n < 1000 ) {
			return n;
		} else if ( n >= 1000 && n < 1000000 ) {
			return Math.round(n*10/1000)/10+'k';
		} else {
			return Math.round(n*10/1000000)/10+'m';
		}
	}
	</script>
	<%-- End pretty number --%>

	<%-- Begin header --%>
	<table class="header"><tr style="width:100%">
		<td style="float:left">
			<a href="/"><img alt="Heatbud logo" style="width:140px; padding-top:2px; margin-left:20px; border:none" src="/resources/images/heatbud-logo.png"/></a>
		</td>
		<td style="float:right; font-size:13px; padding-top:14px; padding-bottom:6px">
			<div style="float:left; margin-right:8px"><a href="/top/posts-trending-now" class="mainSelection">TOP CHARTS</a></div>
			<div style="float:left; margin-right:8px"><a href="/post/singing-bowls-singing-bowls-and-chakras" class="mainSelection">BLOG POSTS</a></div>
			<div style="float:left; margin-right:8px"><a href="/do/search" class="mainSelection">SEARCH</a></div>
			<div style="float:left; margin-right:8px"><a href="/do/help" class="mainSelection">HELP CENTER</a></div>
			<sec:authorize access="!isAuthenticated()">
				<div style="float:left"><a href="/do/login" class="mainSelection">LOGIN / SIGNUP</a></div>
			</sec:authorize>
			<sec:authorize access="isAuthenticated()">
				<div style="float:left; font-size:16px">
					<ul id="nav" style="margin-top:0px; margin-bottom:0px">
						<li>
							<span style="color:#ffffff; letter-spacing:1.5px"><sec:authentication property="principal.firstName"/> <sec:authentication property="principal.lastName"/> <img src="/resources/images/menu_header.png" style="padding-left:5px; height:15px"></span>
							<ul>
								<li><a href="/<sec:authentication property="principal.userId"/>" style="margin-top:10px; padding-top:10px">Profile</a></li>
								<li><a href="/user/settings" style="padding-top:10px">Settings</a></li>
								<li><a href="/user/notifications" style="padding-top:10px">Notifications</a></li>
								<li><a href="/user/pages" style="padding-top:10px">Page Manager</a></li>
								<li><a href="/user/orders" style="padding-top:10px">Orders</a></li>
								<li><a href="/user/images" style="padding-top:10px">Images</a></li>
								<li><a href="/user/posts" style="padding-top:10px">Unpublished Posts</a></li>
								<li><a href="<c:url value="/do/logout"/>" style="padding-top:10px">Logout</a></li>
								<li><a href="/user/drop" style="padding-top:10px; padding-bottom:30px">Drop Account</a></li>
							</ul>
						</li>
					</ul>
				</div>
			</sec:authorize>
		</td>
	</tr></table>
	<div style="clear:both"></div>
	<%-- End header --%>

	<%-- Begin page content --%>
	<input id=topChartsNameHidden type=hidden value="${topChartsName}">
	<input id=generateTopChartsJobPeriodHidden type=hidden value="${generateTopChartsJobPeriod}">

	<table style="border-spacing:2px; width:96%; padding-top:60px; margin-left:4%">

	<tr><td colspan="2">
		<%-- Social Blogging revolution --%>
		<div style="width:70%; background-color:#87bdd8; border-radius:4px; padding:10px 30px; margin:0 auto">
			<div style="color:yellow; font-size:1.8em">Join the Social Blogging revolution!</div>
			<div style="width:38%; float:left; color:white; font-size:1.6em">
				<div>For Bloggers</div>
				<div style="font-size:0.7em"><a style="color:white" href="/do/help/main/pricing">&bull; I want to earn followers</a></div>
				<div style="font-size:0.7em"><a style="color:white" href="/do/help/main/pricing">&bull; I want to earn money</a></div>
			</div>
			<div style="width:60%; float:left; color:white; font-size:1.6em">
				<div>For Businesses</div>
				<div style="font-size:0.7em"><a style="color:white" href="/do/help/main/why-1">&bull; I want to create a new website</a></div>
				<div style="font-size:0.7em"><a style="color:white" href="/do/help/main/why-1">&bull; I want to add Social Blog to my existing website</a></div>
			</div>
			<div style="clear:both"></div>
		</div>
	</td></tr>

	<tr><td style="width:65%; vertical-align:top">

		<%-- Page Title --%>
		<div style="float:right">
			<ul id="nav" style="z-index:3">
				<li>
					<div style="font-family:Calibri, Arial, Sans-serif; font-weight:bold; font-size:1.5em; background-color:#FD8A33; color:white; letter-spacing:3px; padding:3px 13px 7px 20px; border-radius:5px">
						<span>${pageTitle}</span>
						<span><img alt="top charts menu" src="/resources/images/menu.png" style="padding-left:8px; height:24px"></span>
					</div>
					<ul style="width:160px">
						<li style="padding-top:6px; padding-left:6px; font-weight:bold; color:#333333; margin-top:15px">TRENDING NOW</li>
						<li><div onclick="switchChart('posts-trending-now')" style="color:#0E8D9E; padding-top:6px; padding-left:12px; cursor:pointer">POSTS</div></li>
						<li><div onclick="switchChart('zones-trending-now')" style="color:#0E8D9E; padding-top:6px; padding-left:12px; cursor:pointer">ZONES</div></li>
						<li><div onclick="switchChart('bloggers-trending-now')" style="color:#0E8D9E; padding-top:6px; padding-left:12px; cursor:pointer">BLOGGERS</div></li>
						<li><div onclick="switchChart('pages-trending-now')" style="color:#0E8D9E; padding-top:6px; padding-left:12px; cursor:pointer">PAGES</div></li>
						<li style="padding-top:6px; padding-left:6px; font-weight:bold; color:#333333; margin-top:6px">ALL TIME</li>
						<li><div onclick="switchChart('posts-all-time')" style="color:#0E8D9E; padding-top:6px; padding-left:12px; cursor:pointer">POSTS</div></li>
						<li><div onclick="switchChart('bloggers-all-time')" style="color:#0E8D9E; padding-top:6px; padding-left:12px; cursor:pointer">BLOGGERS</div></li>
						<li><div onclick="switchChart('pages-all-time')" style="color:#0E8D9E; padding-top:6px; padding-left:12px; cursor:pointer">PAGES</div></li>
						<li style="padding-top:6px; padding-left:6px; font-weight:bold; color:#333333; margin-top:6px">JUST PUBLISHED</li>
						<li><div onclick="switchChart('posts-just-published')" style="color:#0E8D9E; padding-top:6px; padding-left:12px; margin-bottom:40px; cursor:pointer">POSTS</div></li>
					</ul>
				</li>
			</ul>
		</div>
		<div style="clear:both"></div>
	</td><td style="width:28%; vertical-align:top"></td></tr>

	<tr>
		<td style="width:65%; vertical-align:top; padding-right:11px">

			<div id="topChartsDiv">

				<%-- Top Charts for Posts --%>
				<c:if test="${fn:contains(topChartsName,'post')}">
					<c:forEach var="post" items="${topChartsList}" varStatus="loopStatus">
						<div class="topChartsElement" style="float:right">
							<div style="font-size:18px; font-weight:bold; padding:10px 20px">
								<a href="/post/${post.postId}">${post.postTitle}</a>
							</div>
							<div onclick="location.href='/post/${post.postId}'" class="topChartsThumb grow" style="margin:0 auto; background-image:url(${post.postHeadshot})"></div>
							<div style="font-size:15px; padding:10px 20px">
								<span style="font-size:13px; color:rgb(144, 144, 144)"> By </span>
								<span><a href="/${post.bloggerId}">${post.bloggerName}</a></span>
								<span style="font-size:13px; color:rgb(144, 144, 144)"> Zone </span>
								<span><a href="/zone/${post.zoneId}">${fn:escapeXml(post.zoneName)}</a></span>
							</div>
							<c:if test="${fn:contains(topChartsName,'just')}">
								<div style="padding:3px 20px; color:#8A8C8E"><script>document.write(new Date(${post.updateDate}).toLocaleString());</script></div>
							</c:if>
							<div style="padding:3px 20px">${post.postSummary}</div>
							<div style="padding:5px 20px">
								<img alt="Overall Heat Index" title="Overall Heat Index" style="width:14px; height:18px; border:none" src="/resources/images/favicon.ico"/>
								<span title="Overall Heat Index" style="color:#7A7C7E; font-size:17px"><script>document.write(prettyNumber(${post.hi}));</script></span>
								<c:if test="${fn:contains(topChartsName,'trending')}">
									<c:if test="${post.hiTrending >= 0}">
										<span><img alt="This week's change" title="This week's change" style="width:8px; height:8px; border:none; margin-left:10px" src="/resources/images/trending-up.png"></span>
										<span title="This week's change" style="color:#8A8C8E; font-size:10px">${post.hiTrending}</span>
									</c:if>
									<c:if test="${post.hiTrending < 0}">
										<span><img alt="This week's change" title="This week's change" style="width:8px; height:8px; border:none; margin-left:10px" src="/resources/images/trending-down.png"></span>
										<span title="This week's change" style="color:#8A8C8E; font-size:10px">${-post.hiTrending}</span>
									</c:if>
								</c:if>
							</div>
						</div>
						<c:if test="${loopStatus.index % 2 == 1}">
							<div style="clear:both"></div>
						</c:if>
					</c:forEach>
				</c:if>

				<%-- Top Charts for Zones --%>
				<c:if test="${fn:contains(topChartsName,'zone')}">
					<c:forEach var="zone" items="${topChartsList}" varStatus="loopStatus">
						<div class="topChartsElement" style="float:right">
							<div style="font-size:18px; font-weight:bold; padding:10px 20px">
								<a href="/zone/${zone.zoneId}">${zone.zoneName}</a>
							</div>
							<div onclick="location.href='/zone/${zone.zoneId}'" class="topChartsThumb grow" style="margin:0 auto; background-image:url(${zone.zoneHeadshot})"></div>
							<div style="padding:3px 20px">${zone.zoneDesc}</div>
							<div style="font-size:12px; color:#909090; padding:5px 20px">
								<span>${zone.posts} posts</span>
								<span style="font-weight:bold; color:rgb(144, 144, 144)">&nbsp;.&nbsp;</span>
								<span>${zone.comments} comments</span>
							</div>
						</div>
						<c:if test="${loopStatus.index % 2 == 1}">
							<div style="clear:both"></div>
						</c:if>
					</c:forEach>
				</c:if>

				<%-- Top Charts for entities (bloggers and pages) --%>
				<c:if test="${fn:contains(topChartsName,'blogger') || fn:contains(topChartsName,'page')}">
					<c:forEach var="entity" items="${topChartsList}"  varStatus="loopStatus">
						<div class="topChartsElement" style="float:right">
							<div style="font-size:18px; padding:10px 20px; font-weight:bold">
								<a href="/${entity.entityId}">${entity.entityName}</a>
							</div>
							<c:if test="${empty entity.profilePhoto}">
								<c:if test="${fn:contains(topChartsName,'blogger')}">
									<div onclick="location.href='/${entity.entityId}'" class="topChartsThumb grow" style="margin:0 auto; background-image:url('/resources/images/def-blogger-photo.jpg')"></div>
								</c:if>
								<c:if test="${fn:contains(topChartsName,'page')}">
									<div onclick="location.href='/${entity.entityId}'" class="topChartsThumb grow" style="margin:0 auto; background-image:url('/resources/images/def-page-photo.jpg')"></div>
								</c:if>
							</c:if>
							<c:if test="${not empty entity.profilePhoto}">
								<div onclick="location.href='/${entity.entityId}'" class="topChartsThumb grow" style="margin:0 auto; background-image:url('${entity.profilePhoto}')"></div>
							</c:if>
							<div style="padding:3px 20px; white-space:pre-line">${entity.about}</div>
							<div style="padding:3px 20px">
								<img alt="Overall Heat Index" title="Overall Heat Index" style="width:14px; height:18px; border:none" src="/resources/images/favicon.ico"/>
								<span title="Overall Heat Index" style="color:#7A7C7E; font-size:17px"><script>document.write(prettyNumber(${entity.hi}));</script></span>
								<c:if test="${fn:contains(topChartsName,'trending')}">
									<c:if test="${entity.hiTrending >= 0}">
										<span><img alt="This week's change" title="This week's change" style="width:8px; height:8px; border:none; margin-left:10px" src="/resources/images/trending-up.png"></span>
										<span title="This week's change" style="color:#8A8C8E; font-size:10px">${entity.hiTrending}</span>
									</c:if>
									<c:if test="${entity.hiTrending < 0}">
										<span><img alt="This week's change" title="This week's change" style="width:8px; height:8px; border:none; margin-left:10px" src="/resources/images/trending-down.png"></span>
										<span title="This week's change" style="color:#8A8C8E; font-size:10px">${-entity.hiTrending}</span>
									</c:if>
								</c:if>
							</div>
							<div style="font-size:12px; color:#909090; padding:5px 20px">
								<span>${entity.posts} posts</span>
								<span style="font-weight:bold; color:rgb(144, 144, 144)">&nbsp;.&nbsp;</span>
								<span>${entity.votes} votes</span>
								<span style="font-weight:bold; color:rgb(144, 144, 144)">&nbsp;.&nbsp;</span>
								<span>${entity.comments} comments</span>
							</div>
						</div>
						<c:if test="${loopStatus.index % 2 == 1}">
							<div style="clear:both"></div>
						</c:if>
					</c:forEach>
				</c:if>
			</div>

			<%-- Top Charts navigation --%>
			<div id="topChartsNavigation">
				<%-- previous page link will be hidden on the first page --%>
				<input type=hidden id=topChartsKeyPrevIdHidden value="NULL">
				<input type=hidden id=topChartsKeyPrevHIHidden value="NULL">
				<div id="getTopChartsPreviousDiv" style="width:45%; margin-top:10px; margin-left:15px; float:left; text-align:left; visibility:hidden">
					<a id="getTopChartsPrevious" class="topNextPrev" href="javascript:">BACK</a>
				</div>
				<%-- next page link will be set to visible if the key is not NULL --%>
				<input type=hidden id=topChartsKeyNextIdHidden value="${topChartsKeyNextId}">
				<input type=hidden id=topChartsKeyNextHIHidden value="${topChartsKeyNextHI}">
				<c:if test="${topChartsKeyNextId != 'NULL'}">
					<div id="getTopChartsNextDiv" style="width:45%; margin-top:10px; margin-right:56px; float:right; text-align:right">
						<a id="getTopChartsNext" class="topNextPrev" href="javascript:">MORE</a>
					</div>
				</c:if>
			</div>
			<div style="clear:both"></div>

		</td>
		<td style="width:28%; vertical-align:top">
			<%-- Facebook --%>
			<div class="friendFacebook" style="float:right">
				<a style="color:white" target="_blank" href="https://www.facebook.com/heatbud">Like us on Facebook</a>
			</div>
			<div style="clear:both"></div>
			<%-- Ticker --%>
			<div style="margin-top:10px; margin-bottom:5px; color:#797979; font-size:15px">Recent activity</div>
			<div style="border:1px solid #d1d1d1; padding:20px 10px 30px 20px; background-color:white">
				<c:forEach var="ticker" items="${tickersList}" varStatus="counter">
					<div style="margin-bottom:25px">
						<span style="color:#8A8C8E">&#9898;</span>
						<span style="color:#8A8C8E"><script>document.write(new Date(${ticker.tickerTime}).toLocaleString());</script></span><br/>
						<span>${ticker.tickerDesc}</span>
					</div>
				</c:forEach>
			</div>
		</td>

	</tr></table>

	<%-- Google Ads Horizontal --%>
	<div style="width:100%; text-align:center; margin-top:30px; margin-bottom:40px">
		<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
		<ins class="adsbygoogle"
		     style="display:inline-block;width:728px;height:90px"
		     data-ad-client="ca-pub-3344897177583439"
		     data-ad-slot="5851386905">
		</ins>
		<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
	</div>

	<%-- Begin footer --%>
	<div class="footer">
		<div style="float: right; margin-right: 40px">
			<a href="/top/posts-trending-now">Home</a>&nbsp;&nbsp;&nbsp;&nbsp;
			<a href="/do/help">Help Center</a>&nbsp;&nbsp;&nbsp;&nbsp;
			<a href="/do/privacy">Privacy &amp; Terms</a>&nbsp;&nbsp;&nbsp;&nbsp;
			<a href="/do/partnerships">Partnerships</a>&nbsp;&nbsp;&nbsp;&nbsp;
			<a href="/do/careers">Careers</a>&nbsp;&nbsp;&nbsp;&nbsp;
			<a href="/do/contact">Contact Us</a>&nbsp;&nbsp;&nbsp;&nbsp;
			<a href="/do/newsletters">Newsletters</a>
		</div>
	</div>
	<%-- End footer --%>

	<!-- Google analytics -->
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-48436913-1', 'heatbud.com');
	  ga('send', 'pageview');
	</script>

</body></html>
#include <time.h>

typedef int (*timer_gettime_test)(timer_t, struct itimerspec *);

int dummyfcn (void)
{
	timer_gettime_test dummyvar;
	dummyvar = timer_gettime;
	return 0;
}
﻿' Licensed to the .NET Foundation under one or more agreements.
' The .NET Foundation licenses this file to you under the MIT license.
' See the LICENSE file in the project root for more information.

Imports System.Composition
Imports System.Diagnostics.CodeAnalysis
Imports Microsoft.CodeAnalysis.CodeRefactorings
Imports Microsoft.CodeAnalysis.Text
Imports Microsoft.CodeAnalysis.VisualBasic.Syntax

Namespace Microsoft.CodeAnalysis.VisualBasic.InvertIf
    <ExportCodeRefactoringProvider(LanguageNames.VisualBasic, Name:=PredefinedCodeRefactoringProviderNames.InvertMultiLineIf), [Shared]>
    Friend NotInheritable Class VisualBasicInvertMultiLineIfCodeRefactoringProvider
        Inherits VisualBasicInvertIfCodeRefactoringProvider(Of MultiLineIfBlockSyntax)

        <ImportingConstructor>
        <SuppressMessage("RoslynDiagnosticsReliability", "RS0033:Importing constructor should be [Obsolete]", Justification:="Used in test code: https://github.com/dotnet/roslyn/issues/42814")>
        Public Sub New()
        End Sub

        Protected Overrides Function IsElseless(ifNode As MultiLineIfBlockSyntax) As Boolean
            Return ifNode.ElseBlock Is Nothing
        End Function

        Protected Overrides Function CanInvert(ifNode As MultiLineIfBlockSyntax) As Boolean
            Return ifNode.ElseIfBlocks.IsEmpty
        End Function

        Protected Overrides Function GetCondition(ifNode As MultiLineIfBlockSyntax) As SyntaxNode
            Return ifNode.IfStatement.Condition
        End Function

        Protected Overrides Function GetIfBody(ifNode As MultiLineIfBlockSyntax) As SyntaxList(Of StatementSyntax)
            Return ifNode.Statements
        End Function

        Protected Overrides Function GetElseBody(ifNode As MultiLineIfBlockSyntax) As SyntaxList(Of StatementSyntax)
            Return ifNode.ElseBlock.Statements
        End Function

        Protected Overrides Function UpdateIf(
                sourceText As SourceText,
                ifNode As MultiLineIfBlockSyntax,
                condition As SyntaxNode,
                trueStatement As SyntaxList(Of StatementSyntax),
                Optional falseStatementOpt As SyntaxList(Of StatementSyntax) = Nothing) As MultiLineIfBlockSyntax

            Dim updatedIf = ifNode _
                .WithIfStatement(ifNode.IfStatement.WithCondition(DirectCast(condition, ExpressionSyntax))) _
                .WithStatements(trueStatement)

            If falseStatementOpt.Count > 0 Then
                updatedIf = updatedIf.WithElseBlock(SyntaxFactory.ElseBlock(falseStatementOpt))
            End If

            Return updatedIf
        End Function
    End Class
End Namespace


;;; orary-rust.el --- Rust support for Orary
;;
;;; Commentary:
;; Maybe rust is nice? I'm unlikely to be able to tell if my editor isn't set up for it ;P
;;; Code:

(require 'orary-braces)
(require 'orary-functions)

(use-package cargo)         ;; Build tool wrapper
(use-package racer)         ;; Symbol completion, introspection
(use-package flycheck-rust) ;; Syntax checking

(defun orary/rust-ret-dwim (arg)
  (interactive "P")

  (cond
   ;; We're in a pair of {}, open them
   ((and (looking-at "}")
         (looking-back "{" (- (point) 2)))
    (orary/braces-open-pair))

   ;; We're opening a match; insert {}, open, then expand a yasnippet
   ((looking-back "match.*" (line-beginning-position))
    (sp-insert-pair "{")
    (orary/braces-open-pair)
    ;; NOTE[rdonaldson|2020-05-31] with LSP mode, it's often more ergonomic to
    ;; use an lsp action to fill in match arms. Reconsidering this; might gate
    ;; it behind C-u.
    ;; (yas-expand-snippet "$1 => $0,")
    )

   ;; We're defining an if/else, while, function, struct, enum, unsafe, or trait; insert {}, then open
   ((looking-back "if.*\\|else.*\\|while.*\\|fn .*\\|\\<impl\\>.*\\|trait.*\\|struct.*\\|enum.*\\|mod.*\\|for.*\\|unsafe.*\\|async.*" (line-beginning-position))
    (sp-insert-pair "{")
    (orary/braces-open-pair))

   ;; We're in a match expression
   ((looking-back "=>.*" (line-beginning-position))
    (end-of-line)
    ;; With a prefix arg, jump out of the match
    (if arg
        (progn
          (re-search-forward "}")
          (newline-and-indent))
      (progn
        (unless (looking-back "," (- (point) 1))
          (insert-char ?,))
        (newline-and-indent)
        (yas-expand-snippet "$1 => $0,"))))

   ;; Default: try to add a ; and newline
   (t
    (unless (eolp)
      (re-search-forward ")"))

    (unless (or (looking-at ";")
                (looking-back ";" (- (point) 1))
                (looking-back "^\\s-+" (line-beginning-position)))
      (insert-char ?\;))
    (end-of-line)
    (newline-and-indent))))

(defun orary/rust-insert-arrow ()
  (interactive)
  (orary/insert-key-seq "-" ">" "<")
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "-") #'orary/rust-insert-arrow)
     map)))

;; The Business
(use-package rust-mode
  :config
  (setq cargo-process--command-clippy "clippy")
  (add-hook 'rust-mode-hook
            (lambda ()
              (cargo-minor-mode +1)
              (subword-mode +1)
              (lsp)
              (flycheck-add-next-checker 'lsp 'rust-clippy)
              (setq comment-start "//")))

  (add-hook 'racer-mode-hook #'eldoc-mode)
  (add-hook 'racer-mode-hook #'company-mode)

  :bind (:map rust-mode-map
              ("C-c C-c" . #'rust-compile)
              ("<C-return>" . #'orary/rust-ret-dwim)
              ("C-o" . #'orary/braces-open-newline)
              ("-" . #'orary/rust-insert-arrow))
  )

(provide 'orary-rust)
;;; orary-rust.el ends here

<?php

namespace Tg\OkoaBundle\Response;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\ResponseHeaderBag;
use RuntimeException;

/**
 * Respond with the contents of a file.
 */
class FileResponse extends Response
{

    protected $disposition;

    protected $filename;

    protected $file;

    public function __construct($file, $attach = false, $filename = null)
    {
        parent::__construct(null, 200, [
            'Content-Type' => 'application/octet-stream'
        ]);
        if ($attach) {
            $this->setDispositionAttachment();
        } else {
            $this->setDispositionInline();
        }
        $this->setFile($file);
        $this->setFilename($filename);
        $this->setPrivate();
    }

    public function setContentType($type)
    {
        $this->headers->set('Content-Type', $type);
    }

    public function setDispositionAttachment()
    {
        $this->disposition = ResponseHeaderBag::DISPOSITION_ATTACHMENT;
        $this->updateProps();
    }

    public function setDispositionInline()
    {
        $this->disposition = ResponseHeaderBag::DISPOSITION_INLINE;
        $this->updateProps();
    }

    public function setFilename($name)
    {
        $this->filename = $name;
        $this->updateProps();
    }

    public function getFilesize()
    {
        if (is_string($this->file)) {
            return filesize($this->file);
        } else {
            fseek($this->file, 0, SEEK_END);
            $size = ftell($this->file);
            rewind($this->file);
            return $size;
        }
    }

    public function setFile($file, $determineType = true)
    {
        if (is_string($file)) {
            if (!file_exists($file) || !is_readable($file)) {
                throw new RuntimeException("Could not read file '$file'");
            }
        }
        $this->file = $file;
        if (is_string($file) && $determineType) {
            $this->tryDetermineType();
        }
        $this->updateProps();
    }

    public function tryDetermineType()
    {
        if (is_string($this->file) && strlen($this->file) > 0) {
            $finfo = finfo_open(FILEINFO_MIME_TYPE);
            $mime = finfo_file($finfo, $this->file);
            if (is_string($mime) && strlen($mime) > 0) {
                $this->setContentType($mime);
            }
            finfo_close($finfo);
        }
    }

    public function sendContent()
    {
        if (is_resource($this->file)) {
            $size = $this->getFilesize();
            rewind($this->file);
            print fread($this->file, $size);
        } else {
            readfile($this->file);
        }
    }

    protected function updateProps()
    {
        if (is_string($this->file) || is_resource($this->file)) {
            $disp = $this->disposition;
            if ($disp !== ResponseHeaderBag::DISPOSITION_INLINE && $this->filename !== null) {
                $disp .= '; filename=' . $this->filename;
            }
            $this->headers->set('Content-Disposition', $disp);
            $this->headers->set('Content-Length', $this->getFilesize());
        } else {
            $this->headers->remove('Content-Disposition');
            $this->headers->remove('Content-Length');
        }
    }
}

#include "includes.h"
#include "lib/util/dlinklist.h"
#include "smb_server/smb_server.h"
#include "smbd/service_stream.h"
#include "ntvfs/ntvfs.h"

struct socket_address *smbsrv_get_my_addr(void *p, TALLOC_CTX *mem_ctx)
{
	struct smbsrv_connection *smb_conn = talloc_get_type(p,
					     struct smbsrv_connection);

	return socket_get_my_addr(smb_conn->connection->socket, mem_ctx);
}

struct socket_address *smbsrv_get_peer_addr(void *p, TALLOC_CTX *mem_ctx)
{
	struct smbsrv_connection *smb_conn = talloc_get_type(p,
					     struct smbsrv_connection);

	return socket_get_peer_addr(smb_conn->connection->socket, mem_ctx);
}

/****************************************************************************
init the tcon structures
****************************************************************************/
static NTSTATUS smbsrv_init_tcons(struct smbsrv_tcons_context *tcons_ctx, TALLOC_CTX *mem_ctx, uint32_t limit)
{
	/* 
	 * the idr_* functions take 'int' as limit,
	 * and only work with a max limit 0x00FFFFFF
	 */
	limit &= 0x00FFFFFF;

	tcons_ctx->idtree_tid	= idr_init(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tcons_ctx->idtree_tid);
	tcons_ctx->idtree_limit	= limit;
	tcons_ctx->list		= NULL;

	return NT_STATUS_OK;
}

NTSTATUS smbsrv_smb_init_tcons(struct smbsrv_connection *smb_conn)
{
	return smbsrv_init_tcons(&smb_conn->smb_tcons, smb_conn, UINT16_MAX);
}

NTSTATUS smbsrv_smb2_init_tcons(struct smbsrv_session *smb_sess)
{
	return smbsrv_init_tcons(&smb_sess->smb2_tcons, smb_sess, UINT32_MAX);
}

/****************************************************************************
find a tcon given a tid for SMB
****************************************************************************/
static struct smbsrv_tcon *smbsrv_tcon_find(struct smbsrv_tcons_context *tcons_ctx,
					    uint32_t tid, struct timeval request_time)
{
	void *p;
	struct smbsrv_tcon *tcon;

	if (tid == 0) return NULL;

	if (tid > tcons_ctx->idtree_limit) return NULL;

	p = idr_find(tcons_ctx->idtree_tid, tid);
	if (!p) return NULL;

	tcon = talloc_get_type(p, struct smbsrv_tcon);
	if (!tcon) return NULL;

	tcon->statistics.last_request_time = request_time;

	return tcon;
}

struct smbsrv_tcon *smbsrv_smb_tcon_find(struct smbsrv_connection *smb_conn,
					 uint32_t tid, struct timeval request_time)
{
	return smbsrv_tcon_find(&smb_conn->smb_tcons, tid, request_time);
}

struct smbsrv_tcon *smbsrv_smb2_tcon_find(struct smbsrv_session *smb_sess,
					  uint32_t tid, struct timeval request_time)
{
	if (!smb_sess) return NULL;
	return smbsrv_tcon_find(&smb_sess->smb2_tcons, tid, request_time);
}

/*
  destroy a connection structure
*/
static int smbsrv_tcon_destructor(struct smbsrv_tcon *tcon)
{
	struct smbsrv_tcons_context *tcons_ctx;
	struct socket_address *client_addr;

	client_addr = socket_get_peer_addr(tcon->smb_conn->connection->socket, tcon);
	DEBUG(3,("%s closed connection to service %s\n",
		 client_addr ? client_addr->addr : "(unknown)",
		 tcon->share_name));

	/* tell the ntvfs backend that we are disconnecting */
	if (tcon->ntvfs) {
		ntvfs_disconnect(tcon->ntvfs);
		tcon->ntvfs = NULL;
	}

	if (tcon->smb2.session) {
		tcons_ctx = &tcon->smb2.session->smb2_tcons;
	} else {
		tcons_ctx = &tcon->smb_conn->smb_tcons;
	}

	idr_remove(tcons_ctx->idtree_tid, tcon->tid);
	DLIST_REMOVE(tcons_ctx->list, tcon);
	return 0;
}

/*
  find first available connection slot
*/
static struct smbsrv_tcon *smbsrv_tcon_new(struct smbsrv_connection *smb_conn,
					   struct smbsrv_session *smb_sess,
					   const char *share_name)
{
	TALLOC_CTX *mem_ctx;
	struct smbsrv_tcons_context *tcons_ctx;
	uint32_t handle_uint_max;
	struct smbsrv_tcon *tcon;
	NTSTATUS status;
	int i;

	if (smb_sess) {
		mem_ctx = smb_sess;
		tcons_ctx = &smb_sess->smb2_tcons;
		handle_uint_max = UINT32_MAX;
	} else {
		mem_ctx = smb_conn;
		tcons_ctx = &smb_conn->smb_tcons;
		handle_uint_max = UINT16_MAX;
	}

	tcon = talloc_zero(mem_ctx, struct smbsrv_tcon);
	if (!tcon) return NULL;
	tcon->smb_conn		= smb_conn;
	tcon->smb2.session	= smb_sess;
	tcon->share_name	= talloc_strdup(tcon, share_name);
	if (!tcon->share_name) goto failed;

	/*
	 * the use -1 here, because we don't want to give away the wildcard
	 * fnum used in SMBflush
	 */
	status = smbsrv_init_handles(tcon, handle_uint_max - 1);
	if (!NT_STATUS_IS_OK(status)) {
		DEBUG(1,("ERROR! failed to init handles: %s\n", nt_errstr(status)));
		goto failed;
	}

	i = idr_get_new_random(tcons_ctx->idtree_tid, tcon, tcons_ctx->idtree_limit);
	if (i == -1) {
		DEBUG(1,("ERROR! Out of connection structures\n"));
		goto failed;
	}
	tcon->tid = i;

	DLIST_ADD(tcons_ctx->list, tcon);
	talloc_set_destructor(tcon, smbsrv_tcon_destructor);

	/* now fill in some statistics */
	tcon->statistics.connect_time = timeval_current();

	return tcon;

failed:
	talloc_free(tcon);
	return NULL;
}

struct smbsrv_tcon *smbsrv_smb_tcon_new(struct smbsrv_connection *smb_conn, const char *share_name)
{
	return smbsrv_tcon_new(smb_conn, NULL, share_name);
}

struct smbsrv_tcon *smbsrv_smb2_tcon_new(struct smbsrv_session *smb_sess, const char *share_name)
{
	return smbsrv_tcon_new(smb_sess->smb_conn, smb_sess, share_name);
}
package fr.adrienbrault.idea.symfony2plugin.tests.intentions.yaml;

import fr.adrienbrault.idea.symfony2plugin.tests.SymfonyLightCodeInsightFixtureTestCase;
import org.jetbrains.yaml.YAMLFileType;

/**
 * @author Daniel Espendiller <daniel@espendiller.net>
 *
 * @see fr.adrienbrault.idea.symfony2plugin.intentions.yaml.YamlServiceTagIntention
 */
public class YamlServiceTagIntentionTest extends SymfonyLightCodeInsightFixtureTestCase {

    public void setUp() throws Exception {
        super.setUp();
        myFixture.configureFromExistingVirtualFile(myFixture.copyFileToProject("classes.php"));
    }

    protected String getTestDataPath() {
        return "src/test/java/fr/adrienbrault/idea/symfony2plugin/tests/intentions/yaml/fixtures";
    }

    public void testTagIntentionIsAvailable() {
        assertIntentionIsAvailable(
            YAMLFileType.YML,
            "services:\n" +
                "    foo:\n" +
                "        class: Foo<caret>\\Bar",
            "Symfony: Add Tags"
        );

        assertIntentionIsAvailable(
            YAMLFileType.YML,
            "services:\n" +
                "    foo:\n" +
                "        arguments: [Foo<caret>\\Bar] ",
            "Symfony: Add Tags"
        );
    }
}

/* istanbul ignore file */
/* istanbul ignore file */
import React from 'react';
import { Router } from 'react-router-dom';
import createHistory from 'history/createBrowserHistory';
import { Provider } from 'react-redux';
import { ToastProvider } from 'react-toast-notifications';

import Routes from './routes';
import store from "./store";

import Header from './components/Header';
import Footer from './components/Footer';
import GlobalStyles from './assets/styles/global';

function App () {

  const history = createHistory({
    basename: "",
    forceRefresh: false
  });

  return (
    <Provider store={store}>
      <Router history={history}>
        <GlobalStyles />
        <Header />
        <ToastProvider>
          <Routes />
        </ToastProvider>
        <Footer />
      </Router>
    </Provider>
  );
}

export default App;

package org.ping.apache.sqoop.mapreduce.db.rsync;

import java.sql.Timestamp;

public class TimeUtil {
	public static String getNowStamp() {
		Timestamp now = new Timestamp(System.currentTimeMillis());
		return getStamp(now);
	}

	public static String getStamp(Timestamp timestamp) {
		String stamp = timestamp.toString();
		stamp = stamp.replaceAll("-", "");
		stamp = stamp.replaceAll(":", "");
		stamp = stamp.replaceAll("\\.", "");
		stamp = stamp.replaceAll(" ", "");
		return stamp;
	}
}

import operator

import numpy as np
import numpy.core.umath_tests as ut

from utils.Quaternions import Quaternions


class Animation:
    """
    Animation is a numpy-like wrapper for animation data
    
    Animation data consists of several arrays consisting
    of F frames and J joints.
    
    The animation is specified by
    
        rotations : (F, J) Quaternions | Joint Rotations
        positions : (F, J, 3) ndarray  | Joint Positions
    
    The base pose is specified by
    
        orients   : (J) Quaternions    | Joint Orientations
        offsets   : (J, 3) ndarray     | Joint Offsets
        
    And the skeletal structure is specified by
        
        parents   : (J) ndarray        | Joint Parents
    """
    
    def __init__(self, rotations, positions, orients, offsets, parents):
        
        self.rotations = rotations
        self.positions = positions
        self.orients   = orients
        self.offsets   = offsets
        self.parents   = parents
    
    def __op__(self, op, other):
        return Animation(
            op(self.rotations, other.rotations),
            op(self.positions, other.positions),
            op(self.orients, other.orients),
            op(self.offsets, other.offsets),
            op(self.parents, other.parents))

    def __iop__(self, op, other):
        self.rotations = op(self.roations, other.rotations)
        self.positions = op(self.roations, other.positions)
        self.orients   = op(self.orients, other.orients)
        self.offsets   = op(self.offsets, other.offsets)
        self.parents   = op(self.parents, other.parents)
        return self
    
    def __sop__(self, op):
        return Animation(
            op(self.rotations),
            op(self.positions),
            op(self.orients),
            op(self.offsets),
            op(self.parents))
    
    def __add__(self, other): return self.__op__(operator.add, other)
    def __sub__(self, other): return self.__op__(operator.sub, other)
    def __mul__(self, other): return self.__op__(operator.mul, other)
    def __div__(self, other): return self.__op__(operator.div, other)
    
    def __abs__(self): return self.__sop__(operator.abs)
    def __neg__(self): return self.__sop__(operator.neg)
    
    def __iadd__(self, other): return self.__iop__(operator.iadd, other)
    def __isub__(self, other): return self.__iop__(operator.isub, other)
    def __imul__(self, other): return self.__iop__(operator.imul, other)
    def __idiv__(self, other): return self.__iop__(operator.idiv, other)
    
    def __len__(self): return len(self.rotations)
    
    def __getitem__(self, k):
        if isinstance(k, tuple):
            return Animation(
                self.rotations[k],
                self.positions[k],
                self.orients[k[1:]],
                self.offsets[k[1:]],
                self.parents[k[1:]]) 
        else:
            return Animation(
                self.rotations[k],
                self.positions[k],
                self.orients,
                self.offsets,
                self.parents) 
        
    def __setitem__(self, k, v): 
        if isinstance(k, tuple):
            self.rotations.__setitem__(k, v.rotations)
            self.positions.__setitem__(k, v.positions)
            self.orients.__setitem__(k[1:], v.orients)
            self.offsets.__setitem__(k[1:], v.offsets)
            self.parents.__setitem__(k[1:], v.parents)
        else:
            self.rotations.__setitem__(k, v.rotations)
            self.positions.__setitem__(k, v.positions)
            self.orients.__setitem__(k, v.orients)
            self.offsets.__setitem__(k, v.offsets)
            self.parents.__setitem__(k, v.parents)
        
    @property
    def shape(self): return (self.rotations.shape[0], self.rotations.shape[1])
            
    def copy(self): return Animation(
        self.rotations.copy(), self.positions.copy(), 
        self.orients.copy(), self.offsets.copy(), 
        self.parents.copy())
    
    def repeat(self, *args, **kw):
        return Animation(
            self.rotations.repeat(*args, **kw),
            self.positions.repeat(*args, **kw),
            self.orients, self.offsets, self.parents)
        
    def ravel(self):
        return np.hstack([
            self.rotations.log().ravel(),
            self.positions.ravel(),
            self.orients.log().ravel(),
            self.offsets.ravel()])
        
    @classmethod
    def unravel(clas, anim, shape, parents):
        nf, nj = shape
        rotations = anim[nf*nj*0:nf*nj*3]
        positions = anim[nf*nj*3:nf*nj*6]
        orients   = anim[nf*nj*6+nj*0:nf*nj*6+nj*3]
        offsets   = anim[nf*nj*6+nj*3:nf*nj*6+nj*6]
        return cls(
            Quaternions.exp(rotations), positions,
            Quaternions.exp(orients), offsets,
            parents.copy())
    
    
""" Maya Interaction """

def load_to_maya(anim, names=None, radius=0.5):
    """
    Load Animation Object into Maya as Joint Skeleton
    loads each frame as a new keyfame in maya.
    
    If the animation is too slow or too fast perhaps
    the framerate needs adjusting before being loaded
    such that it matches the maya scene framerate.
    
    
    Parameters
    ----------
    
    anim : Animation
        Animation to load into Scene
        
    names : [str]
        Optional list of Joint names for Skeleton
    
    Returns
    -------
    
    List of Maya Joint Nodes loaded into scene
    """
    
    import pymel.core as pm
    
    joints = []
    frames = range(1, len(anim)+1)
    
    if names is None: names = ["joint_" + str(i) for i in range(len(anim.parents))]
    
    for i, offset, orient, parent, name in zip(range(len(anim.offsets)), anim.offsets, anim.orients, anim.parents, names):
    
        if parent < 0:
            pm.select(d=True)
        else:
            pm.select(joints[parent])
        
        joint = pm.joint(n=name, p=offset, relative=True, radius=radius)
        joint.setOrientation([orient[1], orient[2], orient[3], orient[0]])
        
        curvex = pm.nodetypes.AnimCurveTA(n=name + "_rotateX")
        curvey = pm.nodetypes.AnimCurveTA(n=name + "_rotateY")
        curvez = pm.nodetypes.AnimCurveTA(n=name + "_rotateZ")  
        
        jrotations = (-Quaternions(orient[np.newaxis]) * anim.rotations[:,i]).euler()
        curvex.addKeys(frames, jrotations[:,0])
        curvey.addKeys(frames, jrotations[:,1])
        curvez.addKeys(frames, jrotations[:,2])
        
        pm.connectAttr(curvex.output, joint.rotateX)
        pm.connectAttr(curvey.output, joint.rotateY)
        pm.connectAttr(curvez.output, joint.rotateZ)
        
        offsetx = pm.nodetypes.AnimCurveTU(n=name + "_translateX")
        offsety = pm.nodetypes.AnimCurveTU(n=name + "_translateY")
        offsetz = pm.nodetypes.AnimCurveTU(n=name + "_translateZ")
        
        offsetx.addKeys(frames, anim.positions[:,i,0])
        offsety.addKeys(frames, anim.positions[:,i,1])
        offsetz.addKeys(frames, anim.positions[:,i,2])
        
        pm.connectAttr(offsetx.output, joint.translateX)
        pm.connectAttr(offsety.output, joint.translateY)
        pm.connectAttr(offsetz.output, joint.translateZ)
        
        joints.append(joint)
    
    return joints
    
def transforms_local(anim):
    """
    Computes Animation Local Transforms
    
    As well as a number of other uses this can
    be used to compute global joint transforms,
    which in turn can be used to compete global
    joint positions
    
    Parameters
    ----------
    
    anim : Animation
        Input animation
        
    Returns
    -------
    
    transforms : (F, J, 4, 4) ndarray
    
        For each frame F, joint local
        transforms for each joint J
    """
    
    transforms = anim.rotations.transforms()
    transforms = np.concatenate([transforms, np.zeros(transforms.shape[:2] + (3, 1))], axis=-1)
    transforms = np.concatenate([transforms, np.zeros(transforms.shape[:2] + (1, 4))], axis=-2)
    transforms[:,:,0:3,3] = anim.positions
    transforms[:,:,3:4,3] = 1.0
    return transforms

    
def transforms_multiply(t0s, t1s):
    """
    Transforms Multiply
    
    Multiplies two arrays of animation transforms
    
    Parameters
    ----------
    
    t0s, t1s : (F, J, 4, 4) ndarray
        Two arrays of transforms
        for each frame F and each
        joint J
        
    Returns
    -------
    
    transforms : (F, J, 4, 4) ndarray
        Array of transforms for each
        frame F and joint J multiplied
        together
    """
    
    return ut.matrix_multiply(t0s, t1s)
    
def transforms_inv(ts):
    fts = ts.reshape(-1, 4, 4)
    fts = np.array(list(map(lambda x: np.linalg.inv(x), fts)))
    return fts.reshape(ts.shape)
    
def transforms_blank(anim):
    """
    Blank Transforms
    
    Parameters
    ----------
    
    anim : Animation
        Input animation
    
    Returns
    -------
    
    transforms : (F, J, 4, 4) ndarray
        Array of identity transforms for 
        each frame F and joint J
    """

    ts = np.zeros(anim.shape + (4, 4)) 
    ts[:,:,0,0] = 1.0; ts[:,:,1,1] = 1.0;
    ts[:,:,2,2] = 1.0; ts[:,:,3,3] = 1.0;
    return ts
    
def transforms_global(anim):
    """
    Global Animation Transforms
    
    This relies on joint ordering
    being incremental. That means a joint
    J1 must not be a ancestor of J0 if
    J0 appears before J1 in the joint
    ordering.
    
    Parameters
    ----------
    
    anim : Animation
        Input animation
    
    Returns
    ------
    
    transforms : (F, J, 4, 4) ndarray
        Array of global transforms for 
        each frame F and joint J
    """
    
    joints  = np.arange(anim.shape[1])
    parents = np.arange(anim.shape[1])
    locals  = transforms_local(anim)
    globals = transforms_blank(anim)

    globals[:,0] = locals[:,0]

    for i in range(1, anim.shape[1]):
        globals[:,i] = transforms_multiply(globals[:,anim.parents[i]], locals[:,i])

    return globals
    
    
def positions_global(anim):
    """
    Global Joint Positions
    
    Given an animation compute the global joint
    positions at at every frame
    
    Parameters
    ----------
    
    anim : Animation
        Input animation
        
    Returns
    -------
    
    positions : (F, J, 3) ndarray
        Positions for every frame F 
        and joint position J
    """
    
    positions = transforms_global(anim)[:,:,:,3]
    return positions[:,:,:3] / positions[:,:,3,np.newaxis]
    
""" Rotations """
    
def rotations_global(anim):
    """
    Global Animation Rotations
    
    This relies on joint ordering
    being incremental. That means a joint
    J1 must not be a ancestor of J0 if
    J0 appears before J1 in the joint
    ordering.
    
    Parameters
    ----------
    
    anim : Animation
        Input animation
        
    Returns
    -------
    
    points : (F, J) Quaternions
        global rotations for every frame F 
        and joint J
    """

    joints  = np.arange(anim.shape[1])
    parents = np.arange(anim.shape[1])
    locals  = anim.rotations
    globals = Quaternions.id(anim.shape)
    
    globals[:,0] = locals[:,0]
    
    for i in range(1, anim.shape[1]):
        globals[:,i] = globals[:,anim.parents[i]] * locals[:,i]
        
    return globals
    
def rotations_parents_global(anim):
    rotations = rotations_global(anim)
    rotations = rotations[:,anim.parents]
    rotations[:,0] = Quaternions.id(len(anim))
    return rotations
    
def rotations_load_to_maya(rotations, positions, names=None):
    """
    Load Rotations into Maya
    
    Loads a Quaternions array into the scene
    via the representation of axis
    
    Parameters
    ----------
    
    rotations : (F, J) Quaternions 
        array of rotations to load
        into the scene where
            F = number of frames
            J = number of joints
    
    positions : (F, J, 3) ndarray 
        array of positions to load
        rotation axis at where:
            F = number of frames
            J = number of joints
            
    names : [str]
        List of joint names
    
    Returns
    -------
    
    maxies : Group
        Grouped Maya Node of all Axis nodes
    """
    
    import pymel.core as pm

    if names is None: names = ["joint_" + str(i) for i in range(rotations.shape[1])]
    
    maxis = []
    frames = range(1, len(positions)+1)
    for i, name in enumerate(names):
    
        name = name + "_axis"
        axis = pm.group(
             pm.curve(p=[(0,0,0), (1,0,0)], d=1, n=name+'_axis_x'),
             pm.curve(p=[(0,0,0), (0,1,0)], d=1, n=name+'_axis_y'),
             pm.curve(p=[(0,0,0), (0,0,1)], d=1, n=name+'_axis_z'),
             n=name)
        
        axis.rotatePivot.set((0,0,0))
        axis.scalePivot.set((0,0,0))
        axis.childAtIndex(0).overrideEnabled.set(1); axis.childAtIndex(0).overrideColor.set(13)
        axis.childAtIndex(1).overrideEnabled.set(1); axis.childAtIndex(1).overrideColor.set(14)
        axis.childAtIndex(2).overrideEnabled.set(1); axis.childAtIndex(2).overrideColor.set(15)
    
        curvex = pm.nodetypes.AnimCurveTA(n=name + "_rotateX")
        curvey = pm.nodetypes.AnimCurveTA(n=name + "_rotateY")
        curvez = pm.nodetypes.AnimCurveTA(n=name + "_rotateZ")  
        
        arotations = rotations[:,i].euler()
        curvex.addKeys(frames, arotations[:,0])
        curvey.addKeys(frames, arotations[:,1])
        curvez.addKeys(frames, arotations[:,2])
        
        pm.connectAttr(curvex.output, axis.rotateX)
        pm.connectAttr(curvey.output, axis.rotateY)
        pm.connectAttr(curvez.output, axis.rotateZ)
        
        offsetx = pm.nodetypes.AnimCurveTU(n=name + "_translateX")
        offsety = pm.nodetypes.AnimCurveTU(n=name + "_translateY")
        offsetz = pm.nodetypes.AnimCurveTU(n=name + "_translateZ")
        
        offsetx.addKeys(frames, positions[:,i,0])
        offsety.addKeys(frames, positions[:,i,1])
        offsetz.addKeys(frames, positions[:,i,2])
        
        pm.connectAttr(offsetx.output, axis.translateX)
        pm.connectAttr(offsety.output, axis.translateY)
        pm.connectAttr(offsetz.output, axis.translateZ)
    
        maxis.append(axis)
        
    return pm.group(*maxis, n='RotationAnimation')   
    
""" Offsets & Orients """

def orients_global(anim):

    joints  = np.arange(anim.shape[1])
    parents = np.arange(anim.shape[1])
    locals  = anim.orients
    globals = Quaternions.id(anim.shape[1])
    
    globals[:,0] = locals[:,0]
    
    for i in range(1, anim.shape[1]):
        globals[:,i] = globals[:,anim.parents[i]] * locals[:,i]
        
    return globals

    
def offsets_transforms_local(anim):
    
    transforms = anim.orients[np.newaxis].transforms()
    transforms = np.concatenate([transforms, np.zeros(transforms.shape[:2] + (3, 1))], axis=-1)
    transforms = np.concatenate([transforms, np.zeros(transforms.shape[:2] + (1, 4))], axis=-2)
    transforms[:,:,0:3,3] = anim.offsets[np.newaxis]
    transforms[:,:,3:4,3] = 1.0
    return transforms
    
    
def offsets_transforms_global(anim):
    
    joints  = np.arange(anim.shape[1])
    parents = np.arange(anim.shape[1])
    locals  = offsets_transforms_local(anim)
    globals = transforms_blank(anim)

    globals[:,0] = locals[:,0]
    
    for i in range(1, anim.shape[1]):
        globals[:,i] = transforms_multiply(globals[:,anim.parents[i]], locals[:,i])
        
    return globals
    
def offsets_global(anim):
    offsets = offsets_transforms_global(anim)[:,:,:,3]
    return offsets[0,:,:3] / offsets[0,:,3,np.newaxis]
    
""" Lengths """

def offset_lengths(anim):
    return np.sum(anim.offsets[1:]**2.0, axis=1)**0.5
    
    
def position_lengths(anim):
    return np.sum(anim.positions[:,1:]**2.0, axis=2)**0.5
    
    
""" Skinning """
def skin(anim, rest, weights, mesh, maxjoints=4):
    full_transforms = transforms_multiply(
        transforms_global(anim), 
        transforms_inv(transforms_global(rest[0:1])))
    
    weightids = np.argsort(-weights, axis=1)[:,:maxjoints]
    weightvls = np.array(list(map(lambda w, i: w[i], weights, weightids)))
    weightvls = weightvls / weightvls.sum(axis=1)[...,np.newaxis]
    
    verts = np.hstack([mesh, np.ones((len(mesh), 1))])
    verts = verts[np.newaxis,:,np.newaxis,:,np.newaxis]
    verts = transforms_multiply(full_transforms[:,weightids], verts)    
    verts = (verts[:,:,:,:3] / verts[:,:,:,3:4])[:,:,:,:,0]

    return np.sum(weightvls[np.newaxis,:,:,np.newaxis] * verts, axis=2)


def load_from_network(translation, rotations, length, third_dimension=1, average_length=5, tanslation_scale=3):
    rotations = rotations.reshape((-1, 17, 4))
    length = length[0]
    rotations = rotations / np.repeat(np.expand_dims(np.sqrt(np.sum(np.square(rotations), axis=-1)), axis=-1), 4, axis=-1)
    rotations = Quaternions(rotations)
    scaling_factor = np.mean(length) / average_length
    length = length / scaling_factor
    translation = translation / scaling_factor / tanslation_scale
    positions = np.expand_dims(translation, axis=1)
    parents = [-1, 0, 1, 2, 0, 4, 5, 0, 7, 8, 9, 8, 11, 12, 8, 14, 15]
    offsets = np.zeros((17, 3))
    offsets[1, 0] = -length[0]
    offsets[4, 0] = length[0]
    offsets[2, third_dimension] = -length[1]
    offsets[5, third_dimension] = -length[1]
    offsets[3, third_dimension] = -length[2]
    offsets[6, third_dimension] = -length[2]
    offsets[7, third_dimension] = length[3]
    offsets[8, third_dimension] = length[4]
    offsets[9, third_dimension] = length[5]
    offsets[10, third_dimension] = length[6]    
    offsets[11, 0] = length[7]
    offsets[12, 0] = length[8]
    offsets[13, 0] = length[9]
    offsets[14, 0] = -length[7]
    offsets[15, 0] = -length[8]
    offsets[16, 0] = -length[9]
    return Animation(rotations, positions, Quaternions.id(0), offsets, np.array(parents))

---
date: '2018-01-26T19:28:52.259Z'
user_id: 865
user_name: OverthrowCPC
user_intro: |-
    打倒加拿大保守党
    ————
    名字含义：Overthrow 为“打倒”，CPC 为“加拿大保守党”（Conservative Party of Canada）。
    本人是个文盲，所有帖子均为软件随机生成，可随便转载不必署名，谢绝各种跨省、跨国、跨球行动。
user_avatar: >-
    /static/upload/thumb/small50-u-thumb-8652ad06054ab4de2b630c1433bcf39da043b3e0921.png
upvote: 36
downvote: 0
comments:
    - ''
    - ''
    - ''
    - ''
    - ''
    - ''
    - ''
    - ''
    - ''
    - ''
---

很多人意想不到的是：**中共自己安插在国府中的鼹鼠，大都是低级别的，真正高级别的鼹鼠，都是苏共安插进去的。当时国府的老大哥美国自己就浑身挂满苏联木马，国府中的苏共间谍，很多是美国推荐给国府的。**

（本文无意于给历史翻案，或者给国府的溃败寻找外在理由，目的在于提醒诸位历史爱好者，在美苏谍对于内战局势的影响是不可忽略的）

  

  

先偷懒搬运下我的另一个回答[《如何评价“麦卡锡主义”？》](https://pin-cong.com/p/25952/?s=26471)：  

上世纪 30 年代到 50 年初，美国政府被苏联红色间谍渗透得千疮百孔，就是 CIA ， FBI 这些组织都不能幸免。美国政府财政部、军工部门的高管，充斥着苏联间谍。甚至曼哈顿绝密工程，斯大林比杜鲁门了解的更清楚。这些在美苏谍极大影响了 40 年代美国的对华政策

一方面，早在二战期间，在美苏谍就在暗中破坏美国的对华（中华民国）援助。当时，美国国会通过的对华援助方案，被财政部的苏联间谍怀特（Harry Dexter White）暗中脱后腿。甚至后来内战期间滥发法币的始作俑者冀朝鼎，也是怀特推荐给国府的。

另一方面，内战期间的中共与苏联联手作戏表演给美国左派，营造一种苏联没有支援中共的假象。当时美国主政的是左派的民主党，只是简单的认为中国的内战不过是一次普通的改朝换代，并没有意识到苏联在背后的作用。来华调停的马歇尔甚至天真的认为美国对华（中华民国）援助导致了对中共的不公平，引起了中国人的反美情绪。如此种种，导致杜鲁门当局在 1946 年 8 月出台了对华武器禁运政策，虽然禁用政策在一年后被解除，但由于在美苏谍暗中作梗，直到国府迁台前美援并未起到太大作用。

直到中国大陆易手之后，当时左派掌握话语权的美国仍然没有对此事予以充分重视，杜鲁门当局屡屡以国府贪腐为借口来掩盖自己援华不力外加防共无能的事实，甚至已经准备放弃迁台后的国府。

韩战爆发之后，参议员麦卡锡重提苏谍渗透问题，美国左派才意识到之前的对华政策可能被苏联间谍误导了，FBI 局长胡佛之前曾警告的问题也得以被摆到国会议程上，但为时已晚。此时，FBI 凭借“维诺那计划”（Venona Project）之前已经查到的线索确定当初在政界破坏美国援华的那些高级官员是奉命行事的苏联间谍，白宫才终于把中国大陆内战爆发以来的事情和韩战整合在一起。

  

关于在美苏谍误导美国对华政策的话题，详见[《美国为何没在国共内战的时候全力支持国民政府？ - 知乎》](https://www.zhihu.com/question/20255728/answer/178205685)（[防删备份](https://archive.is/tSFXe)）。

关于苏联在中国内战期间起的作用，推荐阅读：

《大棋局中的国共关系》社科院的吕迅著，此书为近年来研究国共内战的新作（2015出版），基于最新解密档案写成的（顺便跪求该书的电子版）。

《朝鲜支援东北解放战争纪实》中国学者吕明辉著。

  

**（未完待续，关于国府中苏联间谍的情况，需要查很多资料，有时间我会慢慢补充）**

/// <reference types="react" />
declare const MessageBoxUI_base: (new (..._: any[]) => import("react-vextensions").BaseComponent<{
    id: number;
}, {
    offset: {
        x: number;
        y: number;
    };
}, unknown>) & {
    renderCount: number;
    lastRenderTime: number;
};
export declare class MessageBoxUI extends MessageBoxUI_base {
    moveBar_drag_origOffset: {
        x: number;
        y: number;
    } | n;
    moveBar_drag_mouseDownPos: {
        x: number;
        y: number;
    } | n;
    moveBar_drag_mouseMoveListener: EventListener | n;
    moveBar_drag_mouseUpListener: EventListener | n;
    render(): JSX.Element;
}
export {};

import { K8SContext, ResourceWithActions, ResourceWithActionsAndDocs } from "../core/models";
import { NetworkLayout, ResourceVisibility } from "./ui-enums";

export type Node = { id: string; label: string; group: string; shape?: string; image?: string };
export type Edge = { from: string; to: string; dashes?: number[] };

export type DisplaySettings = {
  SettingsVersion: number;
  Layout: NetworkLayout;
  Resources: { [kind: string]: ResourceVisibility };
  // this is just a map of the Resource field (maps are not correctly serialized when saved to local storage)
  ResourcesMap: Map<string, ResourceVisibility>;
  Context: {
    currentContext: string;
    contexts: K8SContext[];
  };
};

export type ResourceUIModel = ResourceWithActionsAndDocs & {
  ui: {
    location: {
      x: number;
      y: number;
    };
    font?: {
      size: number;
      bold: boolean;
    };
    size?: {
      height: number;
      width: number;
    };
  };
  isGroup: boolean;
};

export type MongodbDeploymentUIModel = {
  resources: ResourceUIModel[];
  resourceGroups: Map<string, ResourceUIModel[]>;
};

---
title: Feature Set and Roadmap
author: ashish161
date: 2021-03-24
category: features
layout: post
---

#PikReview
    
    Quick, hassle free and privcay centric  store front for your business and your data 


## Store Settings
 - Setup your store link, currency, payment instructions.
 - Order and shipping settings 
 - Store communication details 
 - Payment options 
 
## Inventory  management
 Easy inventory setup and ability to customize your products    
 - Description
 - Pricing
 - Variants : Size and Colors
 - Taxes 
 - Shipping 
 - Category 
 - Bulk products using excel for quick on-boarding 

## Order Management 
Fulfill orders from your mobile / desktop and never miss updating your customers 
 - Accept orders and send quick updates to your customers using whatsapp 
 - Get insights of high value and repeat customers
 - Dashboard of pending / shipping and shipped order and revenue  
 - Bulk products using excel for quick on-boarding 

## Roadmap 
- Support for local languages 
- Support for international currencies 
- Payment gateway integration 
- Setup on custom domain 
- Reseller management
- Tie up with shipping and logistic partners   
import os
import platform
import shelve
from logic.utils import clear_folder
from collections import OrderedDict


class Round:

    def __init__(self, name, teams=[], max_points=100):
        self.round_name = name
        self.max_points = max_points
        self.teams = OrderedDict()
        for team in teams:
            self.teams[team["name"]] = team
            self.teams[team["name"]]["score"] = 0

    def __str__(self):
        return str(self.teams)

    def create_self(self):
        # first delete all other files
        clear_folder(os.path.join(os.getcwd(), "data", "*"))
        self.write_to_db()

    def write_to_db(self):
        db_path = os.path.join(os.getcwd(), "data", self.round_name)
        db = shelve.open(db_path)
        for k in self.teams.keys():
            db[k] = self.teams[k]
        db.close()

    def exists(self):
        if platform.system() != "Linux":
            db_path = os.path.join(os.getcwd(), "data", self.round_name + '.dat')
        else:
            db_path = os.path.join(os.getcwd(), "data", self.round_name)
        return os.path.exists(db_path)

    def open_existing(self):
        # expects that round_name already exists
        db_path = os.path.join(os.getcwd(), "data", self.round_name)
        db = shelve.open(db_path)
        db_keys = list(db.keys())
        db_keys.sort()
        for k in db_keys:
            self.teams[k] = db[k]
        db.close()

    def update_from_dict(self, d):
        for k in d.keys():
            if k in self.teams:
                val = int(d[k])
                if val < 0:
                    self.teams[k]["score"] = 0
                else:
                    self.teams[k]["score"] = val if val <= self.max_points else self.max_points
        self.write_to_db()



var config = {}

config.redis = {};
config.http = {};
config.cookie = {};
config.log = {};
config.ubersmith = {};
config.ubersmith.warm_cache = false;
config.log.access_log = './access.log';
config.log.directory = process.env.LOG_DIR || './';

config.redis.uri = process.env.REDIS_URI;
config.redis.host = process.env.REDIS_HOST || 'localhost';
config.redis.port = process.env.REDIS_PORT || 6379;
config.redis.db = process.env.REDIS_DB || 1;

config.http.port = process.env.PORT || 3005;
config.cookie.secret = 'securit3333!!';

module.exports = config;

<?php

namespace App\Http\Controllers\Auth;

use App\Custodian;
use App\Http\Controllers\Controller;
use Illuminate\Foundation\Auth\ThrottlesLogins;
use Illuminate\Foundation\Auth\AuthenticatesAndRegistersUsers;
use Illuminate\Http\Request;
use JWTAuth;
use App\UserType;
use App\Department;

class AuthController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | Registration & Login Controller
    |--------------------------------------------------------------------------
    |
    | This controller handles the registration of new users, as well as the
    | authentication of existing users. By default, this controller uses
    | a simple trait to add these behaviors. Why don't you explore it?
    |
    */

    use AuthenticatesAndRegistersUsers, ThrottlesLogins;

    /**
     * Where to redirect users after login / registration.
     *
     * @var string
     */
    protected $redirectTo = '/';

    /**
     * Create a new authentication controller instance.
     *
     * @return void
     */
    public function __construct()
    {
        $this->middleware($this->guestMiddleware(), ['except' => 'logout']);
    }

    public function userAuth(Request $request){
        $credentials = $request->only('email','password');
        $token = null;

        try{
            if(!$token = JWTAuth::attempt($credentials)){ 
                return response()->json(['error' => 'invalid_credentials'], 404);
            }
        }catch(JWTException $ex){
            return response()->json(['error' => 'something_went_wrong'], 500);
        }

        return response()->json(compact('token'));

        
    }

    public function getAuthenticatedUser(){
        
        try {
            if (! $user = JWTAuth::parseToken()->authenticate()) {
                return response()->json(['user_not_found'], 404);
            }

        } catch (Tymon\JWTAuth\Exceptions\TokenExpiredException $e) {

            return response()->json(['token_expired'], $e->getStatusCode());

        } catch (Tymon\JWTAuth\Exceptions\TokenInvalidException $e) {

            return response()->json(['token_invalid'], $e->getStatusCode());

        } catch (Tymon\JWTAuth\Exceptions\JWTException $e) {

            return response()->json(['token_absent'], $e->getStatusCode());
        }

        $user_type_name = Usertype::find($user->user_type_id)->role;
        $user->user_type_name =  $user_type_name;

        $user_department_name = Department::find($user->department_id)->name;
        $user->user_department_name =  $user_department_name;

        $data = [];
            $data = [
                'id' => $user->id,
                'name' => $user->name,
                'email' => $user->email,
                'position' => $user->position,
                'contact_number' => $user->contact_number,
                'employee_id' => $user->employee_id,
                'user_type_id' => $user->user_type_id,
                'department_id' => $user->department_id,
                'user_type_name' => $user->user_type_name,
                'user_department_name' => $user->user_department_name
            ];
        
        // the token is valid and we have found the user via the sub claim
        return response()->json(compact('data'));
    }

    /**
     * Create a new user instance after a valid registration.
     *
     * @param  array  $data
     * @return User
     */
    protected function create(array $data)
    {
        return Custodian::create([
            'name' => $data['name'],
            'email' => $data['email'],
            'password' => bcrypt($data['password']),
        ]);
    }
}

#include "mini_uart.h"
#include "uint.h"
#include "priority_queue.h"
#include "queue.h"
#include "scheduler.h"
#include "task.h"

uint64 freq_thread = 31;

void core_timer_init(){
    uint64 tmp;
    asm volatile("mrs %0, cntkctl_el1" : "=r"(tmp));
    tmp |= 1;
    asm volatile("msr cntkctl_el1, %0" : : "r"(tmp));
    core_timer_disable();
}

void arm_core_timer_intr_handler() {
    core_timer_handler();
}

void core_timer_handler(){
    struct node* node = delete_first_node();
    if(node->next == NULL){
        asm volatile("mrs x0, cntfrq_el0\n"
                     "ldr x1, =10\n"
                     "mul x0, x0, x1\n"
                     "msr cntp_tval_el0, x0\n");
        core_timer_disable();
    }else{
        core_timer_enable();
        uint64 interval = node->next->time_to_ring;
        asm volatile("msr cntp_tval_el0, %[output0]\n"
                     ::[output0] "r" (interval));
    }
    free(node);
    node->todo(node->arguments);
}

void add_timer(void (*callback_f)(void*),void *argu_for_call,int times){
    uint64 clock_hz,now_time,interval;
    asm volatile("mrs %[input0], cntfrq_el0\n"
                 "mrs %[input2], cntp_tval_el0\n"
                 :[input0] "=r" (clock_hz),
                  [input2] "=r" (interval));
    uint64 time_to_ring = add_node(callback_f, argu_for_call, clock_hz / 1000 * times, interval);
    core_timer_enable();
    asm volatile("msr cntp_tval_el0, %[output0]\n"
                 ::[output0] "r" (time_to_ring));
}

void *wakeup(void *p){
    uart_printf("Timeout!!\n");
}

void sleep(int duration){
    add_timer(wakeup,NULL,duration);
    uart_printf("Timer is set...\n");
}

void delay(int duration){
    irq_disable();
    void *argu = get_current();
    add_timer(wakeup_queue,argu,duration);
    irq_enable();
    schedule();
}

void thread_timer_handler(){
    void *t = get_current();
    struct thread *s = t;
    PushToReadyList(s->tid);
    thread_timer();
    task_schedule(t);
}

void thread_timer(){
    while(delete_first_node() != NULL);
    add_timer(thread_timer_handler,NULL,freq_thread);
}

/* eslint-disable @typescript-eslint/no-unused-vars,@typescript-eslint/no-empty-interface,@typescript-eslint/no-explicit-any */
import Vue, { VNode, RenderContext } from 'vue';
import { DefaultProps } from 'vue/types/options';

declare global {
  namespace JSX {
    interface Element extends VNode {}
    interface ElementClass extends Vue {}
    interface IntrinsicElements {
      [elem: string]: any;
    }
  }
}

declare module 'vue/types/index' {
  type FunctionalComponent<Props = DefaultProps> = (
    context: RenderContext<Props>,
  ) => VNode;
}

---
layout: "fluid/docs_base"
version: "3.6.1"
versionHref: "/docs/v3/3.6.1"
path: ""
category: api
id: "app"
title: "App"
header_sub_title: "Ionic API Documentation"
doc: "App"
docType: "class"

---









<h1 class="api-title">
<a class="anchor" name="app" href="#app"></a>

App





</h1>

<a class="improve-v2-docs" href="http://github.com/ionic-team/ionic/edit/v3/src/components/app/app.ts#L16">
Improve this doc
</a>






<p>App is a utility class used in Ionic to get information about various aspects of an app</p>




<!-- @usage tag -->


<!-- @property tags -->



<!-- instance methods on the class -->

<h2><a class="anchor" name="instance-members" href="#instance-members">Instance Members</a></h2>

<div id="getActiveNav"></div>

<h3>
<a class="anchor" name="getActiveNav" href="#getActiveNav">
<code>getActiveNav()</code>


</a>
</h3>








<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>NavController</code> <p>Returns the first Active Nav Controller from the list. This method is deprecated</p>


</div>




<div id="getActiveNavContainers"></div>

<h3>
<a class="anchor" name="getActiveNavContainers" href="#getActiveNavContainers">
<code>getActiveNavContainers()</code>


</a>
</h3>











<div id="getActiveNavs"></div>

<h3>
<a class="anchor" name="getActiveNavs" href="#getActiveNavs">
<code>getActiveNavs()</code>


</a>
</h3>








<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>NavController[]</code> <p>Returns the active NavControllers. Using this method is preferred when we need access to the top-level navigation controller while on the outside views and handlers like <code>registerBackButtonAction()</code></p>


</div>




<div id="getNavByIdOrName"></div>

<h3>
<a class="anchor" name="getNavByIdOrName" href="#getNavByIdOrName">
<code>getNavByIdOrName()</code>


</a>
</h3>











<div id="getRootNav"></div>

<h3>
<a class="anchor" name="getRootNav" href="#getRootNav">
<code>getRootNav()</code>


</a>
</h3>











<div id="getRootNavById"></div>

<h3>
<a class="anchor" name="getRootNavById" href="#getRootNavById">
<code>getRootNavById()</code>


</a>
</h3>








<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>NavController</code> <p>Returns the root NavController</p>


</div>




<div id="getRootNavs"></div>

<h3>
<a class="anchor" name="getRootNavs" href="#getRootNavs">
<code>getRootNavs()</code>


</a>
</h3>











<div id="isScrolling"></div>

<h3>
<a class="anchor" name="isScrolling" href="#isScrolling">
<code>isScrolling()</code>


</a>
</h3>

Boolean if the app is actively scrolling or not.






<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>boolean</code> <p>returns true or false</p>


</div>




<div id="setTitle"></div>

<h3>
<a class="anchor" name="setTitle" href="#setTitle">
<code>setTitle(val)</code>


</a>
</h3>

Sets the document title.


<table class="table param-table" style="margin:0;">
  <thead>
    <tr>
      <th>Param</th>
      <th>Type</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>

    <tr>
      <td>
        val


      </td>
      <td>

  <code>string</code>
      </td>
      <td>
        <p>Value to set the document title to.</p>


      </td>
    </tr>

  </tbody>
</table>








<div id="viewDidEnter"></div>

<h3>
<a class="anchor" name="viewDidEnter" href="#viewDidEnter">
<code>viewDidEnter</code>


</a>
</h3>

Observable that emits after any view is entered in the app.






<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>Observable</code> <p>Returns an observable</p>


</div>




<div id="viewDidLeave"></div>

<h3>
<a class="anchor" name="viewDidLeave" href="#viewDidLeave">
<code>viewDidLeave</code>


</a>
</h3>

Observable that emits after any view is exited in the app.






<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>Observable</code> <p>Returns an observable</p>


</div>




<div id="viewDidLoad"></div>

<h3>
<a class="anchor" name="viewDidLoad" href="#viewDidLoad">
<code>viewDidLoad</code>


</a>
</h3>

Observable that emits whenever a view loads in the app.






<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>Observable</code> <p>Returns an observable</p>


</div>




<div id="viewWillEnter"></div>

<h3>
<a class="anchor" name="viewWillEnter" href="#viewWillEnter">
<code>viewWillEnter</code>


</a>
</h3>

Observable that emits before any view is entered in the app.






<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>Observable</code> <p>Returns an observable</p>


</div>




<div id="viewWillLeave"></div>

<h3>
<a class="anchor" name="viewWillLeave" href="#viewWillLeave">
<code>viewWillLeave</code>


</a>
</h3>

Observable that emits before any view is exited in the app.






<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>Observable</code> <p>Returns an observable</p>


</div>




<div id="viewWillUnload"></div>

<h3>
<a class="anchor" name="viewWillUnload" href="#viewWillUnload">
<code>viewWillUnload</code>


</a>
</h3>

Observable that emits before any view unloads in the app.






<div class="return-value">
<i class="icon ion-arrow-return-left"></i>
<b>Returns:</b>
  <code>Observable</code> <p>Returns an observable</p>


</div>





  <h2 id="sass-variable-header"><a class="anchor" name="sass-variables" href="#sass-variables">Sass Variables</a></h2>
  <div id="sass-variables" ng-controller="SassToggleCtrl">
  <div class="sass-platform-toggle">

    <h3 ng-init="setSassPlatform('base')">All</h3>

  </div>



  <table ng-show="active === 'base'" id="sass-base" class="table param-table" style="margin:0;">
    <thead>
      <tr>
        <th>Property</th>
        <th>Default</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>

      <tr>
        <td><code>$font-size-root</code></td>

          <td><code>62.5%</code></td>

        <td><p>Font size of the root html</p>
</td>
      </tr>

      <tr>
        <td><code>$headings-font-weight</code></td>

          <td><code>500</code></td>

        <td><p>Font weight of all headings</p>
</td>
      </tr>

      <tr>
        <td><code>$headings-line-height</code></td>

          <td><code>1.2</code></td>

        <td><p>Line height of all headings</p>
</td>
      </tr>

      <tr>
        <td><code>$h1-font-size</code></td>

          <td><code>2.6rem</code></td>

        <td><p>Font size of heading level 1</p>
</td>
      </tr>

      <tr>
        <td><code>$h2-font-size</code></td>

          <td><code>2.4rem</code></td>

        <td><p>Font size of heading level 2</p>
</td>
      </tr>

      <tr>
        <td><code>$h3-font-size</code></td>

          <td><code>2.2rem</code></td>

        <td><p>Font size of heading level 3</p>
</td>
      </tr>

      <tr>
        <td><code>$h4-font-size</code></td>

          <td><code>2rem</code></td>

        <td><p>Font size of heading level 4</p>
</td>
      </tr>

      <tr>
        <td><code>$h5-font-size</code></td>

          <td><code>1.8rem</code></td>

        <td><p>Font size of heading level 5</p>
</td>
      </tr>

      <tr>
        <td><code>$h6-font-size</code></td>

          <td><code>1.6rem</code></td>

        <td><p>Font size of heading level 6</p>
</td>
      </tr>

      <tr>
        <td><code>$include-responsive-utilities</code></td>

          <td><code>true</code></td>

        <td><p>Whether to include all of the responsive utility attributes</p>
</td>
      </tr>

      <tr>
        <td><code>$include-text-alignment-utilities</code></td>

          <td><code>$include-responsive-utilities</code></td>

        <td><p>Whether to include all of the responsive text alignment attributes</p>
</td>
      </tr>

      <tr>
        <td><code>$include-text-transform-utilities</code></td>

          <td><code>$include-responsive-utilities</code></td>

        <td><p>Whether to include all of the responsive text transform attributes</p>
</td>
      </tr>

      <tr>
        <td><code>$include-float-element-utilities</code></td>

          <td><code>$include-responsive-utilities</code></td>

        <td><p>Whether to include all of the responsive float attributes</p>
</td>
      </tr>

      <tr>
        <td><code>$screen-breakpoints</code></td>

          <td><code>(&#10;  xs: 0,&#10;  sm: 576px,&#10;  md: 768px,&#10;  lg: 992px,&#10;  xl: 1200px&#10;)</code></td>

        <td><p>The minimum dimensions at which your layout will change,
adapting to different screen sizes, for use in media queries</p>
</td>
      </tr>

    </tbody>
  </table>

</div>



<!-- related link --><!-- end content block -->


<!-- end body block -->


import __SInterface from '@coffeekraken/s-interface';
import __SugarConfig from '@coffeekraken/s-sugar-config';
import __flatten from '@coffeekraken/sugar/shared/object/flatten';
import __postCss from 'postcss';
import __deepMerge from '@coffeekraken/sugar/shared/object/deepMerge';
import __postcss from 'postcss';
import __theme from '../../utils/theme';

class postcssSugarPluginMediaMixinInterface extends __SInterface {
  static definition = {
    query1: {
      type: 'String',
      required: true
    },
    query2: {
      type: 'String'
    },
    query3: {
      type: 'String'
    },
    query4: {
      type: 'String'
    },
    query5: {
      type: 'String'
    },
    query6: {
      type: 'String'
    },
    query7: {
      type: 'String'
    }
  };
}
export { postcssSugarPluginMediaMixinInterface as interface };

/**
 * @name           media
 * @namespace      mixins
 * @type           Mixin
 * @platform      css
 * @status        beta
 *
 * This mixin allows you to apply any media queries that are defined
 * in the config.theme.media.queries configuration stack like "tablet", "mobile", etc...
 *
 * @param       {String}        query       The query string like ">tablet", "<=desktop", etc...
 * @return      {Css}         The generated css
 * 
 * @example         postcss
 * \@sugar.media >=desktop {
 *      // ...
 * }
 * \@sugar.media tablet {
 *      // ...
 * }
 *
 * @since       2.0.0
 * @author         Olivier Bossel <olivier.bossel@gmail.com> (https://olivierbossel.com)
 */
export default function ({
  params,
  atRule,
  postcssApi
}: {
  params: any;
  atRule: any;
  postcssApi: any;
}) {
  const mediaConfig = __theme().config('media');

  const queries: string[] = [];

  Object.keys(params).forEach(queryId => {
    const query = params[queryId].trim();
    query.split(',').forEach(q => {
      queries.push(q.trim());
    });
  });

  // const queries = params.query.split(',').map(l => l.trim());
  const fullQueriesList: string[] = [];

  queries.forEach(query => {

    // const mediasArray: string[] = [];
    // let currentQuery = '';
    // query.replace(/\sand\s/gm, ' , ').replace(/\sor\s/gm, ' _ ').split('').forEach(char => {
    //   if (char === '_') {
    //     mediasArray.push(currentQuery.trim());
    //     mediasArray.push('or');
    //     currentQuery = '';
    //   } else if (char === ',') {
    //     mediasArray.push(currentQuery.trim());
    //     mediasArray.push('and');
    //     currentQuery = '';
    //   } else {
    //     currentQuery += char;
    //   }
    // });
    // mediasArray.push(currentQuery.trim());

    const currentQueryList: string[] = [mediaConfig.defaultQuery, 'and'];

    // mediasArray.forEach((query) => {

      if (query === 'and' || query === 'or') {
        currentQueryList.push(query); 
        return;
      }

      const firstChar = query.slice(0, 1);
      const firstTwoChar = query.slice(0, 2);
      const lastChar = query.slice(-1);
      let action = mediaConfig.defaultAction;
      let mediaName = query;

      if (lastChar === '-' || lastChar === '|')
        mediaName = mediaName.slice(0, -1);

      if (
        firstTwoChar === '>=' ||
        firstTwoChar === '<=' ||
        firstTwoChar === '=='
      ) {
        mediaName = mediaName.slice(2);
        action = firstTwoChar;
      } else if (firstChar === '<' || firstChar === '>' || firstChar === '=') {
        mediaName = mediaName.slice(1);
        action = firstChar;
      }

      const mediaQueryConfig = mediaConfig.queries[mediaName];
      if (!mediaQueryConfig)
        throw new Error(
          `<red>[postcssSugarPlugin.media]</red> Sorry but the requested media "<yellow>${mediaName}</yellow>" does not exists in the config. Here's the available medias: ${Object.keys(
            mediaConfig.queries
          )
            .map((l) => `<green>${l}</green>`)
            .join(',')}`
        );

      const queryList: string[] = [];

      Object.keys(mediaQueryConfig).forEach((prop) => {
        const value = mediaQueryConfig[prop];
        if (!value) return;

        if (
          [
            'min-width',
            'max-width',
            'min-device-width',
            'max-device-width'
          ].indexOf(prop) !== -1
        ) {
          if (action === '>') {
            if (prop === 'max-width' || prop === 'max-device-width') {
              let argName = 'min-width';
              if (prop.includes('-device')) argName = 'min-device-width';
              queryList.push(`(${argName}: ${value + 1}px)`);
            }
          } else if (action === '<') {
            if (prop === 'min-width' || prop === 'min-device-width') {
              let argName = 'max-width';
              if (prop.includes('-device')) argName = 'max-device-width';
              queryList.push(`(${argName}: ${value}px)`);
            }
          } else if (action === '=') {
            queryList.push(`(${prop}: ${value}px)`);
          } else if (action === '>=') {
            if (prop === 'min-width' || prop === 'min-device-width') {
              queryList.push(`(${prop}: ${value}px)`);
            }
          } else if (action === '<=') {
            if (prop === 'max-width' || prop === 'max-device-width') {
              queryList.push(`(${prop}: ${value}px)`);
            }
          } else {
            queryList.push(`(${prop}: ${value}px)`);
          }
        } else {
          queryList.push(`(${prop}: ${value}px)`);
        }
      });

      if (lastChar === '-') {
        queryList.push('(orientation: landscape)');
      } else if (lastChar === '|') {
        queryList.push('(orientation: portrait)');
      }

      currentQueryList.push(queryList.join(' and '));
    // });

    fullQueriesList.push(currentQueryList.join(' '));

  });
  
  const mediaRule = new postcssApi.AtRule({
    name: 'media',
    params: fullQueriesList.join(' ')
  });

  // const AST = __postcss.parse(`@media ${fullQueriesList.join(' ')} {}`);

  // @ts-ignore
  atRule.nodes.forEach(node => {
    mediaRule.append(node);
  });

  atRule.replaceWith(mediaRule);
}

package org.honeysoft.akka.di;

import akka.actor.UntypedActor;
import akka.actor.UntypedActorFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;

import java.lang.reflect.Field;

import static org.fest.reflect.util.Accessibles.setAccessible;
import static org.fest.reflect.util.Accessibles.setAccessibleIgnoringExceptions;

public class SpringUntypedActorFactory implements UntypedActorFactory {

    private final DependencyInjectionFactory dependencyInjectionFactory;

    private final ApplicationContext applicationContext;

    public SpringUntypedActorFactory(Class<?> actorClass, ApplicationContext applicationContext) {
        this.dependencyInjectionFactory = new DefaultUntypedActorFactory(actorClass);
        this.applicationContext = applicationContext;
    }

    public SpringUntypedActorFactory(UntypedActorFactory customFactory, ApplicationContext applicationContext) {
        this.dependencyInjectionFactory = new SpecificUntypedActorFactory(customFactory);
        this.applicationContext = applicationContext;
    }

    private interface DependencyInjectionFactory {
        UntypedActor createAndInject();
    }


    private abstract class AbstractUntypedActorFactory implements DependencyInjectionFactory {

        @Override
        public final UntypedActor createAndInject() {
            try {
                UntypedActor untypedActor = create();

                Class<?> aClass = getActorClass();
                for (Field field : aClass.getDeclaredFields()) {

                    if (field.getAnnotation(Autowired.class) != null) {
                        boolean accessible = field.isAccessible();
                        try {
                            setAccessible(field, true);
                            field.set(untypedActor, applicationContext.getBean(field.getType()));
                        } catch (IllegalAccessException e) {
                            throw new IllegalStateException("Unable to create actor instance", e);
                        } finally {
                            setAccessibleIgnoringExceptions(field, accessible);
                        }
                    }
                }
                return untypedActor;

            } catch (Exception e) {
                throw new IllegalStateException("Unable to create actor instance", e);
            }

        }

        protected abstract Class<?> getActorClass();

        protected abstract UntypedActor create() throws Exception;

    }

    private final class SpecificUntypedActorFactory extends AbstractUntypedActorFactory {

        private final UntypedActorFactory specificFactory;
        private volatile Class<?> actorClass;

        private SpecificUntypedActorFactory(UntypedActorFactory specificFactory) {
            this.specificFactory = specificFactory;
        }

        @Override
        protected Class<?> getActorClass() {
            return actorClass;
        }

        @Override
        protected UntypedActor create() throws Exception {
            UntypedActor untypedActor = (UntypedActor) specificFactory.create();
            actorClass = untypedActor.getClass();
            return untypedActor;
        }
    }

    private final class DefaultUntypedActorFactory extends AbstractUntypedActorFactory {
        private final Class<?> actorClass;

        public DefaultUntypedActorFactory(Class<?> actorClass) {
            this.actorClass = actorClass;
        }

        @Override
        protected Class<?> getActorClass() {
            return actorClass;
        }

        @Override
        protected UntypedActor create() throws InstantiationException, IllegalAccessException {
            return (UntypedActor) actorClass.newInstance();
        }
    }

    /**
     * This method must return a different instance upon every call.
     */
    @Override
    public UntypedActor create() {
        return dependencyInjectionFactory.createAndInject();
    }


}
package channel

import (
	"bytes"
)

/**
 * 通道支付完整单据
 */

// 通道链支付票据
type ChannelPayCompleteDocuments struct {
	// 对账票据表
	ProveBodys *ChannelPayProveBodyList
	// 支付签名票据
	ChainPayment *OffChainFormPaymentChannelTransfer
}

func (c ChannelPayCompleteDocuments) Size() uint32 {
	return c.ProveBodys.Size() + c.ChainPayment.Size()
}

func (c ChannelPayCompleteDocuments) Serialize() ([]byte, error) {
	var buffer bytes.Buffer
	var bt1, _ = c.ProveBodys.Serialize()
	buffer.Write(bt1)
	var bt2, _ = c.ChainPayment.Serialize()
	buffer.Write(bt2)
	return buffer.Bytes(), nil
}

func (c *ChannelPayCompleteDocuments) Parse(buf []byte, seek uint32) (uint32, error) {
	var e error
	// 通道
	c.ProveBodys = &ChannelPayProveBodyList{}
	seek, e = c.ProveBodys.Parse(buf, seek)
	if e != nil {
		return 0, e
	}
	c.ChainPayment = &OffChainFormPaymentChannelTransfer{}
	seek, e = c.ChainPayment.Parse(buf, seek)
	if e != nil {
		return 0, e
	}
	return seek, nil
}

import React, { Fragment, Component } from "react";
import LinearProgress from "@material-ui/core/LinearProgress";
import Snackbar from "../../organisms/Snackbar";

export default class FileUpload extends Component {
  constructor(props) {
    super(props);
    this.state = {
      url: props.url || "/upload/image",
      showStatus: true, //props.showStatus,
      showSnackbar: false,
      snackbarSeverity: "error",
      snackbarDuration: 5000,
      snackbarMessage: "",
    };

    this.uploadId = Math.round(Math.random() * 1e9);
    this.fileInput = React.createRef();
  }

  uploadFile = async (e) => {
    if (this.fileInput.current.files[0]) {
      const formData = new FormData();
      let json;
      try {
        formData.append("image", this.fileInput.current.files[0]);
        const response = await fetch(this.state.url, {
          method: "POST",
          body: formData,
        });
        json = await response.json();

        if (this.props.afterUpload) {
          this.props.afterUpload(json);
        }
        this.setState({
          showSnackbar: true,
          snackbarSeverity: "success",
          snackbarMessage: "Upload success.",
        });
      } catch (e) {
        this.setState({
          showSnackbar: true,
          snackbarSeverity: "error",
          snackbarMessage: "Upload failed.",
        });
      }

      this.fileInput.current.value = "";
    }
  };

  render() {
    const {
      showSnackbar,
      snackbarSeverity,
      snackbarDuration,
      snackbarMessage,
    } = this.state;
    return (
      <Fragment>
        <Snackbar
          open={showSnackbar}
          severity={snackbarSeverity}
          duration={snackbarDuration}
          message={snackbarMessage}
          onClose={() => {
            this.setState({ showSnackbar: false });
          }}
        />
        <input
          accept="image/*"
          id={this.uploadId}
          multiple
          type="file"
          onChange={this.uploadFile}
          onBlur={() => {}}
          ref={this.fileInput}
          style={{ display: "none" }}
        />
        <div
          style={{ cursor: "pointer", display: "inline-block" }}
          onClick={(e) => {
            if (!this.fileInput.current.value === "" || this.props.disabled) {
              return;
            }

            document.getElementById(`${this.uploadId}`).click();
          }}
        >
          {this.fileInput &&
          this.fileInput.current &&
          !this.fileInput.current.value === "" &&
          this.state.showStatus ? (
            <LinearProgress style={{ marginTop: "3em" }} />
          ) : (
            this.props.children
          )}
        </div>
      </Fragment>
    );
  }
}

import FontPainter, { FontParserSVG, RenderEngineSVG, RenderBoundsElementWidth } from 'fontpainter';
import './example-simple.scss';

export class Demo {
	immediate = true;

	constructor() {
		this.container = document.querySelector('.example-simple');
		this.painter = new FontPainter();
		this.engine = new RenderEngineSVG();
		this.painter.setEngine(this.engine);
		this.painter.fontSize = 45;
		this.painter.bounds = new RenderBoundsElementWidth(this.container);
	}

	render(copy = '', fontPath) {
		this.painter.loadFont(fontPath, FontParserSVG);
		this.painter.getFont().then(() => {
			this.painter.paint(copy);
			this.container.appendChild(this.engine.svgElement);
		});
	}

	dispose() {
		this.painter.dispose();
	}
}

export const menuName = 'Simple SVG';

export const defaultText = 'The quick brown fox jumps over the lazy dog';

export { default as template } from 'raw-loader!./template.html';


module BestPractices::Scopes
  extend ActiveSupport::Concern

  included do
    scope :ordered, -> { order obsolete: :asc, name: :asc }
  end

  module ClassMethods
    def visible
      setting                      = Current.organization.settings.find_by name: 'hide_obsolete_best_practices'
      hide_obsolete_best_practices = DEFAULT_SETTINGS[:hide_obsolete_best_practices][:value]

      if (setting ? setting.value : hide_obsolete_best_practices) == '0'
        all
      else
        where(obsolete: false)
      end
    end
  end
end

pragma solidity ^0.7.4;
pragma experimental ABIEncoderV2;

import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";

import "../interfaces/helpers/IPriceFeed.sol";

import "../abstract/AbstractDependant.sol";

contract PriceFeed is IPriceFeed, AbstractDependant {
    IUniswapV2Router02 public ammRouter;

    address public wrappedToken;
    address public bmiToken;
    address public usdtToken;

    function setDependencies(IContractsRegistry _contractsRegistry)
        external
        override
        onlyInjectorOrZero
    {
        ammRouter = IUniswapV2Router02(_contractsRegistry.getAMMRouterContract());
        wrappedToken = _contractsRegistry.getWrappedTokenContract();
        bmiToken = _contractsRegistry.getBMIContract();
        usdtToken = _contractsRegistry.getUSDTContract();
    }

    function howManyBMIsInUSDT(uint256 usdtAmount) external view override returns (uint256) {
        if (usdtAmount == 0) {
            return 0;
        }

        address[] memory pairs = new address[](3);
        pairs[0] = usdtToken;
        pairs[1] = wrappedToken;
        pairs[2] = bmiToken;

        uint256[] memory amounts = ammRouter.getAmountsOut(usdtAmount, pairs);

        return amounts[amounts.length - 1];
    }

    function howManyUSDTsInBMI(uint256 bmiAmount) external view override returns (uint256) {
        if (bmiAmount == 0) {
            return 0;
        }

        address[] memory pairs = new address[](3);
        pairs[0] = bmiToken;
        pairs[1] = wrappedToken;
        pairs[2] = usdtToken;

        uint256[] memory amounts = ammRouter.getAmountsOut(bmiAmount, pairs);

        return amounts[amounts.length - 1];
    }
}
import fs from 'fs';
import sinon from 'sinon';
import test from 'tape';

import { mockParsedMarkdown } from './_fixtures';

import { DIRECTORIES } from './config/constants';
import { MarkdownParser } from './MarkdownParser';
import { Renderer } from './Renderer';
import { parseContent } from './parseContent';

import type { ParsedContentType } from './parseContent';

type MockDirentProps = {
  isDirectory?: true;
  isFile?: true;
  name: string;
};

const mockDirent = (props: MockDirentProps): fs.Dirent => {
  const { isDirectory, isFile, name } = props;

  return {
    isBlockDevice: () => false,
    isCharacterDevice: () => false,
    isDirectory: () => isDirectory || false,
    isFIFO: () => false,
    isFile: () => isFile || false,
    isSocket: () => false,
    isSymbolicLink: () => false,
    name,
  };
};

test('`parseContent`', async (t: test.Test) => {
  const readdirStub = sinon.stub(fs.promises, 'readdir');
  const readFileStub = sinon.stub(fs.promises, 'readFile');

  readdirStub
    .withArgs('./content/', { withFileTypes: true })
    .resolves([
      mockDirent({ isFile: true, name: 'index.md' }),
      mockDirent({ isFile: true, name: 'draft.md' }),
      mockDirent({ isFile: true, name: 'page.md' }),
      mockDirent({ isFile: true, name: 'asset.jpg' }),
      mockDirent({ isFile: true, name: '_data.json' }),
      mockDirent({ isDirectory: true, name: 'directory' }),
    ]);

  readdirStub
    .withArgs('./content/directory/', { withFileTypes: true })
    .resolves([
      mockDirent({ isFile: true, name: '_index.md' }),
      mockDirent({ isFile: true, name: 'draft.md' }),
      mockDirent({ isFile: true, name: 'page.md' }),
      mockDirent({ isFile: true, name: 'asset.jpg' }),
      mockDirent({ isFile: true, name: '_data.json' }),
      mockDirent({ isDirectory: true, name: 'nested' }),
    ]);

  readdirStub
    .withArgs('./content/directory/nested/', { withFileTypes: true })
    .resolves([
      mockDirent({ isFile: true, name: 'index.md' }),
      mockDirent({ isFile: true, name: 'draft.md' }),
      mockDirent({ isFile: true, name: 'page.md' }),
      mockDirent({ isFile: true, name: 'asset.jpg' }),
      mockDirent({ isFile: true, name: '_data.json' }),
    ]);

  readFileStub.withArgs(sinon.match(/\.md$/)).resolves('Markdown');
  readFileStub
    .withArgs(sinon.match(/draft.md$/))
    .resolves('+++\ndraft = true\n+++\n\nMarkdown');
  readFileStub
    .withArgs(sinon.match(/_data.json$/))
    .resolves('{ "key": "value" }');

  const renderer = new Renderer({ baseTemplate: '', config: {}, partials: {} });
  const markdownParser = new MarkdownParser(renderer, []);

  const content = await parseContent({
    directory: DIRECTORIES.CONTENT,
    markdownParser,
    renderer,
  });

  t.deepEqual(
    content,
    {
      assets: [{ filePath: './content/asset.jpg' }],
      children: {
        directory: {
          assets: [{ filePath: './content/directory/asset.jpg' }],
          children: {
            nested: {
              assets: [{ filePath: './content/directory/nested/asset.jpg' }],
              children: null,
              data: {
                json: { key: 'value' },
                filePath: './content/directory/nested/_data.json',
              },
              pages: [
                {
                  filePath: './content/directory/nested/index.md',
                  markdown: mockParsedMarkdown,
                  name: 'index.md',
                },
                {
                  filePath: './content/directory/nested/page.md',
                  markdown: mockParsedMarkdown,
                  name: 'page.md',
                },
              ],
              section: null,
            },
          },
          data: {
            json: { key: 'value' },
            filePath: './content/directory/_data.json',
          },
          pages: [
            {
              filePath: './content/directory/page.md',
              markdown: mockParsedMarkdown,
              name: 'page.md',
            },
          ],
          section: {
            filePath: './content/directory/_index.md',
            markdown: mockParsedMarkdown,
            name: '_index.md',
          },
        },
      },
      data: { json: { key: 'value' }, filePath: './content/_data.json' },
      pages: [
        {
          filePath: './content/index.md',
          markdown: mockParsedMarkdown,
          name: 'index.md',
        },
        {
          filePath: './content/page.md',
          markdown: mockParsedMarkdown,
          name: 'page.md',
        },
      ],
      section: null,
    } as ParsedContentType,
    'parses all files within the given directory and returns a formatted object'
  );

  readdirStub.restore();
  readFileStub.restore();
  t.end();
});

@extends('errors::layout')

@section('title', 'Error')

{{--@section('message', 'Whoops, looks like something went wrong.')--}}

@section('message')
    500
    <br/><br/>
    服务器出错，请联系您的管理员
@stop

package com.pixelw.net.netty;

import com.pixelw.entity.Client;
import com.pixelw.net.ServerCore;
import com.pixelw.net.ServerListener;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.util.CharsetUtil;

import java.util.Map;

/**
 * @author Carl Su
 * @date 2020/5/1
 */
public class NettyCore extends ServerCore {

    private EventLoopGroup bossGroup;
    private EventLoopGroup workerGroup;

    public NettyCore(ServerListener listener, int port) {
        super(listener, port);
    }

    @Override
    public void run() {
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                bossGroup = new NioEventLoopGroup();
                workerGroup = new NioEventLoopGroup();
                try {
                    ServerBootstrap bootstrap = new ServerBootstrap();
                    bootstrap.group(bossGroup, workerGroup)
                            .channel(NioServerSocketChannel.class)
                            .childHandler(new ChannelInitializer<SocketChannel>() {
                                @Override
                                protected void initChannel(SocketChannel socketChannel) {
                                    socketChannel.pipeline().addLast(new ServerHandler(listener, NettyCore.this));
                                }
                            })
                            .option(ChannelOption.SO_BACKLOG, 128)
                            .childOption(ChannelOption.SO_KEEPALIVE, true);
                    ChannelFuture future = bootstrap.bind(port).sync();
                    future.channel().closeFuture().sync();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    @Override
    public void sendTextMsg(String msg, Client client) {
        Channel channel = client.getChannel();
        if (channel != null) {
            System.out.println("sendto:" + client.getInetAddress());
            //client is based on stream reader, append a line
            String string = msg + "\n";
            byte[] bytes = string.getBytes(CharsetUtil.UTF_8);
            ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);
            channel.writeAndFlush(byteBuf);
        }
    }

    @Override
    public void shutdown(Map<String, Client> map) {
        //foreach 或者Iterator
        try {
            if (map.size() > 0) {
                for (String strUserID : map.keySet()) {
                    Client client = map.get(strUserID);
                    client.getChannel().writeAndFlush(CONTROL_TOKEN);
                    client.getChannel().close();
                }
            } else {
                System.out.println("no opened sockets");
            }
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
            listener.onClosed(this);
        }

    }
}

import React, {Component} from 'react';
import FailureView from '../views/FailureView';
import PropTypes from 'prop-types';

class Failure extends Component {
  showLogin() {
    const {emitter} = this.props.services;
    emitter.emit('setView', 'Login');
  }

  render() {
    const {error} = this.props.viewParameters;
    return (
      <FailureView
        errorMessage={error}
        onBackClick={this.showLogin.bind(this)}
      />
    );
  }
}

Failure.propTypes = {
  services: PropTypes.object,
  viewParameters: PropTypes.object
};

export default Failure;

package org.lwjgl.opengl;

/**
 * Native bindings to the <a target="_blank" href="https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_gpu_shader_half_float.txt">AMD_gpu_shader_half_float</a> extension.
 * 
 * <p>This extension was developed based on the {@link NVGPUShader5 NV_gpu_shader5} extension to allow implementations supporting half float in shader and expose the
 * feature without the additional requirements that are present in {@code NV_gpu_shader5}.</p>
 * 
 * <p>The extension introduces the following features for all shader types:</p>
 * 
 * <ul>
 * <li>support for half float scalar, vector and matrix data types in shader;</li>
 * <li>new built-in functions to pack and unpack half float types into a 32-bit integer vector;</li>
 * <li>half float support for all existing single float built-in functions, including angle functions, exponential functions, common functions, geometric
 * functions, matrix functions and etc.;</li>
 * </ul>
 * 
 * <p>This extension is designed to be a functional superset of the half-precision floating-point support from NV_gpu_shader5 and to keep source code
 * compatible with that, thus the new procedures, functions, and tokens are identical to those found in that extension.</p>
 * 
 * <p>Requires {@link GL40 OpenGL 4.0} and GLSL 4.00.</p>
 */
public final class AMDGPUShaderHalfFloat {

    /** Returned by the {@code type} parameter of GetActiveAttrib, GetActiveUniform, and GetTransformFeedbackVarying. */
    public static final int
        GL_FLOAT16_MAT2_AMD   = 0x91C5,
        GL_FLOAT16_MAT3_AMD   = 0x91C6,
        GL_FLOAT16_MAT4_AMD   = 0x91C7,
        GL_FLOAT16_MAT2x3_AMD = 0x91C8,
        GL_FLOAT16_MAT2x4_AMD = 0x91C9,
        GL_FLOAT16_MAT3x2_AMD = 0x91CA,
        GL_FLOAT16_MAT3x4_AMD = 0x91CB,
        GL_FLOAT16_MAT4x2_AMD = 0x91CC,
        GL_FLOAT16_MAT4x3_AMD = 0x91CD;

    private AMDGPUShaderHalfFloat() {}

}
package pipelineexecution

import (
	"context"
	"github.com/rancher/norman/controller"
	"github.com/rancher/rancher/pkg/controllers/user/pipeline/engine"
	"github.com/rancher/rancher/pkg/controllers/user/pipeline/utils"
	"github.com/rancher/rancher/pkg/ticker"
	"github.com/rancher/types/apis/management.cattle.io/v3"
	"github.com/sirupsen/logrus"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/labels"
	"time"
)

const (
	syncStateInterval = 5 * time.Second
)

//ExecutionStateSyncer is responsible for updating pipeline execution states
//by syncing with the pipeline engine
type ExecutionStateSyncer struct {
	clusterName           string
	clusterPipelineLister v3.ClusterPipelineLister

	pipelineLister          v3.PipelineLister
	pipelines               v3.PipelineInterface
	pipelineExecutionLister v3.PipelineExecutionLister
	pipelineExecutions      v3.PipelineExecutionInterface
	pipelineEngine          engine.PipelineEngine
}

func (s *ExecutionStateSyncer) sync(ctx context.Context, syncInterval time.Duration) {
	for range ticker.Context(ctx, syncInterval) {
		s.syncState()
	}

}

func (s *ExecutionStateSyncer) syncState() {
	if !utils.IsPipelineDeploy(s.clusterPipelineLister, s.clusterName) {
		return
	}

	set := labels.Set(map[string]string{utils.PipelineFinishLabel: "false"})
	allExecutions, err := s.pipelineExecutionLister.List("", set.AsSelector())
	if err != nil {
		logrus.Errorf("Error listing PipelineExecutions - %v", err)
		return
	}
	executions := []*v3.PipelineExecution{}
	for _, e := range allExecutions {
		if controller.ObjectInCluster(s.clusterName, e) {
			executions = append(executions, e)
		}
	}
	if len(executions) < 1 {
		return
	}
	if err := s.pipelineEngine.PreCheck(); err != nil {
		//fail to connect engine, mark the remaining executions as failed
		logrus.Errorf("Error get Jenkins engine - %v", err)
		for _, e := range executions {
			e.Status.ExecutionState = utils.StateFail
			v3.PipelineExecutionConditonProvisioned.False(e)
			v3.PipelineExecutionConditonProvisioned.ReasonAndMessageFromError(e, err)
			if err := s.updateExecutionAndLastRunState(e); err != nil {
				logrus.Errorf("Error update pipeline execution - %v", err)
				return
			}
		}
		return
	}
	for _, e := range executions {
		if e.Status.ExecutionState == utils.StateWaiting || e.Status.ExecutionState == utils.StateBuilding {
			updated, err := s.pipelineEngine.SyncExecution(e)
			if err != nil {
				logrus.Errorf("Error sync pipeline execution - %v", err)
				e.Status.ExecutionState = utils.StateFail
				v3.PipelineExecutionConditonProvisioned.False(e)
				v3.PipelineExecutionConditonProvisioned.ReasonAndMessageFromError(e, err)
				updated = true
			}
			if updated {
				if err := s.updateExecutionAndLastRunState(e); err != nil {
					logrus.Errorf("Error update pipeline execution - %v", err)
					return
				}
			}
		} else {
			if err := s.updateExecutionAndLastRunState(e); err != nil {
				logrus.Errorf("Error update pipeline execution - %v", err)
				return
			}
		}
	}
	logrus.Debugf("Sync pipeline execution state complete")
}

func (s *ExecutionStateSyncer) updateExecutionAndLastRunState(execution *v3.PipelineExecution) error {
	if execution.Status.ExecutionState != utils.StateWaiting && execution.Status.ExecutionState != utils.StateBuilding {
		execution.Labels[utils.PipelineFinishLabel] = "true"
	}
	if _, err := s.pipelineExecutions.Update(execution); err != nil {
		return err
	}

	//check and update lastrunstate of the pipeline when necessary
	p, err := s.pipelineLister.Get(execution.Spec.Pipeline.Namespace, execution.Spec.Pipeline.Name)
	if apierrors.IsNotFound(err) {
		logrus.Warningf("pipeline of execution '%s' is not found", execution.Name)
		return nil
	} else if err != nil {
		return err
	}

	if p.Status.LastExecutionID == execution.Namespace+":"+execution.Name &&
		p.Status.LastRunState != execution.Status.ExecutionState {
		p.Status.LastRunState = execution.Status.ExecutionState
		if _, err := s.pipelines.Update(p); err != nil {
			return err
		}
	}
	return nil
}

### [CVE-2006-4327](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4327)
![](https://img.shields.io/static/v1?label=Product&message=n%2Fa&color=blue)
![](https://img.shields.io/static/v1?label=Version&message=n%2Fa&color=blue)
![](https://img.shields.io/static/v1?label=Vulnerability&message=n%2Fa&color=brighgreen)

### Description

Multiple cross-site scripting (XSS) vulnerabilities in add_url.php in CloudNine Interactive Links Manager 2006-06-12 allow remote attackers to inject arbitrary web script or HTML via the (1) title, (2) description, or (3) keywords parameters.

### POC

#### Reference
- http://evuln.com/vulns/136/description.html

#### Github
No PoCs found on GitHub currently.


package io.github.yannici.bedwars.Listener;

import java.util.List;

import io.github.yannici.bedwars.Main;
import io.github.yannici.bedwars.Game.Game;
import io.github.yannici.bedwars.Game.GameState;

import org.bukkit.event.EventHandler;
import org.bukkit.event.weather.WeatherChangeEvent;

public class WeatherListener extends BaseListener {

	public WeatherListener() {
		super();
	}

	@EventHandler
	public void onWeatherEvent(WeatherChangeEvent we) {
	    if(we.isCancelled()) {
	        return;
	    }
	    
	    List<Game> games = Main.getInstance().getGameManager().getGamesByWorld(we.getWorld());
	    
	    if(games.size() == 0) {
	        return;
	    }
	    
	    for(Game game : games) {
	    	if(game.getState() == GameState.STOPPED) {
		        continue;
		    }
	    	
	    	we.setCancelled(true);
	    	return;
	    }
	}

}

package uoc.cbonache.tfg.ui.shippingMap

import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Canvas
import android.location.Geocoder
import android.location.Location
import android.location.LocationManager
import android.os.Build
import android.support.v4.content.ContextCompat
import android.support.v4.graphics.drawable.DrawableCompat
import android.view.ViewGroup
import uoc.cbonache.tfg.R
import uoc.cbonache.tfg.ui.ManagePermissions
import uoc.cbonache.tfg.ui.Navigator
import uoc.cbonache.tfg.ui.base.BaseActivity
import uoc.cbonache.tfg.ui.model.ShippingViewEntity
import com.google.android.gms.common.ConnectionResult
import com.google.android.gms.common.GoogleApiAvailability
import com.google.android.gms.maps.CameraUpdateFactory
import com.google.android.gms.maps.GoogleMap
import com.google.android.gms.maps.MapFragment
import com.google.android.gms.maps.OnMapReadyCallback
import com.google.android.gms.maps.model.BitmapDescriptorFactory
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.maps.model.MarkerOptions
import com.google.android.gms.maps.model.PolylineOptions
import org.jetbrains.anko.contentView
import javax.inject.Inject

/**
 * @author cbonache
 */
class ShippingMapActivity: BaseActivity(), ShippingMapView, OnMapReadyCallback {


    companion object {

        const val CODE = "code"
        @JvmStatic
        fun getIntent(context: Context): Intent {
            return Intent(context, ShippingMapActivity::class.java)
        }
    }

    @Inject lateinit var presenter: ShippingMapPresenter
    @Inject lateinit var managePermissions: ManagePermissions
    @Inject lateinit var navigator: Navigator
    lateinit var locationManager: LocationManager
    lateinit var mapFragment: MapFragment
    lateinit var googleMap: GoogleMap
    lateinit var geocoder: Geocoder
    lateinit var shippingDestination: String

    override fun onRequestLayout(): Int {
        return R.layout.activity_shipping_map
    }

    override fun onViewLoaded() {
        val code = intent.extras.get(CODE) as String
        setUpActionBar()
        presenter.onStart(code)
    }

    override fun showMap() {

        if (googleServicesAvailable()) {
            mapFragment = fragmentManager.findFragmentById(R.id.frame_map) as MapFragment
            mapFragment.getMapAsync(this)
        }
    }

    override fun drawPolyline(polyOptions: PolylineOptions) {

        googleMap.addPolyline(polyOptions)

        setUpMapClick()
    }

    private fun setUpMapClick() {

        googleMap.setOnMapLongClickListener {
            presenter.onClickMap()
        }
    }

    @SuppressLint("MissingPermission")
    override fun getCurrentLocation(): Location? {
        locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager
        return locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)
    }

    override fun getDestination(): String {
        return shippingDestination
    }

    override fun navigateToGoogleMaps() {

        navigator.navigateToGoogleMapsApps(this, shippingDestination)
    }

    private fun googleServicesAvailable(): Boolean {

        val api = GoogleApiAvailability.getInstance()
        val isAvailable = api.isGooglePlayServicesAvailable(this)
        return isAvailable == ConnectionResult.SUCCESS
    }


    private fun setUpActionBar() {

        supportActionBar?.apply {
            title = getString(R.string.shipping_map)
            setDisplayHomeAsUpEnabled(true)
            setDisplayShowHomeEnabled(true)
        }
    }

    override fun showShippingInfo(shippingViewEntity: ShippingViewEntity) {
        shippingDestination = shippingViewEntity.address + " " + shippingViewEntity.cp + " " + shippingViewEntity.city + " " + shippingViewEntity.country
    }

    override fun requestLocationPermission() {

        val permissionsMessage = getString(R.string.permissions_location_message)
        val listener =
                managePermissions.setAllPermissionsListener(this,
                        contentView as ViewGroup, permissionsMessage, { presenter.onLocationPermissionGranted() })
        managePermissions.setRequestPermissions(this, arrayListOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION), listener)
    }

    override fun onMapReady(googleMap: GoogleMap) {

        this.googleMap = googleMap
        geocoder = Geocoder(this)
        goToLocation(15f)
        presenter.onMapReady(this)

    }


    private fun goToLocation(zoom: Float) {

        val address = geocoder.getFromLocationName(shippingDestination, 1)
        val it = address.first()
        val ll = LatLng(it.latitude, it.longitude)
        val updateCamera = CameraUpdateFactory.newLatLngZoom(ll, zoom)

        googleMap.moveCamera(updateCamera)
        googleMap.addMarker(MarkerOptions().position(ll))
    }

    override fun showLocation(currentLocation: Location?) {

        currentLocation?.let {
            val latlng = LatLng(currentLocation.latitude, currentLocation.longitude)

            val bitmap = getBitmapFromVectorDrawable(this, R.drawable.ic_noun_814594_cc)
            googleMap.addMarker(MarkerOptions().position(latlng).icon(BitmapDescriptorFactory.fromBitmap(bitmap)))
        }
    }

    private fun getBitmapFromVectorDrawable(context: Context, drawableId: Int): Bitmap {
        var drawable = ContextCompat.getDrawable(context, drawableId)
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            drawable = DrawableCompat.wrap(drawable).mutate()
        }

        val bitmap = Bitmap.createBitmap(drawable.intrinsicWidth,
                drawable.intrinsicHeight, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        drawable.setBounds(0, 0, canvas.width, canvas.height)
        drawable.draw(canvas)

        return bitmap
    }
}

This is a missing chapter from Hans Magnus Enzensberger's mathematical
adventure The Number Devil (Henry Holt and Company, New York, 1997). In the
book, a math-hating boy named Robert is visited in his dreams by the clever
Number Devil, who teaches him to love all things numerical. However, we all
forget our dreams from time to time. Here is one adventure that Enzensberger
overlooked, where the Number Devil introduces Robert to geometry not-of-Euclid,
great circles, parallel transport, the pendulum of Foucault, and the genius of
Euler.

In the stability analysis of an equilibrium, given by a stationary point of a
functional F[n] (free energy functional, e.g.), the second derivative of F[n]
plays the essential role. If the system in equilibrium is subject to the
conservation constraint of some extensive property (e.g. volume, material, or
energy conservation), the Euler equation determining the stationary point
corresponding to the equilibrium alters according to the method of Lagrange
multipliers. Here, the question as to how the effects of constraints can be
taken into account in a stability analysis based on second functional
derivatives is examined. It is shown that the concept of constrained second
derivatives incorporates all the effects due to constraints; therefore
constrained second derivatives provide the proper tool for the stability
analysis of equilibria under constraints. For a physically important type of
constraints, it is demonstrated how the presented theory works. Further, the
rigorous derivation of a recently obtained stability condition for a special
case of equilibrium of ultrathin-film binary mixtures is given, presenting a
guide for similar analyses. [For details on constrained derivatives, see also
math-ph/0603027, physics/0603129, physics/0701145.]

Quantum mechanics is difficult to learn because it is counterintuitive, hard
to visualize, mathematically challenging, and abstract. The Physics Education
Technology (PhET) Project, known for its interactive computer simulations for
teaching and learning physics, now includes 18 simulations on quantum mechanics
designed to improve learning of this difficult subject. Our simulations include
several key features to help students build mental models and intuitions about
quantum mechanics: visual representations of abstract concepts and microscopic
processes that cannot be directly observed, interactive environments that
directly couple students' actions to animations, connections to everyday life,
and efficient calculations so students can focus on the concepts rather than
the math. Like all PhET simulations, these are developed using the results of
education research and feedback from educators, and are tested in student
interviews and classroom studies. This article provides an overview of the PhET
quantum simulations and their development. We also describe research
demonstrating their effectiveness and share some insights about student
thinking that we have gained from our research on quantum simulations.

Daganzo's criticisms of second-order fluid approximations of traffic flow [C.
Daganzo, Transpn. Res. B. 29, 277-286 (1995)] and Aw and Rascle's proposal how
to overcome them [A. Aw and M. Rascle, SIAM J. Appl. Math. 60, 916-938 (2000)]
have stimulated an intensive scientific activity in the field of traffic
modeling. Here, we will revisit their arguments and the interpretations behind
them. We will start by analyzing the linear stability of traffic models, which
is a widely established approach to study the ability of traffic models to
describe emergent traffic jams. Besides deriving a collection of useful
formulas for stability analyses, the main attention is put on the
characteristic speeds, which are related to the group velocities of the
linearized model equations. Most macroscopic traffic models with a dynamic
velocity equation appear to predict two characteristic speeds, one of which is
faster than the average velocity. This has been claimed to constitute a
theoretical inconsistency. We will carefully discuss arguments for and against
this view. In particular, we will shed some new light on the problem by
comparing Payne's macroscopic traffic model with the Aw-Rascle model and
macroscopic with microscopic traffic models.

Boussinesq systems of nonlinear partial differential equations are
fundamental equations in geophysical fluid dynamics. In this paper, we use
asymmetric ideas and moving frames to solve the two-dimensional Boussinesq
equations with partial viscosity terms studied by Chae ({\it Adv. Math.} {\bf
203} (2006), 497-513) and the three-dimensional stratified rotating Boussinesq
equations studied by Hsia, Ma and Wang ({\it J. Math. Phys.} {\bf 48} (2007),
no. 6, 06560). We obtain new families of explicit exact solutions with multiple
parameter functions. Many of them are the periodic, quasi-periodic, aperiodic
solutions that may have practical significance. By Fourier expansion and some
of our solutions, one can obtain discontinuous solutions. In addition, Lie
point symmetries are used to simplify our arguments.

We study a simple reaction-diffusion population model [proposed by A. Windus
and H. J. Jensen, J. Phys. A: Math. Theor. 40, 2287 (2007)] on scale-free
networks. In the case of fully random diffusion, the network topology cannot
affect the critical death rate, whereas the heterogeneous connectivity can
cause smaller steady population density and critical population density. In the
case of modified diffusion, we obtain a larger critical death rate and steady
population density, at the meanwhile, lower critical population density, which
is good for the survival of species. The results were obtained using a
mean-field-like framework and were confirmed by computer simulations.

A special version of multi--dimensional simple waves given in [G. Boillat,
{\it J. Math. Phys.} {\bf 11}, 1482-3 (1970)] and [G.M. Webb, R. Ratkiewicz, M.
Brio and G.P. Zank, {\it J. Plasma Phys.} {\bf 59}, 417-460 (1998)] is employed
for fully relativistic fluid and plasma flows. Three essential modes: vortex,
entropy and sound modes are derived where each of them is different from its
nonrelativistic analogue. Vortex and entropy modes are formally solved in both
the laboratory frame and the wave frame (co-moving with the wave front) while
the sound mode is formally solved only in the wave frame at ultra-relativistic
temperatures. In addition, the surface which is the boundary between the
permitted and forbidden regions of the solution is introduced and determined.
Finally a symmetry analysis is performed for the vortex mode equation up to
both point and contact transformations. Fundamental invariants and a form of
general solutions of point transformations along with some specific examples
are also derived.

We analyze the low-energy e-N2 collisions within the framework of the
Modified-Effective Range Theory (MERT) for the long-range potentials, developed
by O'Malley, Spruch and Rosenberg [Journal of Math. Phys. 2, 491 (1961)]. In
comparison to the traditional MERT we do not expand the total cross-section in
the series of the incident momentum \hbar k, but instead we apply the exact
analytical solutions of the Schroedinger equation for the long-range
polarization potential, as proposed in the original formulation of O'Malley et
al. This extends the applicability of MERT up to few eV regime, as we confirm
using some simplified model potential of the electron-molecule interaction. The
parameters of the effective-range expansion (i.e. the scattering length and the
effective range) are determined from experimental, integral elastic cross
sections in the 0.1 - 1.0 eV energy range by fitting procedure. Surprisingly,
our treatment predicts a shape resonance that appears slightly higher than
experimentally well known resonance in the total cross section. Agreement with
the experimentally observed shape-resonance can be improved by assuming the
position of the resonance in a given partial wave. Influence of the quadrupole
potential on resonances is also discussed: we show that it can be disregarded
for N2. In conclusion, the modified-effective range formalism treating the
long-range part of the potential in an exact way, reproduces well both the very
low-energy behavior of the integral cross section as well as the presence of
resonances in the few eV range.

A self-focusing of a coasting relativistic beam in a plasma channel that is
confined by an external magnetic field is studied as a means of reconditioning
the beam emerging from a beam injector [a radio frequency quadrupole (RFQ)] for
a linac. A detailed study of the beam stability in the self-focused beam has
been carried out. In order to explain beam filaments and the resistive hose
instability in a unified way, we treat all the azimuthal modes in the
derivation of the dispersion relation in a finite plasma channel that exhibit
many unstable modes, which are classified by Weinberg's scheme [Steven
Weinberg, J. Math. 8, 614 (1967)].

We present and analyze a penalization method wich extends the the method of
[1] to the case of a rigid body moving freely in an incompressible fluid. The
fluid-solid system is viewed as a single variable density flow with an
interface captured by a level set method. The solid velocity is computed by
averaging at avery time the flow velocity in the solid phase. This velocity is
used to penalize the flow velocity at the fluid-solid interface and to move the
interface. Numerical illustrations are provided to illustrate our convergence
result. A discussion of our result in the light of existing existence results
is also given. [1] Ph. Angot, C.-H. Bruneau and P. Fabrie, A penalization
method to take into account obstacles in incompressible viscous flows, Numer.
Math. 81: 497--520 (1999)

A unified energy principle approach is presented for analysing the
magnetohydrodynamic (MHD) stability of plasmas consisting of multiple ideal and
relaxed regions. By choosing an appropriate gauge, we show that the plasma
displacement satisfies the same Euler-Lagrange equation in ideal and relaxed
regions, except in the neighbourhood of magnetic surfaces. The difference at
singular surfaces is analysed in cylindrical geometry: in ideal MHD only
Newcomb's [W. A. Newcomb (2006) Ann. Phys., 10, 232] small solutions are
allowed, whereas in relaxed MHD only the odd-parity large solution and
even-parity small solution are allowed. A procedure for constructing global
multi-region solutions in cylindrical geometry is presented. Focussing on the
limit where the two interfaces approach each other arbitrarily closely, it is
shown that the singular-limit problem encountered previously [M.J. Hole et al.
(2006) J. Plasma Phys., 77, 1167] in multi-region relaxed MHD is stabilised if
the relaxed-MHD region between the coalescing interfaces is replaced by an
ideal-MHD region. We then present a stable (k, pressure) phase space plot,
which allows us to determine the form a stable pressure and field profile must
take in the region between the interfaces. From this knowledge, we conclude
that there exists a class of single interface plasmas that were found stable by
Kaiser and Uecker [R. Kaiser et al (2004) Q. Jl Mech. Appl. Math., 57, 1], but
are shown to be unstable when the interface is resolved.

This article is the continued version of the analytical solutions for the
pressureless Navier-Stokes equations with density-dependent viscosity in "M.W.
Yuen, Analyitcal Solutions to the Navier-Stokes Equations, J. Math. Phys., 49
(2008) No. 11, 113102, 10pp". We are able to extend the similar solutions
structure to the case with pressure under some restriction for $\gamma$ and
$\theta$.

We point out that the {\em spacetime void} inferred by Castro[J. Math. Phys.
49, 042501, (2008)] results from his choice of a discontinuous radial gauge.
Further since the integration constant $\alpha_0 = 2M_0$ ($G=c=1$) occurring in
the vacuum Hilbert/Schwarzschild solution of a neutral "point mass" is zero
[Arnowitt et al., in Gravitation: An Introduction to Current Research, ed. L.
Witten, Wiley, Chap. 7, p.227; also Phys. Rev. Lett., 4, 375, (1960)]; A.
Mitra, Adv. Sp. Res., 38, 2917 (2006)] Castro's gauge reduces to the well
behaved and physical Hilbert gauge. Physically this means that true
Hilbert/Schwarzschild black holes have unique gravitational mass M=0.
Accordingly, the unphysical {\em spacetime viod} inferred by Castro is actually
non-existent.

This work is directed towards investigating the fate of three-dimensional
long perturbation waves in a plane incompressible wake. The analysis is posed
as an initial-value problem in space. More specifically, input is made at an
initial location in the downstream direction and then tracing the resulting
behavior further downstream subject to the restriction of finite kinetic
energy. This presentation follows the outline given by Criminale and Drazin
[Stud. in Applied Math. \textbf{83}, 123 (1990)] that describes the system in
terms of perturbation vorticity and velocity. The analysis is based on large
scale waves and expansions using multi scales and multi times for the partial
differential equations. The multiscaling is based on an approach where the
small parameter is linked to the perturbation property independently from the
flow control parameter. Solutions of the perturbative equations are determined
numerically after the introduction of a regular perturbation scheme
analytically deduced up to the second order. Numerically, the complete linear
system is also integrated. Since the results relevant to the complete problem
are in very good agreement with the results of the first order analysis, the
numerical solution at the second order was deemed not necessary. The use for an
arbitrary initial-value problem will be shown to contain a wealth of
information for the different transient behaviors associated to the symmetry,
angle of obliquity and spatial decay of the long waves. The amplification
factor of transversal perturbations never presents the trend - a growth
followed by a long damping - usually seen in waves with wavenumber of order one
or less. Asymptotical instability is always observed.

In some recent works [G. Dimarco, L. Pareschi, Hybrid multiscale methods I.
Hyperbolic Relaxation Problems, Comm. Math. Sci., 1, (2006), pp. 155-177], [G.
Dimarco, L. Pareschi, Hybrid multiscale methods II. Kinetic equations, SIAM
Multiscale Modeling and Simulation Vol 6., No 4,pp. 1169-1197, (2008)] we
developed a general framework for the construction of hybrid algorithms which
are able to face efficiently the multiscale nature of some hyperbolic and
kinetic problems. Here, at variance with respect to the previous methods, we
construct a method form-fitting to any type of finite volume or finite
difference scheme for the reduced equilibrium system. Thanks to the coupling of
Monte Carlo techniques for the solution of the kinetic equations with
macroscopic methods for the limiting fluid equations, we show how it is
possible to solve multiscale fluid dynamic phenomena faster with respect to
traditional deterministic/stochastic methods for the full kinetic equations. In
addition, due to the hybrid nature of the schemes, the numerical solution is
affected by less fluctuations when compared to standard Monte Carlo schemes.
Applications to the Boltzmann-BGK equation are presented to show the
performance of the new methods in comparison with classical approaches used in
the simulation of kinetic equations.

In this work we study the hemodynamics in a stented artery connected either
to a collateral artery or to an aneurysmal sac. The blood flow is driven by the
pressure drop. Our aim is to characterize the flow-rate and the pressure in the
contiguous zone to the main artery: using boundary layer theory we construct a
homogenized first order approximation with respect to epsilon, the size of the
stent's wires. This provides an explicit expression of the velocity profile
through and along the stent. The profile depends only on the input/output
pressure data of the problem and some homogenized constant quantities: it is
explicit. In the collateral artery this gives the flow-rate. In the case of the
aneurysm, it shows that : (i) the zeroth order term of the pressure in the sac
equals the averaged pressure along the stent in the main artery, (ii) the
presence of the stent inverses the rotation of the vortex. Extending the tools
set up in [Bonnetier et al, Adv. Math. Fluids, 2009, Milisic, Meth. Apl. Ann.,
2009] we prove rigorously that our asymptotic approximation is first order
accurate with respect to . We derive then new implicit interface conditions
that our approximation formally satisfies, generalizing our analysis to other
possible geometrical configurations. In the last part we provide numerical
results that illustrate and validate the theoretical approach.

We show that the exact integrator for the classical Kepler motion, recently
found by Kozlov ({\it J. Phys. A: Math. Theor.\} {\bf 40} (2007) 4529-4539),
can be derived in a simple natural way (using well known exact discretization
of the harmonic oscillator). We also turn attention on important earlier
references, where the exact discretization of the 4-dimensional isotropic
harmonic oscillator has been applied to the perturbed Kepler problem.

Expansion of a wave function in a basis of eigenfunctions of a differential
eigenvalue problem lies at the heart of the R-matrix methods for both the
Schr\"odinger and Dirac particles. A central issue that should be carefully
analyzed when functional series are applied is their convergence. In the
present paper, we study the properties of the eigenfunction expansions
appearing in nonrelativistic and relativistic $R$-matrix theories. In
particular, we confirm the findings of Rosenthal [J. Phys. G: Nucl. Phys. 13,
491 (1987)] and Szmytkowski and Hinze [J. Phys. B: At. Mol. Opt. Phys. 29, 761
(1996); J. Phys. A: Math. Gen. 29, 6125 (1996)] that in the most popular
formulation of the R-matrix theory for Dirac particles, the functional series
fails to converge to a claimed limit.

In one of the very few exact quantum mechanical calculations of fugacity
coefficients, Dodd and Gibbs (\textit{J. Math.Phys}.,\textbf{15}, 41 (1974))
obtained $b_{2}$ and $b_{3}$ for a one dimensional Bose gas, subject to
repulsive delta-function interactions, by direct integration of the wave
functions. For $b_{2}$, we have shown (\textit{Mol. Phys}.,\textbf{103}, 1301
(2005)) that Dodd and Gibbs' result can be obtained from a phase shift
formalism, if one also includes the contribution of oscillating terms, usually
contributing only in 1 dimension. Now, we develop an exact expression for
$b_{3}-b_{3}^{0}$ (where $b_{3}^{0}$ is the free particle fugacity coefficient)
in terms of sums and differences of 3-body eigenphase shifts. Further, we show
that if we obtain these eigenphase shifts in a distorted-Born approximation,
then, to first order, we reproduce the leading low temperature behaviour,
obtained from an expansion of the two-fold integral of Dodd and Gibbs. The
contributions of the oscillating terms cancel. The formalism that we propose is
not limited to one dimension, but seeks to provide a general method to obtain
virial coefficients, fugacity coefficients, in terms of asymptotic quantities.
The exact one dimensional results allow us to confirm the validity of our
approach in this domain.

In this paper we propose an alternative approach for the assessment of
network vulnerability under random and intentional attacks as compared to the
results obtained from the "vulnerability function" given by Criado et al.
[Criado et al. (Int. J. Comput. Math., 86 (2) (2009), pp. 209-218)]. By using
spectral and statistical measurements, we assess robustness as the antonym to
vulnerability of complex networks and suggest a tentative ranking for
vulnerability, based on the interpretation of quantified network
characteristics. We conclude that vulnerability function, derived from the
network's degree distribution and its variations only, is not general enough to
reflect the lack of robustness due to the specific configurations in graphs
with hierarchical or centralized structures. The spectral and statistical
metrics, on the other hand, capture different aspects of network topology which
provide a more thorough assessment of network vulnerability.

For the first time the kinetic description of Landau diamagnetism for
degenerate collisional plasma is given. The correct expression for transverse
electric conductivity of the quantum plasma, found by authors (see
arXiv:1002.1017 [math-ph] 4 Feb 2010) is used. In work S. Dattagupta, A.M.
Jayannavar and N. Kumar [Current science, V. 80, No. 7, 10 April, 2001] was
discussed the important problem of dissipation (collisions) influence on Landau
diamagnetism. The analysis of this problem is given with the use of exact
expression for transverse conductivity of quantum plasma.

The Fast Multipole Method (FMM) is well known to possess a bottleneck arising
from decreasing workload on higher levels of the FMM tree [Greengard and Gropp,
Comp. Math. Appl., 20(7), 1990]. We show that this potential bottleneck can be
eliminated by overlapping multipole and local expansion computations with
direct kernel evaluations on the finest level grid.

Dynamics of a randomly-perturbed quantum system with 3/2-degrees of freedom
is considered. We introduce a transfer operator being the quantum analogue of
the specific Poincar\'e map. This map was proposed in (Makarov, Uleysky, J.
Phys. A: Math. Gen., 2006) for exploring domains of finite-time stability,
which survive under random excitation. Our attention is concentrated on level
spacing distribution of the transfer operator, averaged over ensemble of
realizations. The problem of sound propagation in an oceanic waveguide is
considered as an example. For the acoustic frequency of 200 Hz, level spacing
distribution undergoes the crossover from Poissonian to Wigner-like statistics
with increasing time, as it is consistent with classical predictions via the
specific Poincar\'e map. For the frequency of 600 Hz, the level spacing
statistics becomes non-universal due to large number of nearly-degenerate
levels whose contribution grows with time. Occurrence of nearly-degenerate
levels is attributed to bifurcations of classical periodic orbits, caused by
fast spatial oscillations of the random perturbation.

Research of influence of collisions on Friedel oscillations in quantum
degenerate collisional plasma (T=0) is carried out for the first time. It is
shown that presence of collisions in plasma leads to exponential decreasing of
amplitude and phase shift of the Friedel oscillations. In linear approximation
the phase shift is equal to the half of quantity inverse to product of Fermi's
wave number by free length path of electrons. The correct expression for
longitudinal dielectric permeability of the quantum collisional plasma found by
the authors (see arxiv:1001.3937 [math-ph] 22 Jan 2010) is used.

An Horizontal Visibility Graph (for short, HVG) is defined in association
with an ordered set of non-negative reals. HVGs realize a methodology in the
analysis of time series, their degree distribution being a good discriminator
between randomness and chaos [B. Luque, et al., Phys. Rev. E 80 (2009),
046103]. We prove that a graph is an HVG if and only if outerplanar and has a
Hamilton path. Therefore, an HVG is a noncrossing graph, as defined in
algebraic combinatorics [P. Flajolet and M. Noy, Discrete Math., 204 (1999)
203-229]. Our characterization of HVGs implies a linear time recognition
algorithm. Treating ordered sets as words, we characterize subfamilies of HVGs
highlighting various connections with combinatorial statistics and introducing
the notion of a visible pair. With this technique we determine asymptotically
the average number of edges of HVGs.

We argue that there is a fundamental problem regarding the analysis that
serves as the foundation for the papers {\it Information theory explanation of
the fluctuation theorem, maximum entropy production and self-organized
criticality in non-equilibrium stationary states} [R. Dewar, J. Phys. A: Math.
Gen. {\bf 36} (2003), 631-641] and {\it Maximum entropy production and the
fluctuation theorem} [R. Dewar, J. Phys. A: Math. Gen. {\bf 38} (2005),
L371-L381]. In particular, we demonstrate that this analysis is based on an
assumption that is physically unrealistic and that, hence, the results obtained
in those papers cannot be regarded as physically meaningful.

A paradigm based on the absolute equilibrium of Galerkin-truncated inviscid
systems to aid in understanding turbulence [T.-D. Lee, "On some statistical
properties of hydrodynamical and magnetohydrodynamical fields," Q. Appl. Math.
10, 69 (1952)] is taken to study gyrokinetic plasma turbulence: A finite set of
Fourier modes of the collisionless gyrokinetic equations are kept and the
statistical equilibria are calculated; possible implications for plasma
turbulence in various situations are discussed. For the case of two spatial and
one velocity dimension, in the calculation with discretization also of velocity
$v$ with $N$ grid points (where $N+1$ quantities are conserved, corresponding
to an energy invariant and $N$ entropy-related invariants), the negative
temperature states, corresponding to the condensation of the generalized energy
into the lowest modes, are found. This indicates a generic feature of inverse
energy cascade. Comparisons are made with some classical results, such as those
of Charney-Hasegawa-Mima in the cold-ion limit. There is a universal shape for
statistical equilibrium of gyrokinetics in three spatial and two velocity
dimensions with just one conserved quantity. Possible physical relevance to
turbulence, such as ITG zonal flows, and to a critical balance hypothesis are
also discussed.

By applying Birkhoff's theorem to the problem of the general relativistic
collapse of a uniform density dust, we directly show that the density of the
dust $\rho=0$ even when its proper number density $n$ would be assumed to be
finite! The physical reason behind this exact result can be traced back to the
observation of Arnowitt et al. that the gravitational mass of a neutral point
particle is zero: $m=0$ (PRL, 4, 375, 1960). And since, a dust is a mere
collection of {\em neutral point particles, unlike a continuous hydrodynamic
fluid}, its density $\rho = m n=0$. It is nonetheless found that for $k=-1$, a
homogeneous dust can collapse and expand special relativistically in the
fashion of a Milne universe. Thus, in reality, general relativistic homogeneous
dust collapse does not lead to the formation of any black hole in conformity of
many previous studies (Logunov, Mestverishvili, Kiselev, Phys.Part.Nucl. 37,
317, 2006; Kisevev, Logunov & Mestvirishvili, Theor. Math. Phys., 164, 972,
2010; Mitra, J. Math. Phys. 50, 042502, 2009; Suggett, J. Phys. A, 12, 375
1979).
  Interestingly, this result is in agreement with the intuition of Oppenheimer
& Snyder (Phys. Rev. 56, p.456, 1939) too:
  "Physically such a singularity would mean that the expressions used for the
energy-momentum tensor does not take into account some essential physical fact
which would really smooth the singularity out. Further, a star in its early
stages of development would not possess a singular density or pressure, it is
impossible for a singularity to develop in a finite time."

The purpose of the present paper is to study the influence of wall-echo on
pressure fluctuations $p'$, and on statistical correlations containing $p'$,
{\em viz} redistribution $\phi_{ij}$, pressure diffusion $d_{ij}^{(p)}$, and
velocity/pressure-gradient $\Pi_{ij}$. We extend the usual analysis of
turbulent correlations containing pressure fluctuations in wall-bounded
\tsc{dns} computations [Kim J.: {\em J. Fluid Mech.} {\bf 205} (1989)
421--451], separating $p'$ not only into rapid $p_{(\mathrm{r})}'$ and slow
$p_{(\mathrm{s})}'$ parts [Chou P.Y.: {\em Quart. Appl. Math.} {\bf 3} (1945)
38--54], but further into volume ($p'_{(\mathrm{r};\mathfrak{V})}$ and
$p'_{(\mathrm{s};\mathfrak{V})}$) and surface (wall-echo; $p'_{(\mathrm{r};w)}$
and $p'_{(\mathrm{s};w)}$) terms. An algorithm, based on a Green's function
approach, is developed to compute the above splittings for various correlations
containing pressure fluctuations (redistribution, pressure diffusion,
velocity/pressure-gradient), in fully developed turbulent plane channel flow.
This exact analysis confirms previous results based on a method-of-images
approximation [Manceau R., Wang M., Laurence D.: {\em J. Fluid Mech.} {\bf 438}
(2001) 307--338] showing that, at the wall, $p'_{(\mathfrak{V})}$ and
$p'_{(w)}$ are usually of the same sign and approximately equal. The above
results are then used to study the contribution of each mechanism on the
pressure correlations in low Reynolds-number plane channel flow, and to discuss
standard second-moment-closure modelling practices.

In several applications, such as \tsc{weno} interpolation and reconstruction
[Shu C.W.: SIAM Rev. 51 (2009) 82--126], we are interested in the analytical
expression of the weight-functions which allow the representation of the
approximating function on a given stencil (Chebyshev-system) as the weighted
combination of the corresponding approximating functions on substencils
(Chebyshev-subsystems). We show that the weight-functions in such
representations [M\"uhlbach G.: Num. Math. 31 (1978) 97--110] can be generated
by a general recurrence relation based on the existence of a 1-level
subdivision rule. As an example of application we apply this recurrence to the
computation of the weight-functions for Lagrange interpolation [Carlini E.,
Ferretti R., Russo G.: SIAM J. Sci. Comp. 27 (2005) 1071--1091] for a general
subdivision of the stencil ${x_{i-M_-},...,x_{i+M_+}}$ of $M+1:=M_-+M_++1$
distinct ordered points into $K_\mathrm{s}+1\leq M:=M_-+M_+>1$ (Neville)
substencils ${x_{i-M_-+k_\mathrm{s}},...,x_{i+M_+-K_\mathrm{s}+k_\mathrm{s}}}$
($k_\mathrm{s}\in{0,...,K_\mathrm{s}}$) all containing the same number of
$M-K_\mathrm{s}+1$ points but each shifted by 1 cell with respect to its
neighbour, and give a general proof for the conditions of positivity of the
weight-functions (implying convexity of the combination), extending previous
results obtained for particular stencils and subdvisions [Liu Y.Y., Shu C.W.,
Zhang M.P.: Acta Math. Appl. Sinica 25 (2009) 503--538]. Finally, we apply the
recurrence relation to the representation by combination of substencils of
derivatives of arbitrary order of the Lagrange interpolating polynomial.

The Lagrange reconstructing polynomial [Shu C.W.: {\em SIAM Rev.} {\bf 51}
(2009) 82--126] of a function $f(x)$ on a given set of equidistant ($\Delta
x=\const$) points $\bigl\{x_i+\ell\Delta x;\;\ell\in\{-M_-,...,+M_+\}\bigr\}$
is defined [Gerolymos G.A.: {\em J. Approx. Theory} {\bf 163} (2011) 267--305]
as the polynomial whose sliding (with $x$) averages on $[x-\tfrac{1}{2}\Delta
x,x+\tfrac{1}{2}\Delta x]$ are equal to the Lagrange interpolating polynomial
of $f(x)$ on the same stencil. We first study the fundamental functions of
Lagrange reconstruction, show that these polynomials have only real and
distinct roots, which are never located at the cell-interfaces (half-points)
$x_i+n\tfrac{1}{2}\Delta x$ ($n\in\mathbb{Z}$), and obtain several identities.
Using these identities, by analogy to the recursive Neville-Aitken-like
algorithm applied to the Lagrange interpolating polynomial, we show that there
exists a unique representation of the Lagrange reconstructing polynomial on
$\{i-M_-,...,i+M_+\}$ as a combination of the Lagrange reconstructing
polynomials on the $K_\mathrm{s}+1\leq M:=M_-+M_+>1$ substencils
$\{i-M_-+k_\mathrm{s},...,i+M_+-K_\mathrm{s}+k_\mathrm{s}\}$
($k_\mathrm{s}\in\{0,...,K_\mathrm{s}\}$), with weights
$\sigma_{R_1,M_-,M_+,K_\mathrm{s},k_\mathrm{s}}(\xi)$ which are rational
functions of $\xi$ ($x=x_i+\xi\Delta x$) [Liu Y.Y., Shu C.W., Zhang M.P.: {\em
Acta Math. Appl. Sinica} {\bf 25} (2009) 503--538], and give an analytical
recursive expression of the weight-functions. We then use the analytical
expression of the weight-functions
$\sigma_{R_1,M_-,M_+,K_\mathrm{s},k_\mathrm{s}}(\xi)$ to obtain a formal proof
of convexity (positivity of the weight-functions) in the neighborhood of
$\xi=\tfrac{1}{2}$, under the condition that all of the substencils contain
either point $i$ or point $i+1$ (or both).

We present modeling of the incompressible viscous flows in the domain
containing an unconfined fluid and a porous medium. For such setting a rigorous
derivation of the Beavers-Joseph-Saffman interface condition was undertaken by
J\"ager and Mikeli\'c [SIAM J. Appl. Math. \rm 60 (2000), p. 1111-1127] using
the homogenization method. So far the interface law for the pressure was
conceived and confirmed only numerically. In this article we justify rigorously
the pressure jump condition using the corresponding boundary layer.

There were elaborated different models of Finsler geometry using the Cartan
(metric compatible), or Berwald and Chern (metric non-compatible) connections,
the Ricci flag curvature etc. In a series of works, we studied (non)commutative
metric compatible Finsler and nonholonomic generalizations of the Ricci flow
theory [see S. Vacaru, J. Math. Phys. 49 (2008) 043504; 50 (2009) 073503 and
references therein]. The goal of this work is to prove that there are some
models of Finsler gravity and geometric evolution theories with generalized
Perelman's functionals, and correspondingly derived nonholonomic Hamilton
evolution equations, when metric noncompatible Finsler connections are
involved. Following such an approach, we have to consider distortion tensors,
uniquely defined by the Finsler metric, from the Cartan and/or the canonical
metric compatible connections. We conclude that, in general, it is not possible
to elaborate self-consistent models of geometric evolution with arbitrary
Finsler metric noncompatible connections.

In the present work we analyze the problem of adaptation and evolution of RNA
virus populations, by defining the basic stochastic model as a multivariate
branching process in close relation with the branching process advanced by
Demetrius, Schuster and Sigmund ("Polynucleotide evolution and branching
processes", Bull. Math. Biol. 46 (1985) 239-262), in their study of
polynucleotide evolution. We show that in the absence of beneficial forces the
model is exactly solvable. As a result it is possible to prove several key
results directly related to known typical properties of these systems like (i)
proof, in the context of the theory of branching processes, of the lethal
mutagenesis criterion proposed by Bull, Sanju\'an and Wilke ("Theory of lethal
mutagenesis for viruses", J. Virology 18 (2007) 2930-2939); (ii) a new proposal
for the notion of relaxation time with a quantitative prescription for its
evaluation and (iii) the quantitative description of the evolution of the
expected values in four distinct regimes: transient, "stationary" equilibrium,
extinction threshold and lethal mutagenesis. Moreover, new insights on the
dynamics of evolving virus populations can be foreseen.

Following our paper [J. Math. Phys. 50 (2009) 123102], we systematically
carry out Lie symmetry analysis for the barotropic vorticity equation on the
rotating sphere. All finite-dimensional subalgebras of the corresponding
maximal Lie invariance algebra, which is infinite-dimensional, are classified.
Appropriate subalgebras are then used to exhaustively determine Lie reductions
of the equation under consideration. The relevance of the constructed exact
solutions for the description of real-world physical processes is discussed. It
is shown that the results of the above paper are directly related to the
results of the recent letter by N. H. Ibragimov and R. N. Ibragimov [Phys.
Lett. A 375 (2011) 3858] in which Lie symmetries and some exact solutions of
the nonlinear Euler equations for an atmospheric layer in spherical geometry
were determined.

We provide direct evidence of market manipulation at the beginning of the
financial crisis in November 2007. The type of manipulation, a "bear raid,"
would have been prevented by a regulation that was repealed by the Securities
and Exchange Commission in July 2007. The regulation, the uptick rule, was
designed to prevent manipulation and promote stability and was in force from
1938 as a key part of the government response to the 1929 market crash and its
aftermath. On November 1, 2007, Citigroup experienced an unusual increase in
trading volume and decrease in price. Our analysis of financial industry data
shows that this decline coincided with an anomalous increase in borrowed
shares, the selling of which would be a large fraction of the total trading
volume. The selling of borrowed shares cannot be explained by news events as
there is no corresponding increase in selling by share owners. A similar number
of shares were returned on a single day six days later. The magnitude and
coincidence of borrowing and returning of shares is evidence of a concerted
effort to drive down Citigroup's stock price and achieve a profit, i.e., a bear
raid. Interpretations and analyses of financial markets should consider the
possibility that the intentional actions of individual actors or coordinated
groups can impact market behavior. Markets are not sufficiently transparent to
reveal even major market manipulation events. Our results point to the need for
regulations that prevent intentional actions that cause markets to deviate from
equilibrium and contribute to crashes. Enforcement actions cannot reverse
severe damage to the economic system. The current "alternative" uptick rule
which is only in effect for stocks dropping by over 10% in a single day is
insufficient. Prevention may be achieved through improved availability of
market data and the original uptick rule or other transaction limitations.

In a previous paper (S. Ghosal and Z. Chen Bull. Math. Biol. 2010, vol. 72,
pg. 2047) it was shown that the evolution of the solute concentration in
capillary electrophoresis is described by a nonlinear wave equation that
reduced to Burger's equation if the nonlinearity was weak. It was assumed that
only strong electrolytes (fully dissociated) were present. In the present paper
it is shown that the same governing equation also describes the situation where
the electrolytic buffer consists of a single weak acid (or base). A simple
approximate formula is derived for the dimensionless peak variance which is
shown to agree well with published experimental data.

The differential migration of ions in an applied electric field is the basis
for separation of chemical species by capillary electrophoresis. Axial
diffusion of the concentration peak limits the separation efficiency.
Electromigration dispersion is observed when the concentration of sample ions
is comparable to that of the background ions. Under such conditions, the local
electrical conductivity is significantly altered in the sample zone making the
electric field, and therefore, the ion migration velocity concentration
dependent. The resulting nonlinear wave exhibits shock like features, and,
under certain simplifying assumptions, is described by Burgers' equation (S.
Ghosal and Z. Chen Bull. Math. Biol. 2010, vol.72, pg. 2047).In this paper, we
consider the more general situation where the walls of the separation channel
may have a non-zero zeta potential and are therefore able to sustain an
electro-osmotic bulk flow. The main result is a one dimensional nonlinear
advection diffusion equation for the area averaged concentration. This
homogenized equation accounts for the Taylor-Aris dispersion resulting from the
variation in the electro-osmotic slip velocity along the wall. It is shown that
in a certain range of parameters, the electro-osmotic flow can actually reduce
the total dispersion by delaying the formation of a concentration shock.
However, if the electro-osmotic flow is sufficiently high, the total dispersion
is increased because of the Taylor-Aris contribution.

In this paper we revisit and adapt to viral evolution an approach based on
the theory of branching process advanced by Demetrius, Schuster and Sigmund
("Polynucleotide evolution and branching processes", Bull. Math. Biol. 46
(1985) 239-262), in their study of polynucleotide evolution. By taking into
account beneficial effects we obtain a non-trivial multivariate generalization
of their single-type branching process model. Perturbative techniques allows us
to obtain analytical asymptotic expressions for the main global parameters of
the model which lead to the following rigorous results: (i) a new criterion for
"no sure extinction", (ii) a generalization and proof, for this particular
class of models, of the lethal mutagenesis criterion proposed by Bull,
Sanju\'an and Wilke ("Theory of lethal mutagenesis for viruses", J. Virology 18
(2007) 2930-2939), (iii) a new proposal for the notion of relaxation time with
a quantitative prescription for its evaluation, (iv) the quantitative
description of the evolution of the expected values in in four distinct
"stages": extinction threshold, lethal mutagenesis, stationary "equilibrium"
and transient. Finally, based on these quantitative results we are able to draw
some qualitative conclusions.

There is a very reason to consider that to solve Zeno's paradoxes is to
propose the theory of mechanical world view. We believe that this is not only
our opinion but also most philosophers' opinion. Recently, in order to justify
Heisenberg`s uncertainty principle (cf. Rep. Math. Phys Vol. 29, No. 3, 1991)
more firmly. we proposed the linguistic interpretation of quantum mechanics
(called quantum and classical measurement theory), which was characterized as
the metaphysical and linguistic turn of the Copenhagen interpretation. This
turn from physics to language does not only extend quantum mechanicsto
classical systems but also yield the (quantum and classical) mechanical world
view (and therefore, establish the method of science). If it be so, we may
assert that Zeno's paradoxes (Flying Arrow Paradox, Achilles and the tortoise,
etc.) were already solved in measurement theory. The purpose of this paper is
to examine this assertion.

In capillary electrophoresis, sample ions migrate along a micro-capillary
filled with a background electrolyte under the influence of an applied electric
field. If the sample concentration is sufficiently high, the electrical
conductivity in the sample zone could differ significantly from the
background.Under such conditions, the local migration velocity of sample ions
becomes concentration dependent resulting in a nonlinear wave that exhibits
shock like features. If the nonlinearity is weak, the sample concentration
profile, under certain simplifying assumptions, can be shown to obey Burgers'
equation (S. Ghosal and Z. Chen Bull. Math. Biol. 2010, 72(8), pg. 2047) which
has an exact analytical solution for arbitrary initial condition.In this paper,
we use a numerical method to study the problem in the more general case where
the sample concentration is not small in comparison to the concentration of
background ions. In the case of low concentrations, the numerical results agree
with the weakly nonlinear theory presented earlier, but at high concentrations,
the wave evolves in a way that is qualitatively different.

We show how Noether conservation laws can be obtained from the particle
relabelling symmetries in the Euler-Poincar\'e theory of ideal fluids with
advected quantities. All calculations can be performed without Lagrangian
variables, by using the Eulerian vector fields that generate the symmetries,
and we identify the time-evolution equation that these vector fields satisfy.
When advected quantities (such as advected scalars or densities) are present,
there is an additional constraint that the vector fields must leave the
advected quantities invariant. We show that if this constraint is satisfied
initially then it will be satisfied for all times. We then show how to solve
these constraint equations in various examples to obtain evolution equations
from the conservation laws. We also discuss some fluid conservation laws in the
Euler-Poincar\'e theory that do not arise from Noether symmetries, and explain
the relationship between the conservation laws obtained here, and the
Kelvin-Noether theorem given in Section 4 of Holm, Marsden and Ratiu, {\it Adv.
in Math.}, 1998.

This note is a correction to a paper of Cortez, Peskin, Stockie & Varela
[SIAM J. Appl. Math., 65(2):494-520, 2004], who studied the stability of a
parametrically-forced, circular, elastic fiber immersed in an incompressible
fluid in 2D, and showed the existence of parametric resonance. The results were
represented as plots that separate parameter space into regions where the
solution is either stable or unstable. We uncovered two errors in the paper:
the first was in the derivation of the eigenvalue problem, and the second was
in the code to used to calculate the stability contours.

A model of discrete space-time is presented which is, in a sense, both
Lorentz invariant and has no restriction on the relative velocity between
particles (except v < c). The space-time has an inbuilt indeterminacy.
  Published originally as 'A quantisation of time', J. Phys. A: Math. Gen., 10,
2115, 1977; identical to the original, apart from one or two minor corrections,
and some simplification towards the end of Section 6. The paper presents a
discrete model of time, in which the latter comprises a succession of instants
which are identified as collisions with particles called chronons. Proper-time
intervals are discrete; the structure of space-time is given by a radar map and
has an inbuilt indeterminacy, which leads naturally to Heisenberg's uncertainty
principle. If I were writing this paper today I would identify the chronon with
the virtual Higgs boson. Without the latter all particles would be massless and
would follow null paths; there would be no such thing as proper time. Time is
an emergent phenomenon, and the Higgs boson is the agent of that emergence.

Undergraduate research is widely regarded as a high impact practice. However,
usually only the highest achieving students are rewarded with undergraduate
research opportunities. This paper reports on the successful implementation of
a student research program offering the weakest 10% of incoming freshmen
opportunities to conduct original research in one of several science or
engineering disciplines with the possibility of publication if the research and
report meet a suitable standard, defined as earning an A on the final research
project report in the introductory math course. The opportunity has been
offered now for two years to incoming cadets at the United States Air Force
Academy who are placed in Basic Math. The cadets placed in this course score in
the bottom 5% of incoming cadets on the math placement exam. During the second
semester of their freshman year, cadets enrolled in Calculus 1 are also offered
a similar research opportunity. About 10% of cadets are enrolled in this course
each Spring, the 5% who began in Basic Math and matriculate to Calculus 1 and
the 5% who failed Calculus 1 in their first attempt. During the first four
semesters, the program has yielded 22 cadet papers which have been published or
are currently under review and expected to be published. This represents
approximately 38% of the projects in the program, because the majority of the
projects do not earn As and are not suitable for publication. Over 80% of the
cadet co-authors on the publication quality papers are minorities, women,
and/or intercollegiate athletes.

We introduce an analytical kernel, the "cusp" kernel, to model the effects of
velocity-changing collisions on optically pumped atoms in low-pressure buffer
gases. Like the widely used Keilson-Storer kernel [J. Keilson and J. E. Storer,
Q. Appl. Math. 10, 243 (1952)], cusp kernels are characterized by a single
parameter and preserve a Maxwellian velocity distribution. Cusp kernels and
their superpositions are more useful than Keilson-Storer kernels, because they
are more similar to real kernels inferred from measurements or theory and are
easier to invert to find steady-state velocity distributions.

We apply our general method of duality, introduced in [Giardina', Kurchan,
Redig, J. Math. Phys. 48, 033301 (2007)], to models of population dynamics. The
classical dualities between forward and ancestral processes can be viewed as a
change of representation in the classical creation and annihilation operators,
both for diffusions dual to coalescents of Kingman's type, as well as for
models with finite population size. Next, using SU(1,1) raising and lowering
operators, we find new dualities between the Wright-Fisher diffusion with $d$
types and the Moran model, both in presence and absence of mutations. These new
dualities relates two forward evolutions. From our general scheme we also
identify self-duality of the Moran model.

The Generalized Riemann Problems (GRP) for nonlinear hyperbolic systems of
balance laws in one space dimension are now well-known and can be formulated as
follows: Given initial-data which are smooth on two sides of a discontinuity,
determine the time evolution of the solution near the discontinuity. While the
classical Riemann problem serves as a primary building block in the
construction of many numerical schemes (most notably the Godunov scheme), the
analytic study of GRP will lead to an array of GRP schemes, which extend the
Godunov scheme. Currently there are extensive studies on the second-order GRP
scheme, which proves to be robust and is capable of resolving complex
multidimensional fluid dynamic problems [M. Ben-Artzi and J. Falcovitz,
"Generalized Riemann Problems in Computational Fluid Dynamics", Cambridge
University Press, 2003]. A more general formulation of the second-order GRP
solver is still confined with a class of weakly coupled systems [Numer. Math.
(2007) 106:369-425]. This paper provides a unified approach for solving the GRP
in the general context of hyperbolic balance laws, without weakly coupled
constraint, towards high order accuracy. The derivation of the second-order GRP
solver is more concise compared to those in previous works and the third-order
quadratic GRP is resolved for the first time. The latter is shown to be
necessary through numerical experiments with strong discontinuities. Our method
relies heavily on the new treatment of the rarefaction wave by deriving the
L(Q)-equations, an ODE system capturing the "evolution" of the characteristic
derivatives in x-t space for generalized Riemann invariants. The case of a
sonic point is incorporated into a general treatment. The accuracy of the
derived GRP solvers are justified and numerical examples are presented for the
performance of the resulting scheme.

The highest level of mathematics research is traditionally seen as a solitary
activity. Yet new innovations by mathematicians themselves are starting to
harness the power of social computation to create new modes of mathematical
production. We study the effectiveness of one such system, and make proposals
for enhancement, drawing on AI and computer based mathematics. We analyse the
content of a sample of questions and responses in the community question
answering system for research mathematicians, math-overflow. We find that
mathoverflow is very effective, with 90% of our sample of questions answered
completely or in part. A typical response is an informal dialogue, allowing
error and speculation, rather than rigorous mathematical argument: 37% of our
sample discussions acknowledged error. Responses typically present information
known to the respondent, and readily checked by other users: thus the
effectiveness of mathoverflow comes from information sharing. We conclude that
extending and the power and reach of mathoverflow through a combination of
people and machines raises new challenges for artificial intelligence and
computational mathematics, in particular how to handle error, analogy and
informal reasoning.

With the use of correct expression of the electric conductivity of quantum
collisional degenerate plasmas (A. V. Latyshev and A. A. Yushkanov, Transverse
electrical conductivity of a quantum collisional plasma in the Mermin approach,
- Theor. and Math. Phys., {\bf 175}(1): 559-569 (2013)) the kinetic description
of a magnetic susceptibility is obtained and the formula for calculation of
Landau diamagnetism is deduced.

With the use of correct expression of the electric conductivity of quantum
collisional plasmas (A. V. Latyshev and A. A. Yushkanov, {\it Transverse
electrical conductivity of a quantum collisional plasma in the Mermin
approach}. - Theor. and Math. Phys., {\bf 175}(1): 559-569 (2013)) the kinetic
description of a magnetic susceptibility is obtained and the formula for
calculation of Landau diamagnetism is deduced.

The kinetic description of magnetic susceptibility and Landau diamagnetism of
quantum collisional plasmas with any degeration of electronic gas is given. The
correct expression of electric conductivity of quantum collisional plasmas with
any degeration of electronic gas (see A. V. Latyshev and A. A. Yushkanov,
Transverse electrical conductivity of a quantum collisional plasma in the
Mermin approach. - Theor. and Math. Phys., V. 175(1):559-569 (2013)) is used.

The message passing approach of Karrer and Newman [Phys. Rev. E 82, 016101
(2010)] is an exact and practicable representation of
susceptible-infected-recovered dynamics on finite trees. Here we show that,
assuming Poisson contact processes, a pair-based moment closure representation
[Sharkey, J. Math. Biol. 57, 311 (2008)] can be derived from their equations.
We extend the applicability of both representations and discuss their relative
merits. On arbitrary time-independent networks, as was shown for the message
passing formalism, the pair-based moment closure equations also provide a
rigorous lower bound on the expected number of susceptibles at all times.

We find a further class of exact solutions to the Lighthill Whitham Richards
Payne (LWRP) traffic flow equations. As before, using two consecutive
Lagrangian transformations, a linearization is achieved. Next, depending on the
initial density, we either obtain exact formulae for the dependence of the car
density and velocity on x, t, or else, failing that, the same result in a
parametric representation. The calculation always involves two possible
factorizations of a consistency condition. Both must be considered. In physical
terms, the lineup usually separates into two offshoots at different velocities.
Each velocity soon becomes uniform. This outcome in many ways resembles not
only Rowlands, Infeld and Skorupski J. Phys. A: Math. Theor. 46 (2013) 365202
(part I) but also the two soliton solution to the Korteweg-de Vries equation.
This paper can be read independently of part I. This explains unavoidable
repetitions. Possible uses of both papers in checking numerical codes are
indicated at the end. Since LWRP, numerous more elaborate models, including
multiple lanes, traffic jams, tollgates etc. abound in the literature. However,
we present an exact solution. These are few and far between, other then found
by inverse scattering. The literature for various models, including ours, is
given. The methods used here and in part I may be useful in solving other
problems, such as shallow water flow.

We are interested in the energetic cost of a martensitic inclusion of volume
$V$ in austenite for the cubic-to-tetragonal phase transformation. In contrast
with the work of [Kn\"upfer, Kohn, Otto: Comm. Pure Appl. Math. 66 (2013), no.
6, 867--904], we consider domain with a corner and obtain a better scaling law
for the minimal energy ($E_{min} \sim \min(V^{2/3},V^{7/9})$). Our predictions
are in a good agreement with physical experiments where nucleation of
martensite is usually observed near the corners of the specimen.

In ref [math.ST/0411462] the notion of statistically dual distributions is
introduced. The reconstruction of confidence density [AIP Conference
Proceedings 803 (2005) 398] for the location parameter for several pairs of
statistically dual distributions (Poisson and Gamma, normal and normal, Cauchy
and Cauchy, Laplace and Laplace) in the case of single observation of the
random variable is a unique. It allows to introduce the Transform between the
space of observed values and the space of possible values of the parameter.

In Ann. Math., 170 (2009), 1417-1436, C. De Lellis and L. Sz\'ekelyhidi Jr.
constructed wild solutions of the incompressible Euler equations using a
reformulation of the Euler equations as a differential inclusion together with
convex integration. In this article we adapt their construction to the system
consisting of adding the transport of a passive scalar to the two-dimensional
incompressible Euler equations.

We revisit the classic thermodynamic problem of maximum work extraction from
two arbitrary sized hot and cold reservoirs, modelled as perfect gases.
Assuming ignorance about the extent to which the process has advanced, which
implies an ignorance about the final temperatures, we quantify the prior
information about the process and assign a prior distribution to the unknown
temperature(s). This requires that we also take into account the temperature
values which are regarded to be unphysical in the standard theory, as they lead
to a contradiction with the physical laws. Instead in our formulation, such
values appear to be consistent with the given prior information and hence are
included in the inference. We derive estimates of the efficiency at optimal
work from the expected values of the final temperatures, and show that these
values match with the exact expressions in the limit when any one of the
reservoirs is very large compared to the other. For other relative sizes of the
reservoirs, we suggest a weighting procedure over the estimates from two valid
inference procedures, that generalizes the procedure suggested earlier in [J.
Phys. A: Math. Theor. {\bf 46}, 365002 (2013)]. Thus a mean estimate for
efficiency is obtained which agrees with the optimal performance to a high
accuracy.

Following the lines of the recent papers [J. Phys. A: Math. Theor. 44, 495201
(2012); Eur. Phys. J. D 67, 179 (2013)], we construct here a new class of
generalized coherent states related to the Landau levels, which can be used as
the finite Fock subspaces for the representation of the $su(2)$ Lie algebra. We
establish the relationship between them and the deformed truncated coherent
states. We have, also, shown that they satisfy the resolution of the identity
property through a positive definite measures on the complex plane. Their
nonclassical and quantum statistical properties such as quadrature squeezing,
higher order `$su(2)$' squeezing, anti-bunching and anti-correlation effects
are studied in details. Particularly, the influence of the generalization on
the nonclassical properties of two modes is clarified.

Consider a finite-sized, multidimensional system in parameter state a. The
system is either at statistical equilibrium or general non-equilibrium, and may
obey either classical or quantum physics. L. Hardy's mathematical axioms
provide a basis for the physics obeyed by any such system. One axiom is that
the number N of distinguishable states a in the system obeys N=max. This
assumes that N is known as deterministic prior knowledge. However, most
observed systems suffer statistical fluctuations, for which N is therefore only
known approximately. Then what happens if the scope of the axiom N=max is
extended to include such observed systems? It is found that the state a of the
system must obey a principle of maximum Fisher information, I=I_{max}. This is
important because many physical laws have been derived, assuming as a working
hypothesis that I=I_{max}. These derivations include uses of the principle of
Extreme physical information (EPI). Examples of such derivations were of the De
Broglie wave hypothesis, quantum wave equations, Maxwell's equations, new laws
of biology (e.g. of Coulomb force-directed cell development, and of in situ
cancer growth), and new laws of economic fluctuation and investment. That the
principle I=I_{max} itself derives, from suitably extended Hardy axioms,
thereby eliminates its need to be assumed in these derivations. Thus, uses of
I=I_{max} and EPI express physics at its most fundamental level -- its
axiomatic basis in math.

The paper studies violation of conventional rules of SUSY quantum mechanics
for the centrifugal potential V(r) within the limit-circle (LC) range. A
special attention is given to transformation properties of the Titchmarsh-Weyl
m-function under Darboux deformations of the reflective Kratzer oscillator:
centrifugal Kepler-Coulomb (KC) potential plus a Taylor series in r. Since our
analysis is based on Fulton's representation of a regular-at-infinity solution
[Math. Nachr. 281, 1418 (2008)] as a superposition of two Frobenius solutions
at the origin, we refer to the appropriate expressions as the
Titchmarsh-Weyl-Fulton (TWF) functions. Explicit transformation relations are
derived for partner TWF functions associated with SUSY pairs of centrifugal
potentials. It is shown that these relations have a completely different form
for Darboux transformations (DTs) keeping the potential within the LC range.
  As an illustration, we use regular nodeless Frobenius solutions to construct
SUSY partners of the radial r- and c-Gauss-reference (GRef) potentials solvable
via hypergeometric and confluent hypergeometric functions, respectively. We
explicitly demonstrate existence of non-isospectral partners of both radial
potentials in the LC region and obtain their discrete energy spectra using the
derived closed-form expressions for the TWF functions. The general
transformation relations for the TWF function have been verified taking
advantage of form-invariance of the radial GRef potentials under double-step
DTs with the so-called 'basic' seed solutions (SSs). Similarly we directly
ratify that TWF functions for three shape-invariant reflective potentials on
the half-line -- hyperbolic Poschl-Teller (h-PT), Eckart/Manning-Rosen (E/MR),
and centrifugal KC potentials - do retain their form under basic DTs.

The conservation of the recently formulated relativistic canonical helicity
[Yoshida Z, Kawazura Y, and Yokoyama T 2014 J. Math. Phys. 55 043101] is
derived from Noether's theorem by constructing an action principle on the
relativistic Lagrangian coordinates (we obtain general cross helicities that
include the helicity of the canonical vorticity). The conservation law is,
then, explained by the relabeling symmetry pertinent to the Lagrangian label of
fluid elements. Upon Eulerianizing the Noether current, the purely spatial
volume integral on the Lagrangian coordinates is mapped to a space-time mixed
three-dimensional integral on the four-dimensional Eulerian coordinates. The
relativistic conservation law in the Eulerian coordinates is no longer
represented by any divergence-free current; hence, it is not adequate to regard
the relativistic helicity (represented by the Eulerian variables) as a Noether
charge, and this stands the reason why the "conventional helicity" is no longer
a constant of motion. We have also formulated a relativistic action principle
of magnetohydrodynamics (MHD) on the Lagrangian coordinates, and have derived
the relativistic MHD cross helicity.

The {\it unsteady} process for thermocapillary droplet migration at large
Reynolds and Marangoni numbers has been previously reported by identifying a
nonconservative integral thermal flux across the surface in the {\it steady}
thermocapillary droplet migration, [Wu and Hu, J. Math. Phys. {\bf 54} 023102,
(2013)]. Here we add a thermal source in the droplet to preserve the integral
thermal flux across the surface as conservative, so that thermocapillary
droplet migration at large Reynolds and Marangoni numbers can reach a {\it
quasi-steady} process. Under assumptions of {\it quasi-steady} state and
non-deformation of the droplet, we make an analytical result for the {\it
steady} thermocapillary migration of droplet with the thermal source at large
Reynolds and Marangoni numbers. The result shows that the thermocapillary
droplet migration speed slowly increases with the increase of Marangoni number.

A goal of PER is to understand how students use math in physics contexts. To
investigate how students use math, we need to identify transitions between
conceptual sense-making about physical systems and using mathematics to
describe and to make predictions about those systems. We reviewed video of
students solving a variety of physics problems in small groups through the lens
of epistemic frames (e-frames). In this paper, we present a new e-frame, which
we are calling "Just Math", that is similar to the Worksheet e-frame, but is
characterized by brief, low-level, math-focused utterances between students.
Future work will focus on analyzing the transitions into and out of this
e-frame so that we may develop a more coherent understanding of students' use
of math in physics.

In recent work, Li et al.\ (Comm.\ Math.\ Sci., 7:81-107, 2009) developed a
diffuse-domain method (DDM) for solving partial differential equations in
complex, dynamic geometries with Dirichlet, Neumann, and Robin boundary
conditions. The diffuse-domain method uses an implicit representation of the
geometry where the sharp boundary is replaced by a diffuse layer with thickness
$\epsilon$ that is typically proportional to the minimum grid size. The
original equations are reformulated on a larger regular domain and the boundary
conditions are incorporated via singular source terms. The resulting equations
can be solved with standard finite difference and finite element software
packages. Here, we present a matched asymptotic analysis of general
diffuse-domain methods for Neumann and Robin boundary conditions. Our analysis
shows that for certain choices of the boundary condition approximations, the
DDM is second-order accurate in $\epsilon$. However, for other choices the DDM
is only first-order accurate. This helps to explain why the choice of
boundary-condition approximation is important for rapid global convergence and
high accuracy. Our analysis also suggests correction terms that may be added to
yield more accurate diffuse-domain methods. Simple modifications of first-order
boundary condition approximations are proposed to achieve asymptotically
second-order accurate schemes. Our analytic results are confirmed numerically
in the $L^2$ and $L^\infty$ norms for selected test problems.

The quasi-streamfunction (Psi) formalism proposed by Kim et. al. (J.W. Kim,
K.J. Bai, R.C. Ertekin, W.C. Webster, J. Eng. Math. 40, 17 (2001)) provides a
natural framework for systematically studying zero-vorticity waves over
arbitrary bathymetry. The modified Psi-formalism developed here discards the
original constraints of zero-vorticity by allowing for vertical vorticity which
is the case of most interest for coastal dynamics. The problem is reformulated
in terms of two dynamical equations on the boundary supplemented by one
equation that represents a kinematic constraint in the interior of the domain.
In this framework, the kinematic constraint can be solved to express Psi in
terms of canonically-conjugated variables. The formalism is demonstrated for
horizontally homogeneous flows over mild topography, where asymptotic
formulations for the Hamiltonian and Lagrangian functions are derived based on
the Helmholz-Hodge decomposition. For potential flows, the asymptotic form of
the Hamiltonian is identical to previous results. The Lagrangian function is
also expressed as an expansion in terms of the surface height and its time
derivative and compared with Zakharov's formalism where agreement is found for
one-dimensional wave scattering.

In the framework of the focusing Nonlinear Schrodinger (NLS) equation we
study numerically the nonlinear stage of the modulation instability (MI) of the
condensate. As expected, the development of the MI leads to formation of
"integrable turbulence" [V.E. Zakharov, Turbulence in integrable systems, Stud.
in Appl. Math. 122, no. 3, 219-234, (2009)]. We study the time evolution of
it's major characteristics averaged across realizations of initial data - the
condensate solution seeded by small random noise with fixed statistical
properties. The measured quantities are: (1) wave-action spectrum and spatial
correlation function, (2) the probability density function (PDF) of wave
amplitudes and their momenta, and (3) kinetic and potential energies.

In classical kinetic or kinetic-like models a particle free path distribution
is exponensial, but this is more likely to be an exception than a rule. In this
paper we derive a linear Boltzmann-like equation for a general free path
distribution in the framework of Alt's model J. Math. Biol. 9:147 (1980). In
the special case that the free path distribution has at least first and second
finite moments we construct an asymptotic solution of the equation for small
mean free paths. The asymptotic solution becomes a diffusion approximation to
the one-speed Boltzmann-like equation.

For all the joint von Neumann measurements on a D-dimensional quantum system,
we present the specific example of a context-invariant quasi hidden variable
(qHV) model, proved in [Loubenets, J. Math. Phys. 56, 032201 (2015)] to exist
for each Hilbert space. In this model, a quantum observable X is represented by
a variety of random variables satisfying the functional condition required in
quantum foundations but, in contrast to a contextual model, each of these
random variables equivalently models X under all joint von Neumann
measurements, regardless of their contexts. This, in particular, implies the
specific local qHV (LqHV) model for an N-qudit state and allows us to derive
the new exact upper bound on the maximal violation of 2x...x2-setting Bell-type
inequalities of any type (either on correlation functions or on joint
probabilities) under N-partite joint von Neumann measurements on an N-qudit
state. For d=2, this new upper bound coincides with the maximal violation by an
N-qubit state of the Mermin-Klyshko inequality. Based on our results, we
discuss the conceptual and mathematical advantages of context-invariant and
local qHV modelling.

We consider a nonlinear kinetic equation of Boltzmann type which takes into
account the influence of conviction during the formation of opinion in a system
of agents which interact through the binary exchanges introduced in [G.
Toscani, Commun. Math. Sci. 4, 481 (2006)]. The original exchange mechanism,
which is based on the human tendency to compromise and change of opinion
through self-thinking, is here modified in the parameters of the compromise and
diffusion terms, which now are assumed to depend on the personal degree of
conviction. The numerical simulations show that the presence of conviction has
the potential to break symmetry, and to produce clusters of opinions. The model
is partially inspired by the recent work [L. Pareschi, G. Toscani, Phil. Trans.
R. Soc. A 372, 20130396 (2014)], in which the role of knowledge in the
formation of wealth distribution has been investigated.

In this paper, we consider the Cauchy problem to the TROPIC CLIMATE MODEL
derived by Frierson-Majda-Pauluis in [Comm. Math. Sci, Vol. 2 (2004)] which is
a coupled system of the barotropic and the first baroclinic modes of the
velocity and the typical midtropospheric temperature. The system considered in
this paper has viscosities in the momentum equations, but no diffusivity in the
temperature equation. We establish here the global well-posedness of strong
solutions to this model. In proving the global existence of strong solutions,
to overcome the difficulty caused by the absence of the diffusivity in the
temperature equation, we introduce a new velocity $w$ (called the pseudo
baroclinic velocity), which has more regularities than the original baroclinic
mode of the velocity. An auxiliary function $\phi$, which looks like the
effective viscous flux for the compressible Navier-Stokes equations, is also
introduced to obtain the $L^\infty$ bound of the temperature. Regarding the
uniqueness, we use the idea of performing suitable energy estimates at level
one order lower than the natural basic energy estimates for the system.

We consider the inverse refractor and the inverse reflector problem. The task
is to design a free-form lens or a free-form mirror that, when illuminated by a
point light source, produces a given illumination pattern on a target. Both
problems can be modeled by strongly nonlinear second-order partial differential
equations of Monge-Amp\`ere type. In [Math. Models Methods Appl. Sci. 25
(2015), pp. 803--837, DOI: 10.1142/S0218202515500190] the authors have proposed
a B-spline collocation method which has been applied to the inverse reflector
problem. Now this approach is extended to the inverse refractor problem. We
explain in depth the collocation method and how to handle boundary conditions
and constraints. The paper concludes with numerical results of refracting and
reflecting optical surfaces and their verification via ray tracing.

We reexamine Liouville equation based turbulence theories proposed by Qian
{[}Phys. Fluids \textbf{26}, 2098 (1983){]} and Edwards and McComb {[}J. Phys.
A: Math. Gen. \textbf{2}, 157 (1969){]}, which are compatible with Kolmogorov
spectrum. These theories obtained identical equation for spectral density
$q(k)$ and different results for damping coefficient. Qian proposed variational
approach and Edwards and McComb proposed maximal entropy principle to obtain
equation for the damping coefficient. We show that assumptions used in these
theories to obtain damping coefficient correspond to unphysical conditions.

Fourier transform methods are used to analyze functions and data sets to
provide frequencies, amplitudes, and phases of underlying oscillatory
components. Fast Fourier transform (FFT) methods offer speed advantages over
evaluation of explicit integrals (EI) that define Fourier transforms. This
paper compares frequency, amplitude, and phase accuracy of the two methods for
well resolved peaks over a wide array of data sets including cosine series with
and without random noise and a variety of physical data sets, including
atmospheric $\mathrm{CO_2}$ concentrations, tides, temperatures, sound
waveforms, and atomic spectra. The FFT uses MIT's FFTW3 library. The EI method
uses the rectangle method to compute the areas under the curve via complex
math. Results support the hypothesis that EI methods are more accurate than FFT
methods. Errors range from 5 to 10 times higher when determining peak frequency
by FFT, 1.4 to 60 times higher for peak amplitude, and 6 to 10 times higher for
phase under a peak. The ability to compute more accurate Fourier transforms has
promise for improved data analysis in many fields, including more sensitive
assessment of hypotheses in the environmental sciences related to
$\mathrm{CO_2}$ concentrations and temperature. Other methods are available to
address different weaknesses in FFTs; however, the EI method always produces
the most accurate output possible for a given data set. On the 2011 Lenovo
ThinkPad used in this study, an EI transform on a 10,000 point data set took 31
seconds to complete. Source code (C) and Windows executable for the EI method
are available at
https://sourceforge.net/projects/amoreaccuratefouriertransform/.

We study the long-time asymptotic of the solutions to Maxwell's equation in
the case of a upper-hybrid resonance in the cold plasma model. We base our
analysis in the transfer to the time domain of the recent results of B.
Despr\'es, L.M. Imbert-G\'erard and R. Weder, J. Math. Pures Appl. {\bf 101} (
2014) 623-659, where the singular solutions to Maxwell's equations in the
frequency domain were constructed by means of a limiting absorption principle
and a formula for the heating of the plasma in the limit of vanishing collision
frequency was obtained. Currently there is considerable interest in these
problems, in particular, because upper-hybrid resonances are a possible
scenario for the heating of plasmas, and since they can be a model for the
diagnostics involving wave scattering in plasmas.

In this paper, we consider a nonlinear interaction system between the
barotropic mode and the first baroclinic mode of the tropical atmosphere with
moisture; that was derived in [Frierson, D.M.W.; Majda, A.J.; Pauluis, O.M.:
Dynamics of precipitation fronts in the tropical atmosphere: a novel relaxation
limit, Commum. Math. Sci., 2 (2004), 591-626.] We establish the global
existence and uniqueness of strong solutions to this system, with initial data
in $H^1$, for each fixed convective adjustment relaxation time parameter
$\varepsilon>0$. Moreover, if the initial data enjoy slightly more regularity
than $H^1$, then the unique strong solution depends continuously on the initial
data. Furthermore, by establishing several appropriate
$\varepsilon$-independent estimates, we prove that the system converges to a
limiting system, as the relaxation time parameter $\varepsilon$ tends to zero,
with convergence rate of the order $O(\sqrt\varepsilon)$. Moreover, the
limiting system has a unique global strong solution, for any initial data in
$H^1$, and such unique strong solution depends continuously on the initial data
if the the initial data posses slightly more regularity than $H^1$. Notably,
this solves the VISCOUS VERSION of an open problem proposed in the above
mentioned paper of Frierson, Majda and Pauluis.

In our previous work [J. Math. Phys. 49, 033513 (2008)] two problems remain
to be resolved. One is that we lack a minimal group to replace GL(4,C), the
other is that the Equation of Motion (EoM) for fermion has no mass term. After
careful investigation we find these two problems are linked by conformal group,
a subgroup of GL(4,C) group. The Weyl group, a subgroup of conformal group, can
bring about the running of mass, charge etc. while making it responsible for
the transformation of interaction vertex. However, once concerning the
generation of the mass term in EoM, we have to resort to the whole conformal
group, in which the generators $K_\mu $ play a crucial role in making vacuum
vary from space-like (or light-cone-like)to time-like. Physically the starting
points are our previous conclusion, $\vec E^2-\vec B^2\neq 0$ for massive
bosons, and the two-photon process yielding $e^+ e^-$ pair. Finally we get to
the conclusion that the mass term of strong interaction is linearly relevant to
(chromo-)magnetic flux as well as angular momentum.

The helical absolute equilibrium of a compressible adiabatic flow presents
not only the polarization between the two purely helical modes of opposite
chiralities but also that between the vortical and acoustic modes, deviating
from the equipartition predicted by {\sc Kraichnan, R. H.} [1955 The Journal of
the Acoustical Society of America {\bf 27}, 438--441.]. Due to the existence of
the acoustic mode, even if all Fourier modes of one chiral sector in the
sharpened Helmholtz decomposition [{\sc Moses, H. E.} 1971 SIAM ~(Soc. Ind.
Appl. Math.) J. Appl. Math. {\bf 21}, 114--130] are thoroughly truncated,
leaving the system with positive definite helicity and energy, negative
temperature and the corresponding large-scale concentration of vortical modes
are not allowed, unlike the incompressible case.

We explain why the theory of Escauriaza, Seregin, and Sverak (Russian Math.
Surveys, 2003) on potential finite time singularity in Navier-Stokes solutions
must be largely misapprehended. It is found that the proofs of the backward
uniqueness theorem for parabolic equations contain technical errors. The stated
validity of a theorem for vorticity is established on ill-informed analyses as
the solenoidal constraint is not taken into account. There are many cases where
parabolic scalings are erroneously applied. We briefly discuss a number of
related issues.

Statistical agent-based models for crime have shown that repeat victimization
can lead to predictable crime hotspots (see e.g. Short et al., Math. Models
Methods Appl., 2008), then a recent study in one space dimension (Chaturapruek
et al., SIAM J. Appl. Math, 2013) shows that the hotspot dynamics changes when
movement patterns of the criminals involve long-tailed L\'evy distributions for
the jump length as opposed to classical random walks. In reality, criminals
move in confined areas with a maximum jump length. In this paper we develop a
mean-field continuum model with truncated L\'evy flights for residential
burglary in one space dimension. The continuum model yields local Laplace
diffusion, rather than fractional diffusion. We present an asymptotic theory to
derive the continuum equations and show excellent agreement between the
continuum model and the agent-based simulations. This suggests that local
diffusion models are universal for continuum limits of this problem, the
important quantity being the diffusion coefficient. Law enforcement agents are
also incorporated into the model, and the relative effectiveness of their
deployment strategies are compared quantitatively.

We introduce two new singularity detection criteria based on the work of
Duchon-Robert (DR) [J. Duchon and R. Robert, Nonlinearity, 13, 249 (2000)], and
Eyink [G.L. Eyink, Phys. Rev. E, 74 (2006)] which allow for the local detection
of singularities with scaling exponent $h\leqslant1/2$ in experimental flows,
using PIV measurements. We show that in order to detect such singularities, one
does not need to have access to the whole velocity field inside a volume but
can instead look for them from stereoscopic particle image velocimetry (SPIV)
data on a plane. We discuss the link with the Beale-Kato-Majda (BKM) [J.T.
Beale, T. Kato, A. Majda, Commun. Math. Phys., 94, 61 (1984)] criterion, based
on the blowup of vorticity, which applies to singularities of Navier-Stokes
equations. We illustrate our discussion using tomographic PIV data obtained
inside a high Reynolds number flow generated inside the boundary layer of a
wind tunnel. In such a case, BKM and DR criteria are well correlated with each
other.

A primary goal of physics is to create mathematical models that allow both
predictions and explanations of physical phenomena. We weave maths extensively
into our physics instruction beginning in high school, and the level and
complexity of the maths we draw on grows as our students progress through a
physics curriculum. Despite much research on the learning of both physics and
math, the problem of how to successfully teach most of our students to use
maths in physics effectively remains unsolved. A fundamental issue is that in
physics, we don't just use maths, we think about the physical world with it. As
a result, we make meaning with math-ematical symbology in a different way than
mathematicians do. In this talk we analyze how developing the competency of
mathematical modeling is more than just "learning to do math" but requires
learning to blend physical meaning into mathematical representations and use
that physical meaning in solving problems. Examples are drawn from across the
curriculum.

A global solution of the Schr\"odinger equation, obtained recently within the
wave operator formalism for explicitly time-dependent Hamiltonians [J. Phys. A:
Math. Theor. 48, 225205 (2015)], is generalized to take into account the case
of multidimensional active spaces. An iterative algorithm is derived to obtain
the Fourier series of the evolution operator issuing from a given
multidimensional active subspace and then the effective Hamiltonian
corresponding to the model space is computed and analysed as a measure of the
cyclic character of the dynamics. Studies of the laser controlled dynamics of
diatomic models clearly show that a multidimensional active space is required
if the wavefunction escapes too far from the initial subspace. A suitable
choice of the multidimensional active space, including the initial and target
states, increases the cyclic character and avoids divergences occuring when
one-dimensional active spaces are used. The method is also proven to be
efficient in describing dissipative processes such as photodissociation.

We consider the effective hydrophobicity of a periodically grooved surface
immersed in liquid, with trapped shear-free bubbles protruding between the
no-slip ridges at a $\pi/2$ contact angle. Specifically, we carry out a
singular-perturbation analysis in the limit $\epsilon\ll1$ where the bubbles
are closely spaced, finding the effective slip length (normalised by the bubble
radius) for longitudinal flow along the the ridges as
${\pi}/{\sqrt{2\epsilon}}-(12/\pi)\ln 2 + (13\pi/24)\sqrt{2\epsilon}+
o(\sqrt{\epsilon})$, the small parameter $\epsilon$ being the planform solid
fraction. The square-root divergence highlights the strong hydrophobic
character of this configuration; this leading singular term (along with the
third term) follows from a local lubrication-like analysis of the gap regions
between the bubbles, together with general matching considerations and a global
conservation relation. The $O(1)$ constant term is found by matching with a
leading-order solution in the "outer'" region, where the bubbles appear to be
touching. We find excellent agreement between our slip-length formula and a
numerical scheme recently derived using a "unified-transform" method (D.
Crowdy, IMA J. Appl. Math., 80 1902, 2015). The comparison demonstrates that
our asymptotic formula, together with the diametric "dilute-limit"
approximation (D. Crowdy, J. Fluid Mech., 791 R7, 2016), provides an elementary
analytical description for essentially arbitrary no-slip fractions.

In this paper, we consider the initial-boundary value problem of the
three-dimensional primitive equations for oceanic and atmospheric dynamics with
only horizontal viscosity and horizontal diffusivity. We establish the local,
in time, well-posedness of strong solutions, for any initial data $(v_0,
T_0)\in H^1$, by using the local, in space, type energy estimate. We also
establish the global well-posedness of strong solutions for this system, with
any initial data $(v_0, T_0)\in H^1\cap L^\infty$, such that $\partial_zv_0\in
L^m$, for some $m\in(2,\infty)$, by using the logarithmic type anisotropic
Sobolev inequality and a logarithmic type Gronwall inequality. This paper
improves the previous results obtained in [Cao, C.; Li, J.; Titi, E.S.: Global
well-posedness of the 3D primitive equations with only horizontal viscosity and
diffusivity, Comm. Pure Appl.Math., Vol. 69 (2016), 1492-1531.], where the
initial data $(v_0, T_0)$ was assumed to have $H^2$ regularity.

We consider the 3D Cahn-Hilliard equations coupled to, and driven by, the
forced, incompressible 3D Navier-Stokes equations. The combination, known as
the Cahn-Hilliard-Navier-Stokes (CHNS) equations, is used in statistical
mechanics to model the motion of a binary fluid. The potential development of
singularities (blow-up) in the contours of the order parameter $\phi$ is an
open problem. To address this we have proved a theorem that closely mimics the
Beale-Kato-Majda theorem for the $3D$ incompressible Euler equations [Beale et
al. Commun. Math. Phys., Commun. Math. Phys., ${\rm 94}$, $ 61-66 ({\rm
1984})$]. By taking an $L^{\infty}$ norm of the energy of the full binary
system, designated as $E_{\infty}$, we have shown that
$\int_{0}^{t}E_{\infty}(\tau)\,d\tau$ governs the regularity of solutions of
the full 3D system. Our direct numerical simulations (DNSs), of the 3D CHNS
equations, for (a) a gravity-driven Rayleigh Taylor instability and (b) a
constant-energy-injection forcing, with $128^3$ to $512^3$ collocation points
and over the duration of our DNSs, confirm that $E_{\infty}$ remains bounded as
far as our computations allow.

In this work, Stroh's formalism is endowed with causal properties on the
basis of an analysis of the radiation condition in the Green tensor of the
elastodynamic wave equation. The modified formalism is applied to dislocations
moving uniformly in an anisotropic medium. In practice, accounting for
causality amounts to a simple analytic continuation procedure whereby to the
dislocation velocity is added an infinitesimal positive imaginary part. This
device allows for a straightforward computation of velocity-dependent field
expressions that are valid whatever the dislocation velocity ---including
supersonic regimes--- without needing to consider subsonic and supersonic cases
separately. As an illustration, the distortion field of a Somigliana
dislocation of the Peierls-Nabarro-Eshelby-type with finite-width core is
computed analytically, starting from the Green tensor of elastodynamics. To
obtain the result in the form of a single compact expression, use of the
modified Stroh formalism requires splitting the Green function into its
reactive and radiative parts. In supersonic regimes, the solution obtained
displays Mach cones, which are supported by Dirac measures in the Volterra
limit. From these results, an explanation of Payton's `backward' Mach cones
[R.G. Payton, Z. Angew. Math. Phys. 46, 282--288 (1995)] is given in terms of
slowness surfaces, and a simple criterion for their existence is derived. The
findings are illustrated by full-field calculations from analytical formulas
for a dislocation of finite width in iron, and by Huygens-type geometric
constructions of Mach cones from ray surfaces.

A pair of random walkers, the motion of each of which in two dimensions is
confined spatially by the action of a quadratic potential centered at different
locations for the two walks, are analyzed in the context of reaction-diffusion.
The application sought is to the process of transmission of infection in
epidemics. The walkers are animals such as rodents in considerations of the
Hantavirus epidemic, infected or susceptible, the reaction is the transmission
of infection, and the confining potential represents the tendency of the
animals to stay in the neighborhood of their home range centers. Calculations
are based on a recently developed formalism (Kenkre and Sugaya, Bull. Math.
Bio. 76, 3016 (2014)) structured around analytic solutions of a Smoluchowski
equation and one of its aims is the resolution of peculiar but well-known
problems of reaction-diffusion theory in 2-dimensions. In the present analysis,
reaction occurs not at points but in spatial regions of dimensions larger than
0. The analysis uncovers interesting nonintuitive phenomena one of which is
similar to that encountered in the 1-dimensional analysis given in the quoted
article, and another specific to the fact that the reaction region is spatially
extended. The analysis additionally provides a realistic description of
observations on animals transmitting infection while moving on what is
effectively a 2-dimensional landscape. Along with the general formalism and
explicit 1-dimensional analysis given in Bull. Math. Bio. 76, 3016 (2014), the
present work forms a model calculational tool for the analysis for the
transmission of infection in dilute systems.

Quantum violation of Bell inequalities is now used in many quantum
information applications and it is important to analyze it both quantitatively
and conceptually. In the present paper, we analyze violation of multipartite
Bell inequalities via the local probability model - the LqHV (local quasi
hidden variable) model [Loubenets, J. Math. Phys. 53, 022201 (2012)],
incorporating the LHV model only as a particular case and correctly reproducing
the probabilistic description of every quantum correlation scenario, more
generally, every nonsignaling scenario. The LqHV probability framework allows
us to construct nonsignaling analogs of Bell inequalities and to specify
parameters quantifying violation of Bell inequalities - Bell's nonlocality - in
a general nonsignaling case. For quantum correlation scenarios on an N-qudit
state, we evaluate these nonlocality parameters analytically in terms of
dilation characteristics of an N-qudit state and also, numerically - in d and
N. In view of our rigorous mathematical description of Bell's nonlocality in a
general nonsignaling case via the local probability model, we argue that
violation of Bell inequalities in a quantum case is not due to violation of the
Einstein-Podolsky-Rosen (EPR) locality conjectured by Bell but due to the
improper HV modelling of "quantum realism".

Hamiltonian and action principle (HAP) formulations of plasma physics are
reviewed for the purpose of explaining structure preserving numerical
algorithms. Geometric structures associated with and emergent from HAP
formulations are discussed. These include conservative integration, which
exactly conserves invariants, symplectic integration, which exactly preserves
the Hamiltonian geometric structure, and other Hamiltonian integration
techniques. Basic ideas of variational integration and Poisson integration,
which can preserve noncanonical Hamiltonian structure, are discussed.
Metriplectic integration, which preserves the structure of conservative systems
with both Hamiltonian and dissipative parts, is proposed. Two kinds of
simulated annealing, a relaxation technique for obtaining equilibrium states,
are reviewed: one that uses metriplectic dynamics, which maximizes an entropy
at fixed energy, the other that uses double bracket dynamics, which preserves
Casimir invariants. Throughout, applications to plasma systems are emphasized.
The paper culminates with a discussion of GEMPIC [Kraus et al.,
arXiv:1609.03053v1 [math.NA] (2016)], a particle in cell code that incorporates
Hamiltonian and geometrical structure preserving properties.

Cauchy invariants are now viewed as a powerful tool for investigating the
Lagrangian structure of three-dimensional (3D) ideal flow (Frisch &
Zheligovsky, Commun. Math. Phys., vol. 326, 2014, pp. 499-505, Podvigina et
al., J. Comput. Phys., vol. 306, 2016, pp. 320-342). Looking at such invariants
with the modern tools of differential geometry and of geodesic flow on the
space SDiff of volume-preserving transformations (Arnold, Ann. Inst. Fourier,
vol. 16, 1966, pp. 319-361), all manners of generalisations are here derived.
The Cauchy invariants equation and the Cauchy formula, relating the vorticity
and the Jacobian of the Lagrangian map, are shown to be two expressions of this
Lie-advection invariance, which are duals of each other (specifically, Hodge
dual). Actually, this is shown to be an instance of a general result, which
holds for flow both in flat (Euclidean) space and in a curved Riemannian space:
any Lie-advection invariant p-form which is exact (i.e. is a differential of a
(p-1)-form) has an associated Cauchy invariants equation and a Cauchy formula.
This constitutes a new fundamental result in linear transport theory, providing
a Lagrangian formulation of Lie advection for some classes of differential
forms. The result has a broad applicability: examples include the
magnetohydrodynamics (MHD) equations and various extensions thereof, discussed
by Lingam et al. (Phys. Lett. A, vol. 380, 2016, pp. 2400-2406), and include
also the equations of Tao (2016, arXiv:1606.08481 [math.AP]), Euler equations
with modified Biot-Savart law, displaying finite-time blow-up. Our main result
is also used for new derivations, and several new results, concerning local
helicity-type invariants for fluids and MHD flow in flat or curved spaces of
arbitrary dimension.

Topology changes in multi-phase fluid flows are difficult to model within a
traditional sharp interface theory. Diffuse interface models turn out to be an
attractive alternative to model two-phase flows. Based on a
Cahn-Hilliard-Navier-Stokes model introduced by Abels, Garcke and Gr\"{u}n
(Math. Models Methods Appl. Sci. 2012), which uses a volume averaged velocity,
we derive a diffuse interface model in a Hele-Shaw geometry, which in the case
of non-matched densities, simplifies an earlier model of Lee, Lowengrub and
Goodman (Phys. Fluids 2002). We recover the classical Hele-Shaw model as a
sharp interface limit of the diffuse interface model. Furthermore, we show the
existence of weak solutions and present several numerical computations
including situations with rising bubbles and fingering instabilities.

We present experimental evidence of the universal emergence of the Peregrine
soliton predicted in the semi-classical (zero-dispersion) limit of the focusing
nonlinear Schr\"{o}dinger equation [Comm. Pure Appl. Math. {\bf 66}, 678
(2012)]. Experiments studying higher-order soliton propagation in optical fiber
use an optical sampling oscilloscope and frequency-resolved optical gating to
characterise intensity and phase around the first point of soliton compression
and the results show that the properties of the compressed pulse and background
pedestal can be interpreted in terms of the Peregrine soliton. Experimental and
numerical results reveal that the universal mechanism under study is highly
robust and can be observed over a broad range of parameters, and experiments
are in very good agreement with numerical simulations.

The strong-interaction limit of the Hohenberg-Kohn functional defines a
multimarginal optimal transport problem with Coulomb cost. From physical
arguments, the solution of this limit is expected to yield strictly-correlated
particle positions, related to each other by co-motion functions (or optimal
maps), but the existence of such a deterministic solution in the general
three-dimensional case is still an open question. A conjecture for the
co-motion functions for radially symmetric densities was presented in
Phys.~Rev.~A {\bf 75}, 042511 (2007), and later used to build approximate
exchange-correlation functionals for electrons confined in low-density quantum
dots. Colombo and Stra [Math.~Models Methods Appl.~Sci., {\bf 26} 1025 (2016)]
have recently shown that these conjectured maps are not always optimal. Here we
revisit the whole issue both from the formal and numerical point of view,
finding that even if the conjectured maps are not always optimal, they still
yield an interaction energy (cost) that is numerically very close to the true
minimum. We also prove that the functional built from the conjectured maps has
the expected functional derivative also when they are not optimal.

We formulate a new family of high order on-surface radiation conditions to
approximate the outgoing solution to the Helmholtz equation in exterior
domains. Motivated by the pseudo-differential expansion of the
Dirichlet-to-Neumann operator developed by Antoine et al. (J. Math. Anal. Appl.
229:184-211, 1999), we design a systematic procedure to apply
pseudo-differential symbols of arbitrarily high order. Numerical results are
presented to illustrate the performance of the proposed method for solving both
the Dirichlet and the Neumann boundary value problems. Possible improvements
and extensions are also discussed.

This paper presents a new methodology for the solution of problems of two-
and three-dimensional acoustic scattering (and, in particular, two-dimensional
electromagnetic scattering) by obstacles and defects in presence an arbitrary
number of penetrable layers. Relying on use of certain slow-rise windowing
functions, the proposed Windowed Green Function approach (WGF) efficiently
evaluates oscillatory integrals over unbounded domains, with high accuracy,
without recourse to the highly expensive Sommerfeld integrals that have
typically been used to account for the effect of underlying planar multi-layer
structures. The proposed methodology, whose theoretical basis was presented in
the recent contribution (SIAM J. Appl. Math. 76(5), p. 1871, 2016), is fast,
accurate, flexible, and easy to implement. Our numerical experiments
demonstrate that the numerical errors resulting from the proposed approach
decrease faster than any negative power of the window size. In a number of
examples considered in this paper the proposed method is up to thousands of
times faster, for a given accuracy, than corresponding methods based on use of
Sommerfeld integrals.

Upper-division physics students spend much of their time solving problems. In
addition to their basic skills and background, their epistemic framing can form
an important part of their ability to learn physics from these problems.
Encouraging students to move toward productive framing may help them solve
problems. Thus, an instructor should understand the specifics of how student
have framed a problem and understand how her interaction with the students will
impact that framing. In this study we investigate epistemic framing of students
in problem solving situations where math is applied to physics. To analyze the
frames and changes in frames, we develop and use a two-axis framework involving
conceptual and algorithmic physics and math. We examine student and instructor
framing and the interactions of these frames over a range of problems in an
upper-division electromagnetic fields course. Within interactions, students and
instructors generally follow each others' leads in framing.

Evolutionary dynamics experienced by mixed microbial populations of
cooperators and cheaters has been examined in experiments in the literature
using a protocol of periodic dilution to investigate the properties of
resilience and adaptability to environmental changes. Data depicted on an
appropriate phase diagram indicate, among other features, a stable equilibrium
point at which cooperators and cheaters coexist [A. Sanchez, J. Gore, PLOs
Biology, 11 (4), e1001547 (2013)]. We present here a phenomenological analysis
of these data focusing on an eco-evolutionary-game perspective. To that end, we
work on an extension of the model proposed by Tao and Cressman Y. Tao, R.
Cressman, Bull. Math. Biol. 69, 1377 - 1399 (2007). It's original version takes
into account changes of the total population density while the individuals
experience pairwise Prisoner's Dilemma game. The extension devised here
contains a dilution factor to be conform with the experimental procedure, in
addition of a term accounting for Allee effects. Differently from other
descriptions proposed in similar contexts, however, the model here does not
account for assortative encounters, group or kin selection. Nonetheless, it
describes surprisingly well both qualitatively and quantitatively the features
of the observed phase diagram. We discuss these results in terms of the
behavior of an effective payoff matrix defined accordingly.

A material-based, i.e., Lagrangian, methodology for exact integration of flux
by volume-preserving flows through a surface has been developed recently in
[Karrasch, SIAM J. Appl. Math., 76 (2016), pp. 1178-1190]. In the present
paper, we first generalize this framework to general compressible flows,
thereby solving the donating region problem in full generality. Second, we
demonstrate the efficacy of this approach on a slightly idealized version of a
classic two-dimensional mixing problem: transport in a cross-channel
micromixer, as considered recently in [Balasuriya, SIAM J. Appl. Dyn. Syst., 16
(2017), pp. 1015-1044].

The Dimensional Regularization of Bollini and Giambiags (Phys. Lett. {\bf B
40}, 566 (1972), Il Nuovo Cim. {\bf B 12}, 20 (1972). Phys. Rev. {\bf D 53},
5761 (1996)) can not be defined for all Schwartz Tempered Distributions
Explicitly Lorentz Invariant (STDELI) ${\cal S}^{'}_L$. In this paper we
overcome here such limitation and show that it can be generalized to all
aforementioned STDELI and obtain a product in a ring with zero divisors.
  For this purpose, we resort to a formula obtained in [Int. J. of Theor. Phys.
{\bf 43}, 1019 (2004)] and demonstrate the existence of the convolution (in
Minkowskian space) of such distributions. This is done by following a procedure
similar to that used so as to define a general convolution between the
Ultradistributions of J. Sebastiao e Silva [Math. Ann. {\bf 136}, 38 (1958)],
also known as Ultrahyperfunctions, obtained by Bollini et al. [Int. J. of
Theor. Phys. {\bf 38}, 2315 (1999), {\bf 43}, 1019 (2004), {\bf 43}, 59
(2004),{\bf 46}, 3030 (2007)]. Using the Inverse Fourier Transform we get the
ring with zero divisors ${\cal S}^{'}_{LA}$, defined as ${\cal
S}^{'}_{LA}={\cal F}^{-1}\{{\cal S}^{'}_L\}$, where ${\cal F}^{-1}$ denotes the
Inverse Fourier Transform. In this manner we effect a dimensional
regularization in momentum space (the ring ${\cal S}^{'}_{L}$) via convolution,
and a product of distributions in the corresponding configuration space (the
ring ${\cal S}^{'}_{LA})$. This generalizes the results obtained by Bollini and
Giambiagi for Euclidean space in [Phys. Rev. {\bf D 53}, 5761 (1996)].
  We provide several examples of the application of our new results in Quantum
Field Theory. In particular, the convolution of $n$ massless Feynman
propagators and the convolution of n massless Wheeler propagators in
Minkowskian space.

The recent study by Waclawczyk et al. [J. Phys. A: Math. Theor. 50, 175501
(2017)] possesses three shortcomings: (i) The analysis misses a key aspect of
the LMN equations which makes their Lie-group symmetry results incomplete. In
particular, two essential symmetries will break when including this aspect.
(ii) The statements on the constraints regarding the infinite-dimensional
symmetry groups are misleading. (iii) The particular symmetries originating
solely from the linearity of the LMN hierarchy violate the classical principle
of cause and effect and therefore are unphysical. Within this Comment we
present a detailed proof to this claim and conclude with the note that the new
study by Waclawczyk et al. gives an unrealistic outlook on deriving invariant
symmetry solutions for velocity correlations that arise from intermittent
processes.

We consider a delay differential equation (DDE) model for mode-locked
operation in class-A semiconductor lasers containing both gain and absorber
sections. The material processes are adiabatically eliminated as these are
considered fast in comparison to the delay time for a long cavity device. We
determine the steady states and analyze their bifurcations using DDE-BIFTOOL
[K. Engelborghs, T. Luzyanina, and D. Roose, ACM Trans. Math. Softw. 28, 1
(2002)]. Multiple forms of coexistence, transformation and hysteretic behavior
of stable steady states and fundamental periodic regimes are discussed in
bifurcation diagrams.

In this paper we study the dimension reduction limits of the compressible
Navier--Stokes equations over product Riemannian manifolds
$\mathcal{O}_\epsilon \cong \mathcal{M} \times \epsilon\mathcal{F}$, such that
$\dim\,(\mathcal{M})=n$ and $\dim\,(\mathcal{F})=d$ are arbitrary. Using the
method of relative entropies, we establish the convergence of the suitable weak
solutions of the Navier--Stokes equations on $\mathcal{O}_\epsilon$ to the
classical solution of the limiting equations on $\mathcal{M}$ as $\epsilon
\rightarrow 0^+$, provided the latter exists. In addition, we also deduce the
vanishing viscosity limit. The limiting equations identified through our
analysis contain the weight function $A:\mathcal{M} \rightarrow \mathbb{R}^+$
as a parameter, where $A(x)$ = area of fibre $\mathcal{F}_x$. Our work is based
on and generalises the results in P. Bella, E. Feireisl, M. Lewicka and A.
Novotn\'{y}, A rigorous justification of the Euler and Navier--Stokes equations
with geometric effects, \textit{SIAM J. Math. Anal.}, \textbf{48} (2016),
3907--3930, and it contains as special cases the physical models of circular
nozzles, thin plate limits and finite-length longitudinal nozzles.

Lane changing is one of the most common maneuvers on motorways. Although,
macroscopic traffic models are well known for their suitability to describe
fast moving crowded traffic, most of these models are generally developed in
one dimensional framework, henceforth lane changing behavior is somehow
neglected. In this paper, we propose a macroscopic model, which accounts for
lane-changing behavior on motorway, based on a two-dimensional extension of the
Aw and Rascle [Aw and Rascle, SIAM J.Appl.Math., 2000] and Zhang [Zhang,
Transport.Res.B-Meth., 2002] macroscopic model for traffic flow. Under
conditions, when lane changing maneuvers are no longer possible, the model
"relaxes" to the one-dimensional Aw-Rascle-Zhang model. Following the same
approach as in [Aw, Klar, Materne and Rascle, SIAM J.Appl.Math., 2002], we
derive the two-dimensional macroscopic model through scaling of time
discretization of a microscopic follow-the-leader model with driving direction.
We provide a detailed analysis of the space-time discretization of the proposed
macroscopic as well as an approximation of the solution to the associated
Riemann problem. Furthermore, we illustrate some features of the proposed model
through some numerical experiments.

A classical problem in fluid mechanics is the motion of an axisymmetric
vortex sheet evolving under the action of surface tension, surrounded by an
inviscid fluid. Lagrangian descriptions of these dynamics are well-known,
involving complex nonlocal expressions for the radial and longitudinal
velocities in terms of elliptic integrals. Here we use these prior results to
arrive at a remarkably compact and exact Eulerian evolution equation for the
sheet radius $r(z,t)$ in an explicit flux form associated with the conservation
of enclosed volume. The flux appears as an integral involving the pairwise
mutual induction formula for vortex loop pairs first derived by Helmholtz and
Maxwell. We show how the well-known linear stability results for cylindrical
vortex sheets in the presence of surface tension and streaming flows [A.M.
Sterling and C.A. Sleicher, $J.~Fluid~Mech.$ ${\bf 68}$, 477 (1975)] can be
obtained directly from this formulation. Furthermore, the inviscid limit of the
empirical model of Eggers and Dupont [$J.~Fluid~Mech.$ $\textbf{262}$ 205
(1994); $SIAM~J.~Appl.~Math.$ ${\bf 60}$, 1997 (2000)], which has served as the
basis for understanding singularity formation in droplet pinchoff, is derived
within the present formalism as the leading order term in an asymptotic
analysis for long slender axisymmetric vortex sheets, and should provide the
starting point for a rigorous analysis of singularity formation.

Combining ideas from [Alouges et al. (Numer. Math., 128, 2014)] and
[Praetorius et al. (Comput. Math. Appl., 2017)], we propose a numerical
algorithm for the integration of the nonlinear and time-dependent
Landau-Lifshitz-Gilbert (LLG) equation which is unconditionally convergent,
formally (almost) second-order in time, and requires only the solution of one
linear system per time-step. Only the exchange contribution is integrated
implicitly in time, while the lower-order contributions like the
computationally expensive stray field are treated explicitly in time. Then, we
extend the scheme to the coupled system of the Landau-Lifshitz-Gilbert equation
with the eddy current approximation of Maxwell equations (ELLG). Unlike
existing schemes for this system, the new integrator is unconditionally
convergent, (almost) second-order in time, and requires only the solution of
two linear systems per time-step.

The presence of exotic states of matter in neutron stars (NSs) is currently
an open issue in physics. The appearance of muons, kaons, hyperons, and other
exotic particles in the inner regions of the NS, favored by energetic
considerations, is considered to be an effective mechanism to soften the
equation of state (EoS). In the so-called two-families scenario, the softening
of the EoS allows for NSs characterized by very small radii, which become
unstable and convert into a quark stars (QSs). In the process of conversion of
a NS into a QS material can be ablated by neutrinos from the surface of the
star. Not only neutron-rich nuclei, but also more exotic material, such as
hypernuclei or deconfined quarks, could be ejected into the atmosphere. In the
NS atmosphere, atoms like H, He, and C should exist, and attempts to model the
NS thermal emission taking into account their presence, with spectra modified
by the extreme magnetic fields, have been done. However, exotic atoms, like
muonic hydrogen $(p\,\mu^-)$ or the so-called Sigmium $(\Sigma^+\,e^-)$, could
also be present during the conversion process or in its immediate aftermath. At
present, analytical expressions of the wave functions and eigenvalues for these
atoms have been calculated only for H. In this work, we extend the existing
solutions and parametrizations to the exotic atoms $(p\,\mu^-)$ and
$(\Sigma^+\,e^-)$, making some predictions on possible transitions. Their
detection in the spectra of NS would provide experimental evidence for the
existence of hyperons in the interior of these stars.

Non-Abelian and non-adiabatic variants of Berry's geometric phase have been
pivotal in the recent advances in fault tolerant quantum computation gates,
while Berry's phase itself is at the heart of the study of topological phases
of matter. The geometrical and topological properties of the phase space of
spin$-1$ quantum states is richer than that of spin$-1/2$ quantum states and is
relatively unexplored. For instance, the spin vector of a spin-1 system, unlike
that of a spin$-1/2$ system, can lie anywhere on or inside the Bloch sphere
representing the phase space. Recently, a generalization of Berry's phase that
encapsulates the topology of spin-1 quantum states has been formulated in J.
Math. Phys., 59(6), 062105. This geometric phase includes loops that go inside
the Bloch sphere and is carried by the tensor of spin fluctuations, unlike
Berry's phase which is carried by the global phase of the quantum state.
Furthermore, due to a mathematical singularity at the center of the Bloch
sphere, the class of loops that pass through the center are called singular
loops and are significant because their geometric phase is non-Abelian. In
contrast with Berry's phase for spin$-1/2$ systems, whose properties come from
the topology of a sphere, the properties of singular loop geometric phases come
from the topology of the real projective plane $\mathbb{RP}^2$, which is more
non-trivial. Here we use coherent control of ultracold $^{87}$Rb atoms in an
optical trap to experimentally explore this geometric phase for singular loops
in a spin-1 quantum system.

The derivation of the time-dependent variational equations of the
Multi-Configuration Time-Dependent Hartree (MCTDH) method for high-dimensional
quantum propagation is revisited from the perspective of tangent space
projection methods. In this context, we focus on a recently introduced
algorithm [C. Lubich, Appl. Math. Res. eXpress 2015, 311 (2015), B. Kloss et
al., J. Chem. Phys. 146, 174107 (2017)] for the integration of the MCTDH
equations, which relies on a suitable splitting of the tangent space
projection. The new integrator circumvents the direct inversion of reduced
density matrices that appears in the standard method, by employing an auxiliary
set of non-orthogonal single-particle functions. Here, we formulate the new
algorithm and the underlying alternative form of the MCTDH equations in
conventional chemical physics notation, in a complementary fashion to the
tensor formalism used in the original work. Further, key features of the
integration scheme are highlighted.

The recent claim by Grebenev et al. [J. Phys. A: Math. Theor. 50, 435502
(2017)] that the inviscid 2D Lundgren-Monin-Novikov (LMN) equations on a zero
vorticity characteristic naturally would reveal local conformal invariance when
only analyzing these by means of a classical Lie-group symmetry approach, is
invalid and will be refuted in the present comment. To note is that within this
comment the (possible) existence of conformal invariance in 2D turbulence is
not questioned, only the conclusion as is given in Grebenev et al. (2017) and
their approach how this invariance was derived is what is being criticized and
refuted herein. In fact, the algebraic derivation for conformal invariance of
the 2D LMN vorticity equations in Grebenev et al. (2017) is flawed. A key
constraint of the LMN equations has been wrongly transformed. Providing the
correct transformation instead will lead to a breaking of the proclaimed
conformal group. The corrected version of Grebenev et al. (2017) just leads to
a globally constant scaling in the fields and not to a local one as claimed. In
consequence, since in Grebenev et al. (2017) only the first equation within the
infinite and unclosed LMN chain is considered, also different Lie-group
infinitesimals for the one- and two-point probability density functions (PDFs)
will result from this correction, replacing thus the misleading ones proposed.

Three-dimensional, compressible, magnetohydrodynamic turbulence of an
isothermal, self-gravitating fluid is analyzed using two-point statistics in
the asymptotic limit of large Reynolds numbers (both kinetic and magnetic).
Following an alternative formulation proposed by S. Banerjee and S. Galtier
(Phys. Rev. E,93, 033120, 2016) and S. Banerjee and S. Galtier (J. Phys. A,
Math. and Theor.,50, 015501, 2017), an exact relation has been derived for the
total energy transfer. This approach results in a simpler relation expressed
entirely in terms of mixed second-order structure functions. The kinetic,
thermodynamic, magnetic and gravitational contributions to the energy transfer
rate can be easily separated in the present form. By construction, the new
formalism includes such additional effects as global rotation, the Hall term in
the induction equation, etc. The analysis shows that solid-body rotation cannot
alter the energy flux rate of compressible turbulence. However, the
contribution of a uniform background magnetic field to the flux is shown to be
non-trivial unlike in the incompressible case. Finally, the compressible,
turbulent energy flux rate does not vanish completely due to simple alignments,
which leads to a zero turbulent energy flux rate in the incompressible case.

It is well-known that by placing judiciously chosen image point forces and
doublets to the Stokeslet above a flat wall, the no-slip boundary condition can
be conveniently imposed on the wall [Blake, J. R. Math. Proc. Camb. Philos.
Soc. 70(2), 1971: 303.]. However, to further impose periodic boundary
conditions on directions parallel to the wall usually involves tedious
derivations because single or double periodicity in Stokes flow may require the
periodic unit to have no net force, which is not satisfied by the well-known
image system. In this work we present a force-neutral image system. This
neutrality allows us to represent the Stokes image system in a universal
formulation for non-periodic, singly periodic and doubly periodic geometries.
This formulation enables the black-box style usage of fast kernel summation
methods. We demonstrate the efficiency and accuracy of this new image method
with the periodic kernel independent fast multipole method in both non-periodic
and doubly periodic geometries. We then extend this new image system to other
widely used Stokes fundamental solutions, including the Laplacian of the
Stokeslet and the Rotne-Prager-Yamakawa tensor.

We consider a hierarchy of relaxation models for two-phase flow. The models
are derived from the non-equilibrium Baer-Nunziato model, which is endowed with
relaxation source terms to drive it towards equilibrium. The source terms cause
transfer of volume, heat, mass and momentum due to differences between the
phases in pressure, temperature, chemical potential and velocity, respectively.
The subcharacteristic condition is closely linked to the stability of such
relaxation systems, and in the context of two-phase flow models, it implies
that the sound speed of an equilibrium system can never exceed that of the
relaxation system. Here, previous work by Fl{\aa}tten and Lund [Math. Models
Methods Appl. Sci., 21 (12), 2011, 2379--2407] and Lund [SIAM J. Appl. Math.
72, 2012, 1713--1741] is extended to encompass two-fluid models, i.e. models
with separately governed velocities for the two phases. Each remaining model in
the hierarchy is derived, and analytical expressions for the sound speeds are
presented. Given only physically fundamental assumptions, the subcharacteristic
condition is shown to be satisfied in the entire hierarchy, either in a weak or
in a strong sense.

Despite simplicity, the synchronous cellular automaton [D.A. Young, Math.
Biosci. 72, 51 (1984)] enables reconstructing basic features of patterns of
skin. Our extended model allows studying the formatting of patterns and their
temporal evolution also on the favourable and hostile environments. As a
result, the impact of different types of an environment is accounted for the
dynamics of patterns formation. The process is based on two diffusible
morphogens, the short-range activator and the long-range inhibitor, produced by
differentiated cells (DCs) represented as black pixels. For a neutral
environment, the extended model reduces to the original one. However, even the
reduced model is statistically sensitive to a type of the initial distribution
of DCs. To compare the impact of the uniform random distribution of DCs
(R-system) and the non-uniform distribution in the form of random
Gaussian-clusters (G-system), we chose inhibitor as the control parameter. To
our surprise, in the neutral environment, for the chosen inhibitor-value that
ensures stable final patterns, the average size of final G-populations is lower
than in the R-case. In turn, when we consider the favourable environment, the
relatively bigger shift toward higher final concentrations of DCs appears in
the G. Thus, in the suitably favourable environment, this order can be
reversed. Furthermore, the different critical values of the control parameter
for the R and the G suggest some dissimilarities in temporal evolution of both
systems. In particular, within the proper ranges of the critical values, their
oscillatory behaviours are different. The respective temporal evolutions are
illustrated by a few examples.

This paper is based on the complete classification of evolutionary scenarios
for the Moran process with two strategies given by Taylor et al. (B. Math.
Biol. 66(6): 1621--1644, 2004). Their classification is based on whether each
strategy is a Nash equilibrium and whether the fixation probability for a
single individual of each strategy is larger or smaller than its value for
neutral evolution. We improve on this analysis by showing that each
evolutionary scenario is characterized by a definite graph shape for the
fixation probability function. A second class of results deals with the
behavior of the fixation probability when the population size tends to
infinity. We develop asymptotic formulae that approximate the fixation
probability in this limit and conclude that some of the evolutionary scenarios
cannot exist when the population size is large.

Using some rigorous results by Wiener [(1930). {\em Acta Math.} {\bf 30},
118-242] on the Fourier integral of a bounded function and the condition that
small-angle scattering intensities of amorphous samples are almost everywhere
continuous, we obtain the conditions that must be obeyed by a function
$\eta(\br)$ for this may be considered a physical scattering density
fluctuation. It turns out that these conditions can be recast in the form that
the $V\to\infty$ limit of the modulus of the Fourier transform of $\eta(\br)$,
evaluated over a cubic box of volume $V$ and divided by $\sqrt{V}$, exists and
that its square obeys the Porod invariant relation. Some examples of
one-dimensional scattering density functions, obeying the aforesaid condition,
are also numerically illustrated.

The full story of the Stern-Gerlach experiment and its reception,
interpretation and final understanding has many unexpected surprises. Here, we
review the history and the context of the proposal, the experiment, and the
subsequent story of the aftermath. We also discuss the story of the possible
Stern-Gerlach experiment for free electrons etc. Finally, we comment on the
remarkable career of Otto Stern.

In this short note we provide clarification to the comments made in Z. Angew.
Math. Phys. (2018) 69:64 on our work "Finiteness of corner vortices" [ Z.
Angew. Math. Phys. (2018) 69:37].

For a pulsating free surface source in a three-dimensional finite depth fluid
domain, the Green function of the source presented by John [F. John, On the
motion of floating bodies II. Simple harmonic motions, Communs. Pure Appl.
Math. 3 (1950) 45-101] is superposed as the Rankine source potential, an image
source potential and a wave integral in the infinite domain $(0, \infty)$. When
the source point together with a field point is on the free surface, John's
integral and its gradient are not convergent since the integration
$\int^\infty_\kappa$ of the corresponding integrands does not tend to zero in a
uniform manner as $\kappa$ tends to $\infty$. Thus evaluation of the Green
function is not based on direct integration of the wave integral but is
obtained by approximation expansions in earlier investigations. In the present
study, five images of the source with respect to the free surface mirror and
the water bed mirror in relation to the image method are employed to
reformulate the wave integral. Therefore the free surface Green function of the
source is decomposed into the Rankine potential, the five image source
potentials and a new wave integral, of which the integrand is approximated by a
smooth and rapidly decaying function. The gradient of the Green function is
further formulated so that the same integration stability with the wave
integral is demonstrated. The significance of the present research is that the
improved wave integration of the Green function and its gradient becomes
convergent. Therefore evaluation of the Green function is obtained through the
integration of the integrand in a straightforward manner. The application of
the scheme to a floating body or a submerged body motion in regular waves shows
that the approximation is sufficiently accurate to compute linear wave loads in
practice.

Entanglement in Quantum Field Theory is restricted to spacelike separations
to the order of the Compton wavelength $\hbar/mc$ (e.g., S. J. Summers and R.
Werner, {\it J. Math. Phys.}, {\bf 28}, 10,2440-2447, (1987)). Yet spin
entanglement of electrons across macroscopic distances has been observed by
Hensen { \it et al.} ({\it Nature}, {\bf 526}, doi:10.1038/nature/15759,
(2015)). The parametrized relativistic quantum mechanics of Feynman and
Stueckelberg admits spin singlets, across arbitrary separations, by providing a
single covariant wave equation for tensor products of two Dirac spinors (A. F.
Bennett, {\it Ann. Phys.} {\bf 345}, 1-16 (2014)). The formalism is extended
here from quantum electrodynamics to the electroweak interaction. A
relativistic Bell's inequality for Dirac spinors is extended here to weak
isospin.

A recent paper by A.~Z.~Janda [J.~Math.~Phys.~{\bf 59}, 061509 (2018)]
presented a partial solution of the equations of dissipationless Hall
magnetohydrodynamics (MHD) in terms of the Weierstrass elliptic function.
Unfortunately, an error crept up in the analysis, where the kinetic and
potential energies of the initial Hall MHD state were misidentified. The
present comment presents the correct energy analysis and offers a complete
solution of dissipationless Hall magnetohydrodynamics in terms of the Jacobi
elliptic functions.

Motivation: Surface generation and visualization are some of the most
important tasks in biomolecular modeling and computation. Eulerian solvent
excluded surface (ESES) software provides analytical solvent excluded surface
(SES) in the Cartesian grid, which is necessary for simulating many
biomolecular electrostatic and ion channel models. However, large biomolecules
and/or fine grid resolutions give rise to excessively large memory requirements
in ESES construction. We introduce an out-of-core and parallel algorithm to
improve the ESES software.
  Results: The present approach drastically improves the spatial and temporal
efficiency of ESES. The memory footprint and time complexity are analyzed and
empirically verified through extensive tests with a large collection of
biomolecule examples. Our results show that our algorithm can successfully
reduce memory footprint through a straightforward divide-and-conquer strategy
to perform the calculation of arbitrarily large proteins on a typical commodity
personal computer. On multi-core computers or clusters, our algorithm can
reduce the execution time by parallelizing most of the calculation as disjoint
subproblems. Various comparisons with the state-of-the-art Cartesian grid based
SES calculation were done to validate the present method and show the improved
efficiency. This approach makes ESES a robust software for the construction of
analytical solvent excluded surfaces.
  Availability and implementation: http://weilab.math.msu.edu/ESES.

Liquid droplets sliding along solid surfaces are a frequently observed
phenomenon in nature, e.g., raindrops on a leaf, and in everyday situations,
e.g., drops of water in a drinking glass. To model this situation, we use a
phase field approach. The bulk model is given by the thermodynamically
consistent Cahn-Hilliard Navier-Stokes model from [Abels et al., Math. Mod.
Meth. Appl. Sc., 22(3), 2012]. To model the contact line dynamics we apply the
generalized Navier boundary condition for the fluid and the dynamically
advected boundary contact angle condition for the phase field as derived in
[Qian et al., J. Fluid Mech., 564, 2006]. In recent years several schemes were
proposed to solve this model numerically. While they widely differ in terms of
complexity, they all fulfill certain basic properties when it comes to
thermodynamic consistency. However, an accurate comparison of the influence of
the schemes on the moving contact line is rarely found. Therefore, we
thoughtfully compare the quality of the numerical results obtained with three
different schemes and two different bulk energy potentials. Especially, we
discuss the influence of the different schemes on the apparent contact angles
of a sliding droplet.

This paper presents a homogenisation-based constitutive model to describe the
effective tran- sient diffusion behaviour in heterogeneous media in which there
is a large contrast between the phase diffusivities. In this case mobile
species can diffuse over long distances through the fast phase in the time
scale of diffusion in the slow phase. At macroscopic scale, contrasted phase
diffusivities lead to a memory effect that cannot be properly described by
classical Fick's second law. Here we obtain effective governing equations
through a two-scale approach for composite materials consisting of a fast
matrix and slow inclusions. The micro-macro transition is similar to
first-order computational homogenisation, and involves the solution of a
transient diffusion boundary-value problem in a Representative Volume Element
of the microstructure. Different from computational homogenisation, we propose
a semi-analytical mean-field estimate of the composite response based on the
exact solution for a single inclusion developed in our previous work [Brassart,
L., Stainier, L., 2018. Effective transient behaviour of inclusions in
diffusion problems. Z. Angew Math. Mech. 98, 981-998]. A key outcome of the
model is that the macroscopic concentration is not one-to-one related to the
macroscopic chemical potential, but obeys a local kinetic equation associated
with diffusion in the slow phase. The history-dependent macroscopic response
admits a representation based on internal variables, enabling efficient time
integration. We show that the local chemical kinetics can result in non-Fickian
behaviour in macroscale boundary-value problems.

A classic problem in general relativity, long studied by both physicists and
philosophers of physics, concerns whether the geodesic principle may be derived
from other principles of the theory, or must be posited independently. In a
recent paper [Geroch & Weatherall, "The Motion of Small Bodies in Space-Time",
Comm. Math. Phys. (forthcoming)], Bob Geroch and I have introduced a new
approach to this problem, based on a notion we call "tracking". In the present
paper, I situate the main results of that paper with respect to two other,
related approaches, and then make some preliminary remarks on the
interpretational significance of the new approach. My main suggestion is that
"tracking" provides the resources for eliminating "point particles"---a
problematic notion in general relativity---from the geodesic principle
altogether.

Previously (A. Akhmeteli, J. Math. Phys., v. 52, p. 082303 (2011)), the Dirac
equation in an arbitrary electromagnetic field was shown to be generally
equivalent to a fourth-order equation for just one component of the
four-component Dirac spinor function, and the remaining component can be made
real by a gauge transformation. This work extends the result to the case of the
Dirac equation in the Yang-Mills field.

This paper discusses the generalised least-action principle introduced by
Brenier (J. Am. Math. Soc, 1989), from the perspective of turbulence modelling.
In essence, Brenier's least-action principle extends to a probabilistic setting
Arnold's geometric interpretation of ideal fluid mechanics, whereby strong
solutions to the Euler equations are deduced from minimising an action over
Lagrangian maps. While Arnold's framework relies on the deterministic concept
of Lagrangian flow, Brenier's least-action principle describes solutions to the
Euler equations in terms of non-deterministic "generalised flows", namely
probability measures over sets of Lagrangian trajectories. Generalised flows
seem naturally fit to describe turbulent Lagrangian trajectories in terms of
stochastic processes, an approach that originates from Richardson's seminal
work on turbulent dispersion. In particular, they seem suited to address cases
when the concept of Lagrangian flow breaks down, due to Lagrangian trajectories
becoming spontaneously stochastic. The purpose of the present paper is
therefore to give a physical perspective on Brenier's principle, and provide a
qualitative description of the hydrodynamical features of generalised flows.
Using Monte-Carlo techniques, we analyse the statistical features of three
classes of two-dimensional generalised flows, ranging from solid rotation and
cellular flows to to freely decaying two-dimensional turbulence. Our results
suggest that generalised variational formulations, if carefully used, may
provide new tools to coarse-grain multi-scale hydrodynamics.

The method of approximate automodel solution for the Green's function of the
time-dependent superdiffusive (nonlocal) transport equations (J. Phys. A: Math.
Theor. 49 (2016) 255002) is extended to the case of a finite velocity of
carriers. This corresponds to extension from the L\'evy flights-based transport
to the transport of the type, which belongs to the class of "L\'evy walk +
rests", to allow for the retardation effects in the L\'evy flights. This
problem covers the cases of the transport by the resonant photons in
astrophysical gases and plasmas, heat transport by electromagnetic waves in
plasmas, migration of predators, and other applications. We treat a model case
of one-dimensional transport on a uniform background with a simple power-law
step-length probability distribution function (PDF). A solution for arbitrary
superdiffusive PDF is suggested, and the verification of solution for a
particular power law PDF, which corresponds, e.g., to the Lorentzian wings of
atomic spectral line shape for emission of photons, is carried out using the
computation of the exact solution.

In this paper, we proposed a novel method using the elementary number theory
to investigate the discrete nature of the screw dislocations in crystal
lattices, simple cubic (SC) lattice and body centered cubic (BCC) lattice, by
developing the algebraic description of the dislocations in the previous report
(Hamada, Matsutani, Nakagawa, Saeki, Uesaka, Pacific J. Math.~for Industry
{\bf{10}} (2018), 3). Using the method, we showed that the stress energy of the
screw dislocations in the BCC lattice and the SC lattice are naturally
described; the energy of the BCC lattice was expressed by the truncated
Epstein-Hurwitz zeta function of the Eisenstein integers, whereas that of SC
lattice is associated with the truncated Epstein-Hurwitz zeta function of the
Gauss integers.

In a previous paper [Adv. Appl. Math. Mech. 10 (2018), pp. 1025-1056], we
used the Buchwald representation to construct several families of separable
cylindrical solutions to the Navier-Lam\'{e} equation; these solutions had the
property of being $2\pi$-periodic in the circumferential coordinate. In this
paper, we extend the analysis and obtain the complementary set of separable
solutions whose circumferential parts are elementary $2\pi$-aperiodic
functions. Collectively, we construct eighteen distinct families of separable
solutions; in each case, the circumferential part of the solution is one of
three elementary $2\pi$-aperiodic functions. These solutions are useful for
solving a wide variety of dynamical problems that involve cylindrical
geometries and for which $2\pi$-periodicity in the angular coordinate is
incompatible with the given boundary conditions. As illustrative examples, we
show how the obtained solutions can be used to solve certain forced-vibration
problems involving open cylindrical shells and open solid cylinders where (by
virtue of the boundary conditions) $2\pi$-periodicity in the angular coordinate
is inappropriate. As an addendum to our prior work, we also include an
illustrative example of a certain type of asymmetric problem that can be solved
using the particular $2\pi$-periodic subsolutions that ensue when there is no
explicit dependence on the circumferential coordinate.

We demonstrate that the asymptotic approximant applied to the Blasius
boundary layer flow over a flat plat (Barlow et al., 2017 Q. J. Mech. Appl.
Math., 70(1): 21-48) yields accurate analytic closed-form solutions to the
Falkner-Skan boundary layer equation for flow over a wedge having angle
$\beta\pi/2$ to the horizontal. A wide range of wedge angles satisfying
$\beta\in[-0.198837735, 1]$ are considered, and the previously established
non-unique solutions for $\beta<0$ having positive and negative shear rates
along the wedge are accurately represented. The approximant is used to
determine the singularities in the complex plane that prescribe the radius of
convergence of the power series solution to the Falkner-Skan equation. An
attractive feature of the approximant is that it may be constructed quickly by
recursion compared with traditional Pad\'e approximants that require a matrix
inversion. The accuracy of the approximant is verified by numerical solutions,
and benchmark numerical values are obtained that characterize the asymptotic
behavior of the Falkner-Skan solution at large distances from the wedge.

Solitons on a finite a background, also called breathers, are solutions of
the focusing nonlinear Schr\"odinger equation, which play a pivotal role in the
description of rogue waves and modulation instability. The breather family
includes Akhmediev breathers (AB), Kuznetsov-Ma (KM), and Peregrine solitons
(PS), which have been successfully exploited to describe several physical
effects. These families of solutions are actually only particular cases of a
more general three-parameter class of solutions originally derived by
Akhmediev, Eleonskii and Kulagin [Theor. Math. Phys. {\bf 72}, 809--818
(1987)]. Having more parameters to vary, this significantly wider family has a
potential to describe many more physical effects of practical interest than its
subsets mentioned above. The complexity of this class of solutions prevented
researchers to study them deeply. In this paper, we overcome this difficulty
and report several new effects that follow from more detailed analysis. Namely,
we present the doubly periodic solutions and their Fourier expansions. In
particular, we outline some striking properties of these solutions. Among the
new effects, we mention (a) regular and shifted recurrence, (b) period doubling
and (c) amplification of small periodic perturbations with frequencies outside
the conventional modulation instability gain band.

The action principle by Low [Proc. R. Soc. Lond. A 248, 282--287] for the
classic Vlasov-Maxwell system contains a mix of Eulerian and Lagrangian
variables. This renders the Noether analysis of reparametrization symmetries
inconvenient, especially since the well-known energy- and momentum-conservation
laws for the system are expressed in terms of Eulerian variables only. While an
Euler-Poincar\'e formulation of Vlasov-Maxwell-type systems, effectively
starting with Low's action and using constrained variations for the Eulerian
description of particle motion, has been known for a while [J. Math. Phys., 39,
6, pp. 3138-3157], it is hard to come by a documented derivation of the related
energy- and momentum-conservation laws in the spirit of the Euler-Poincar\'e
machinery. To our knowledge only one such derivation exists in the literature
so far, dealing with the so-called guiding-center Vlasov-Darwin system [Phys.
Plasmas 25, 102506]. The present exposition discusses a generic class of local
Vlasov-Maxwell-type systems, with a conscious choice of adopting the language
of differential geometry to exploit the Euler-Poincar\'e framework to its full
extent. After reviewing the transition from a Lagrangian picture to an Eulerian
one, we demonstrate how symmetries generated by isometries in space lead to
conservation laws for linear- and angular-momentum density and how symmetry by
time translation produces a conservation law for energy density. We also
discuss what happens if no symmetries exist. Finally, two explicit examples
will be given -- the classic Vlasov-Maxwell and the drift-kinetic
Vlasov-Maxwell -- and the results expressed in the language of regular vector
calculus for familiarity.

Motivated by renewed interest in the physics of branched polymers, we present
here a complete characterization of the connectivity and spatial properties of
$2$ and $3$-dimensional single-chain conformations of randomly branching
polymers in $\theta$-solvent conditions obtained by Monte Carlo computer
simulations. The first part of the work focuses on polymer average properties,
like the average polymer spatial size as a function of the total tree mass and
the typical length of the average path length on the polymer backbone. In the
second part, we move beyond average chain behavior and we discuss the complete
distribution functions for tree paths and tree spatial distances, which are
shown to obey the classical Redner-des Cloizeaux functional form. Our results
were rationalized first by the systematic comparison to a Flory theory for
branching polymers and, next, by generalized Fisher-Pincus relationships
between scaling exponents of distribution functions. For completeness, the
properties of $\theta$-polymers were compared to their ideal (i.e.), no volume
interactions) as well as good-solvent (i.e.), above the $\theta$-point)
counterparts. The results presented here brings to conclusion the recent work
performed in our group [A. Rosa and R. Everaers, J. Phys. A: Math. Theor. 49,
345001 (2016), J. Chem. Phys. 145, 164906 (2016), Phys. Rev. E 95, 012117
(2017)] in the context of the scaling properties of branching polymers.

In this work we prove that the solution of the Serre-Green-Naghdi equation
cannot be globally defined when the interface reaches the impervious bottom
tangentially. As a consequence, our result complements the paper \emph{Camassa,
R., Falqui, G., Ortenzi, G., Pedroni, M., \& Thomson, C. Hydrodynamic models
and confinement effects by horizontal boundaries. Journal of Nonlinear Science,
29(4), 1445-1498, 2019.} Furthermore, we also prove that the solution to the
$abcd-$Boussinesq system can change sign in finite time. Finally, we provide
with a proof of a scenario of finite time singularity for the $abcd-$Boussinesq
system. These latter mathematical results are related to the numerics in
\emph{Bona, \& Chen, Singular solutions of a Boussinesq system for water waves.
J. Math. Study, 49(3), 205-220, 2016}.

We present a general method for solving the modified Helmholtz equation
without shape approximation for an arbitrary periodic charge distribution,
whose solution is known as the Yukawa potential or the screened Coulomb
potential. The method is an extension of Weinert's pseudo-charge method [M.
Weinert, J. Math. Phys. 22, 2433 (1981)] for solving the Poisson equation for
the same class of charge density distributions. The inherent differences
between the Poisson and the modified Helmholtz equation are in their respective
radial solutions. These are polynomial functions, for the Poisson equation, and
modified spherical Bessel functions, for the modified Helmholtz equation. This
leads to a definition of a modified pseudo-charge density and modified
multipole moments. We have shown that Weinert's convergence analysis of an
absolutely and uniformly convergent Fourier series of the pseudo-charge density
is transferred to the modified pseudo-charge density. We conclude by
illustrating the algorithmic changes necessary to turn an available
implementation of the Poisson solver into a solver for the modified Helmholtz
equation.

This article discusses several erroneous claims which appear in textbooks on
numerical methods and computational physics. These are not typos or mistakes an
individual author has made, but widespread misconceptions. In an attempt to
stop these issues from further propagating, we discuss them here, along with
some background comments. In each case, we also provide a correction, which is
aimed at summarizing material that is known to experts but is frequently
mishandled in the introductory literature. To make the mistakes and corrections
easy to understand, we bring up specific examples drawn from elementary physics
and math. We also take this opportunity to provide pointers to the specialist
literature for readers who wish to delve into a given topic in more detail.

We extend a method (E. Canc\`es and L.R. Scott, SIAM J. Math. Anal., 50,
2018, 381--410) to compute more terms in the asymptotic expansion of the van
der Waals attraction between two hydrogen atoms. These terms are obtained by
solving a set of modified Slater-Kirkwood partial differential equations. The
accuracy of the method is demonstrated by numerical simulations and comparison
with other methods from the literature. It is also shown that the scattering
states of the hydrogen atom, that are the states associated with the continuous
spectrum of the Hamiltonian, have a major contribution to the C$_6$ coefficient
of the van der Waals expansion.

We investigate student comfort with the material in an upper-division
spins-first quantum mechanics course. Pre-lecture surveys probing students'
comfort were administered weekly, in which students assigned themselves a
"discomfort level" on a scale of 0--10 and provided a written explanation for
their choice. The weekly class-wide average discomfort level was effectively
constant over the semester, suggesting that the class found no single unit
especially jarring nor especially easy. Student written responses were coded
according to their reported source of discomfort---math, math-physics
connection, physics, and notation. The relative prevalence of these categories
varied significantly over the semester, indicating that students find that
different units present different challenges, and also that some of these
challenges fade in importance as the semester progresses. Semi-structured
interviews with students in a similar quantum mechanics course at a different
institution provided additional context and insight into these results.

The current claim by Grebenev et al. [J. Phys. A: Math. Theor. 52, 335501
(2019)], namely that the inviscid and unclosed 2D Lundgren-Monin-Novikov (LMN)
equations on a zero-vorticity Lagrangian path admit conformal invariance, is
based on a flawed and misleading analysis published earlier by Grebenev et al.
(2017). All false results and conclusions made before in the Eulerian picture
were now extended by Grebenev et al. (2019) to the Lagrangian picture. Although
we have already commented on these errors and consistently refuted their
previous study (Frewer & Khujadze, 2018), we deem it necessary to address and
discuss these errors again in the new formulation and notation of Grebenev et
al. (2019) as it will offer new insights into this issue.

The Native Skywatchers programming addresses the loss of Ojibwe and Dakota
star knowledge. The goal is to help preserve indigenous astronomy and pass it
on to future generations. The star knowledge will serve as a cornerstone
inspiration for native communities and at the same time be influential to
Native students interested in science and math. Presented here is the Ojibwe
Giizhig Anung Masinaaigan-Ojibwe Sky Star Map created by Annette Lee and
collaborators as part of the Native Skywatchers Middle School Teachers Workshop
held June 2012.

The key difference between math as math and math in science is that in
science we blend our physical knowledge with our knowledge of math. This
blending changes the way we put meaning to math and even to the way we
interpret mathematical equations. Learning to think about physics with math
instead of just calculating involves a number of general scientific thinking
skills that are often taken for granted (and rarely taught) in physics classes.
In this paper, I give an overview of my analysis of these additional skills. I
propose specific tools for helping students develop these skills in subsequent
papers.

Making meaning with math in physics requires blending physical conceptual
knowledge with mathematical symbology. Students in introductory physics classes
often struggle with this, but it is an essential component of learning how to
think with math. Teaching dimensional analysis (DA). figuring out what
measurements were combined to create a symbolic quantity, is a valuable first
step in helping them learn to appreciate this difference. In this paper I
discuss some of the issues associated with learning dimensional analysis and
show some ways we can modify our instruction to help. This paper is one of a
series on how to help students develop the scientific thinking skills required
for learning to use math in science.

To further confirm the causality and stability of a second-order hyperbolic
system of partial differential equations that models the relativistic dynamics
of barotropic fluids with viscosity and heat conduction (H. Freist\"uhler and
B. Temple, J. Math. Phys. 59 (2018)), this paper studies the Fourier-Laplace
modes of this system and shows that all such modes, relative to arbitrary
Lorentz frames, (a) decay with increasing time and (b) travel at subluminal
speeds. Stability is also shown for the related model of non-barotropic fluids
(H. Freist\"uhler and B. Temple. Proc. R. Soc. A 470 (2014) and Proc. R. Soc. A
473 (2017)). Even though these properties had been known for a while in the
sense of numerical evidence, the fully analytical proofs for the subluminality
of modes of arbitrary wave numbers in arbitrary frames given here appear to be
the first regarding any five-field formulation of dissipative relativistic
fluid dynamics.

Recently, we have determined the spectrum and the wave functions of the
Hamiltonian of a Landau particle with time-dependent mass and frequency
undergoing the influence of a uniform time-dependent electric field[J. Math.
Phys. 56, 072104 (2018)]. In the present paper we extend the study of this
model that we name the time-dependent Landau problem into the context of
coherent states. By means of the traditional factorization method of the
eigenfunctions of this system expressed in terms of the generalized Laguerre
polynomials, we derive the generators of the su(1,1) Lie algebra and we
construct the coherent states a la Barut-Girardello. These states are shown to
satisfy the Klauder's mathematical requirement to build coherent states and
some of their statistical properties are calculated and analyzed. We find that
these states are sub-Poissonian in nature. We show that, addition of photons
from these coherent states, increases the statistical properties and changes
the mathematical properties of these states.

On the idea of mapped WENO-JS scheme, properties of mapping methods are
analyzed, uncertainties in mapping development are investigated, and new
rational mappings are proposed. Based on our former understandings, i.e.
mapping at endpoints {0, 1} tending to identity mapping, an integrated Cm,n
condition is summarized for function development. Uncertainties, i.e., whether
the mapping at endpoints would make mapped scheme behave like WENO or ENO,
whether piecewise implementation would entail numerical instability, and
whether WENO3-JS could preserve the third-order at first-order critical points
by mapping, are analyzed and clarified. A new piecewise rational mapping with
sufficient regulation capability is developed afterwards, where the flatness of
mapping around the linear weights and its endpoint convergence toward identity
mapping can be coordinated explicitly and simultaneously. Hence, the increase
of resolution and preservation of stability can be balanced. Especially,
concrete mappings are determined for WENO3,5,7-JS. Numerical cases are tested
for the new mapped WENO-JS, which regards numerical stability including that in
long time computation, resolution and robustness. In purpose of comparison,
some recent mappings such as IM by [App. Math. Comput. 232, 2014:453-468], RM
by [J. Sci. Comput. 67, 2016:540-580] and AIM by [J. Comput. Phys. 381,
2019:162-188] are chosen; in addition, some recent WENO-Z type scheme are
selected also. Proposed new schemes can preserve optimal orders at
corresponding critical points, achieve numerical stability and indicate overall
comparative advantages regarding accuracy, resolution and robustness.

Steady plasma flows have been studied almost exclusively in systems with
continuous symmetry or in open domains. In the absence of continuous symmetry,
the lack of a conserved quantity makes the study of flows intrinsically
challenging. In a toroidal domain, the requirement of double-periodicity for
physical quantities adds to the complications. In particular, the
magnetohydrodynamics (MHD) model of plasma steady-state with the flow in a
non-symmetric toroidal domain allows the development of singularities when the
rotational transform of the magnetic field is rational, much like the
equilibrium MHD model. In this work, we show that steady flows can still be
maintained provided the rotational transform is close to rational and the
magnetic shear is weak. We extend the techniques developed in carrying out
perturbation methods to all orders for static MHD equilibrium by Weitzner
(Physics of Plasmas 21, 022515 (2014)) to MHD equilibrium with flows. We
construct perturbative MHD equilibrium in a doubly-periodic domain with nearly
parallel flows by systematically eliminating magnetic resonances order by
order. We then utilize an additional symmetry of the flow problem, first
discussed by E. Hameiri in (J. Math. Phys. \textbf{22}, 2080 (1981) Sec. III),
to obtain a generalized Grad-Shafranov equation for a class of non-symmetric
three-dimensional MHD equilibrium with flows both parallel and perpendicular to
the magnetic field. For this class of flows, we are able to obtain
non-symmetric generalizations of integrals of motion, such as Bernoulli's
function and angular momentum. Finally, we obtain the generalized Hamada
conditions, which are consistency conditions necessary to suppress singular
currents in such a system when the magnetic field lines are closed. We do not
attempt to address the question of neoclassical damping of flows.

In our earlier publication we introduced the Spectrally Integrated Voigt
Function (SIVF) as an alternative to the traditional Voigt function for the
HITRAN-based applications [Quine & Abrarov, JQSRT 2013]. It was shown that
application of the SIVF enables us to reduce spectral resolution without loss
of accuracy in computation of the spectral radiance. As a further development,
in this study we present more efficient SIVF approximations derived by using a
new sampling method based on incomplete cosine expansion of the sinc function
[Abrarov & Quine, Appl. Math. Comput. 2015]. Since the SIVF mathematically
represents the mean value integral of the Voigt function, this method accounts
for area under the curve of the Voigt function. Consequently, the total band
radiance, defined as the integrated spectral radiance within a given spectral
region, can also retain its accuracy even at low spectral resolution. Our
numerical results demonstrate that application of the SIVF may be promising for
more rapid line-by-line computation in atmospheric models utilizing the HITRAN
molecular spectroscopic database. Such an approach may be particularly
efficient to implement a retrieval algorithm for the greenhouse gases from the
NIR space data collected by Earth-orbiting micro-spectrometers like Argus 1000
for their operation in a real-time mode. The real-time mode operation of the
micro-spectrometers can be advantageous for instant decision making during
flight for more efficient data collection from space.

We consider the thin-film equation $\partial_t h + \partial_y \left(m(h)
\partial_y^3 h\right) = 0$ in $\{h > 0\}$ with partial-wetting boundary
conditions and inhomogeneous mobility of the form $m(h) =
h^3+\lambda^{3-n}h^n$, where $h \ge 0$ is the film height, $\lambda > 0$ is the
slip length, $y > 0$ denotes the lateral variable, and $n \in (0,3)$ is the
mobility exponent parameterizing the nonlinear slip condition. The
partial-wetting regime implies the boundary condition $\partial_y h =
\mathrm{const.} > 0$ at the triple junction $\partial\{h > 0\}$ (nonzero
microscopic contact angle). Existence and uniqueness of traveling-wave
solutions to this problem under the constraint $\partial_y^2 h \to 0$ as $h \to
\infty$ have been proved in previous work by Chiricotto and Giacomelli in
[Commun. Appl. Ind. Math., 2(2):e-388, 16, 2011]. We are interested in the
asymptotics as $h \downarrow 0$ and $h \to \infty$. By reformulating the
problem as $h \downarrow 0$ as a dynamical system for the difference between
the solution and the microscopic contact angle, values for $n$ are found for
which linear as well as nonlinear resonances occur. These resonances lead to a
different asymptotic behavior of the solution as $h\downarrow0$ depending on
$n$.
  Together with the asymptotics as $h\to\infty$ characterizing the Cox-Voinov
law for the velocity-dependent macroscopic contact angle as found by
Giacomelli, the first author of this work, and Otto in [Nonlinearity,
29(9):2497-2536, 2016], the rigorous asymptotics of traveling-wave solutions to
the thin-film equation in partial wetting can be characterized. Furthermore,
our approach enables us to analyze the relation between the microscopic and
macroscopic contact angle. It is found that the Cox-Voinov law for the
macroscopic contact angle depends continuously differentiably on the
microscopic contact angle.

For ideal fluid flow with zero surface tension and gravity, it remains
unknown whether local singularities on the free surface can develop in
well-posed initial value problems with smooth initial data. This is so despite
great advances over the last 25 years in the mathematical analysis of the Euler
equations for water waves. Here we expand our earlier work (Chin. Ann. Math.
Ser. B 40 (2019) 925) and review the mathematical literature and some of the
history concerning Dirichlet's ellipsoids and related hyperboloids associated
with jet formation and "flip-through," "splash singularities," and recent
constructions of singular free surfaces that however violate the Taylor sign
condition for linear well-posedness. We illustrate some of these phenomena with
numerical computations of 2D flow based upon a conformal mapping formulation
(whose derivation is detailed and discussed in an appendix). Additional
numerical evidence strongly suggests that corner singularities may form in an
unstable self-similar way from specially prepared initial data.

Math anxiety is a clinical pathology impairing cognitive processing in
math-related contexts. Originally thought to affect only inexperienced,
low-achieving students, recent investigations show how math anxiety is vastly
diffused even among high-performing learners. This review of data-informed
studies outlines math anxiety as a complex system that: (i) cripples
well-being, self-confidence and information processing on both conscious and
subconscious levels, (ii) can be transmitted by social interactions, like a
pathogen, and worsened by distorted perceptions, (iii) affects roughly 20% of
students in 63 out of 64 worldwide educational systems but correlates weakly
with academic performance, and (iv) poses a concrete threat to students'
well-being, computational literacy and career prospects in science. These
patterns underline the crucial need to go beyond performance for estimating
math anxiety. Recent advances with network psychometrics and cognitive network
science provide ideal frameworks for detecting, interpreting and intervening
upon such clinical condition. Merging education research, psychology and data
science, the approaches reviewed here reconstruct psychological constructs as
complex systems, represented either as multivariate correlation models (e.g.
graph exploratory analysis) or as cognitive networks of semantic/emotional
associations (e.g. free association networks or forma mentis networks). Not
only can these interconnected networks detect otherwise hidden levels of math
anxiety but - more crucially - they can unveil the specific layout of
interacting factors, e.g. key sources and targets, behind math anxiety in a
given cohort. As discussed here, these network approaches open concrete ways
for unveiling students' perceptions, emotions and mental well-being, and can
enable future powerful data-informed interventions untangling math anxiety.

In a previous paper [Jayanti, P.C., Trivisa, K. Local Existence of Solutions
to a Navier-Stokes-Nonlinear-Schr\"odinger Model of Superfluidity. J. Math.
Fluid Mech. 24, 46 (2022)], the authors proved the existence of local-in-time
weak solutions to a model of superfluidity. The system of governing equations
was derived by Pitaevskii in 1959 and couples the nonlinear Schr\"odinger
equation (NLS) and the Navier-Stokes equations (NSE). In this article, we prove
a weak-strong type uniqueness theorem for these weak solutions. Only some of
their regularity properties are used, allowing room for improved existence
theorems in the future, with compatible uniqueness results.

Entropy-Stable (ES) schemes, specifically those built from [Tadmor
\textit{Math. Comput.} 49 (1987) 91], have been gaining interest over the past
decade, especially in the context of under-resolved simulations of compressible
turbulent flows using high-order methods. These schemes are attractive because
they can provide stability in a global and nonlinear sense (consistency with
thermodynamics). However, fully realizing the potential of ES schemes requires
a better grasp of their local behavior. Entropy-stability itself does not imply
good local behavior [Gouasmi \textit{et al.} \textit{J. Sci. Comp.} 78 (2019)
971, Gouasmi \textit{et al.} \textit{Comput. Methd. Appl. M.} 363 (2020)
112912]. In this spirit, we studied ES schemes in problems where \textit{global
stability is not the core issue}. In the present work, we consider the accuracy
degradation issues typically encountered by upwind-type schemes in the
low-Mach-number regime [Turkel \textit{Annu. Rev. Fluid Mech.} 31 (1999) 285]
and their treatment using \textit{Flux-Preconditioning} [Turkel \textit{J.
Comput. Phys.} 72 (1987) 277, Miczek \textit{et al.} \textit{A \& A} 576 (2015)
A50]. ES schemes suffer from the same issues and Flux-Preconditioning can
improve their behavior without interfering with entropy-stability. This is
first demonstrated analytically: using similarity and congruence transforms we
were able to establish conditions for a preconditioned flux to be ES, and
introduce the ES variants of the Miczek's and Turkel's preconditioned fluxes.
This is then demonstrated numerically through first-order simulations of two
simple test problems representative of the incompressible and acoustic limits,
the Gresho Vortex and a right-moving acoustic wave. The results are overall
consistent with previous studies [...]

Froth flotation is a common unit operation used in mineral processing. It
serves to separate valuable mineral particles from worthless gangue particles
in finely ground ores. The valuable mineral particles are hydrophobic and
attach to bubbles of air injected into the pulp. This creates bubble-particle
aggregates that rise to the top of the flotation column where they accumulate
to a froth or foam layer that is removed through a launder for further
processing. At the same time, the hydrophilic gangue particles settle and are
removed continuously. The drainage of liquid due to capillarity is essential
for the formation of a stable froth layer. This effect is included into a
previously formulated hyperbolic system of partial differential equations that
models the volume fractions of floating aggregates and settling hydrophilic
solids [R. B\"{u}rger, S. Diehl and M.C. Mart\'i, {\it IMA J. Appl. Math.} {\bf
84} (2019) 930--973]. The construction of desired steady-state solutions with a
froth layer is detailed and feasibility conditions on the feed volume fractions
and the volumetric flows of feed, underflow and wash water are visualized in
so-called operating charts. A monotone numerical scheme is derived and employed
to simulate the dynamic behaviour of a flotation column. It is also proven
that, under a suitable Courant-Friedrichs-Lewy (CFL) condition, the approximate
volume fractions are bounded between zero and one when the initial data are.

Z.E. Musielak has reported in 2008 J. Phys. A: Math. Theor. {\bf 41} 055205
methods to obtain standard and non-standard Lagrangians and identify classes of
equations of motion that admit a Lagrangian description. In this comment we
show how to obtain new non-standard Lagrangians using the non-standard
Lagrangians previously found. In particular, it is demonstrated that for every
non-standard Lagrangian one can generate a new non-standard Lagrangian
associated to a new equation of motion.

In this paper we investigate the homeostatic mechanism in two biologically
motivated models: intracellular copper regulation and self immune recognition.
The analysis is based on the notions of infinitesimal homeostasis and
near-perfect homeostasis. We introduce a theoretical background that makes it
possible to consider points of infinitesimal homeostasis that lie at the
boundary of the domain of definition of the input-output function. We show that
the two models display near-perfect homeostasis. Moreover, we show that, unlike
the examples of [M. Reed, J. Best, M. Golubitsky, I. Stewart, and H. F.
Nijhout. Analysis of homeostatic mechanisms in biochemical networks. Bull.
Math. Biol., 79(11):2534-2557, 2017], the obstruction of occurrence of
infinitesimal homeostasis in both of them is caused by the modeling assumptions
that force the point of infinitesimal homeostasis to lie at the boundary of
domain of definition of the respective input-output functions.

We consider the problem of "wall-to-wall optimal transport" in which we
attempt to maximize the transport of a passive temperature field between hot
and cold plates. Specifically, we optimize the choice of the divergence-free
velocity field in the advection-diffusion equation subject to an enstrophy
constraint (which can be understood as a constraint on the power required to
generate the flow). Previous work established an a priori upper bound on the
transport, scaling as the 1/3-power of the flow's enstrophy. Recently, Tobasco
& Doering (Phys. Rev. Lett. vol.118, 2017, p.264502}) and Doering & Tobasco
(Comm. Pure Appl. Math. vol.72, 2019, p.2385--2448}) constructed self-similar
two-dimensional steady branching flows saturating this bound up to a
logarithmic correction. This logarithmic correction appears to arise due to a
topological obstruction inherent to two-dimensional steady branching flows. We
present a construction of three-dimensional "branching pipe flows" that
eliminates the possibility of this logarithmic correction and therefore
identifies the optimal scaling as a clean 1/3-power law. Our flows resemble
previous numerical studies of the three-dimensional wall-to-wall problem by
Motoki, Kawahara & Shimizu (J. Fluid Mech. vol.851, 2018, p.R4}). We also
discuss the implications of our result to the heat transfer problem in
Rayleigh--B\'enard convection and the problem of anomalous dissipation in a
passive scalar.

We present $TimeEvolver$, a program for computing time evolution in a generic
quantum system. It relies on well-known Krylov subspace techniques to tackle
the problem of multiplying the exponential of a large sparse matrix $i H$,
where $H$ is the Hamiltonian, with an initial vector $v$. The fact that $H$ is
Hermitian makes it possible to provide an easily computable bound on the
accuracy of the Krylov approximation. Apart from effects of numerical roundoff,
the resulting a posteriori error bound is rigorous, which represents a crucial
novelty as compared to existing software packages such as $Expokit$ (R. Sidje,
ACM Trans. Math. Softw. 24 (1) 1998). On a standard notebook, $TimeEvolver$
allows to compute time evolution with adjustable precision in Hilbert spaces of
dimension greater than $10^6$. Additionally, we provide routines for deriving
the matrix $H$ from a more abstract representation of the Hamiltonian operator.

This work considers two linear operators which yield wave modes that are
classified as neutrally stable, yet have responses that grow or decay in time.
Previously, King et al. (Phys. Rev. Fluids, 1, 2016, 073604:1-19) and Huber et
al. (IMA J. Appl. Math., 85, 2020, 309-340) examined the one-dimensional (1D)
wave propagation governed by these operators. Here, we extend the linear
operators to two spatial dimensions (2D) and examine the resulting solutions.
We find that the increase of dimension leads to long-time behaviour where the
magnitude is reduced by a factor of $t^{\frac{-1}{2}}$ from the 1D solutions.
Thus, regions of the solution which grew algebraically as $t^{\frac{1}{2}}$ in
1D now are algebraically neutral in 2D, whereas regions which decay
(algebraically or exponentially) in 1D now decay more quickly in 2D.
Additionally, we find that these two linear operators admit long-time solutions
that are functions of the same similarity variable that contracts space and
time.

When surface-active molecules are released at a liquid interface, their
spreading dynamics is controlled by Marangoni flows. Though such Marangoni
spreading was investigated in different limits, exact solutions remain very
few. Here we consider the spreading of an insoluble surfactant along the
interface of a deep fluid layer. For two-dimensional Stokes flows, it was
recently shown that the non-linear transport problem can be exactly mapped to a
complex Burgers equation [Crowdy, SIAM J. Appl. Math. 81, 2526 (2021)]. We
first present a very simple derivation of this equation. We then provide fully
explicit solutions and find that varying the initial surfactant distribution -
pulse, hole, or periodic - results in distinct spreading behaviors. By
obtaining the fundamental solution, we also discuss the influence of surface
diffusion. We identify situations where spreading can be described as an
effective diffusion process but observe that this approximation is not
generally valid. Finally, the case of a three-dimensional flow with axial
symmetry is briefly considered. Our findings should provide reference solutions
for Marangoni spreading, that may be tested experimentally with fluorescent or
photoswitchable surfactants.

The chemical diffusion master equation (CDME) describes the probabilistic
dynamics of reaction--diffusion systems at the molecular level [del Razo et
al., Lett. Math. Phys. 112:49, 2022]; it can be considered the master equation
for reaction--diffusion processes. The CDME consists of an infinite ordered
family of Fokker--Planck equations, where each level of the ordered family
corresponds to a certain number of particles and each particle represents a
molecule. The equations at each level describe the spatial diffusion of the
corresponding set of particles, and they are coupled to each other via reaction
operators --linear operators representing chemical reactions. These operators
change the number of particles in the system, and thus transport probability
between different levels in the family. In this work, we present three
approaches to formulate the CDME and show the relations between them. We
further deduce the non-trivial combinatorial factors contained in the reaction
operators, and we elucidate the relation to the original formulation of the
CDME, which is based on creation and annihilation operators acting on
many-particle probability density functions. Finally we discuss applications to
multiscale simulations of biochemical systems among other future prospects.

We generalize the notion of quantum state designs to infinite-dimensional
spaces. We first prove that, under the definition of continuous-variable (CV)
state $t$-designs from Comm. Math. Phys. 326, 755 (2014), no state designs
exist for $t\geq2$. Similarly, we prove that no CV unitary $t$-designs exist
for $t\geq 2$. We propose an alternative definition for CV state designs, which
we call rigged $t$-designs, and provide explicit constructions for $t=2$. As an
application of rigged designs, we develop a design-based shadow-tomography
protocol for CV states. Using energy-constrained versions of rigged designs, we
define an average fidelity for CV quantum channels and relate this fidelity to
the CV entanglement fidelity. As an additional result of independent interest,
we establish a connection between torus $2$-designs and complete sets of
mutually unbiased bases.

In this paper, we develop a fully conservative, positivity-preserving, and
entropy-bounded discontinuous Galerkin scheme for simulating the chemically
reacting, compressible Euler equations with complex thermodynamics. The
proposed formulation is an extension of the conservative, high-order numerical
method previously developed by Johnson and Kercher [J. Comput. Phys., 423
(2020), 109826] that maintains pressure equilibrium between adjacent elements.
In this first part of our two-part paper, we focus on the one-dimensional case.
Our methodology is rooted in the minimum entropy principle satisfied by entropy
solutions to the multicomponent, compressible Euler equations, which was proved
by Gouasmi et al. [ESAIM: Math. Model. Numer. Anal., 54 (2020), 373--389] for
nonreacting flows. We first show that the minimum entropy principle holds in
the reacting case as well. Next, we introduce the ingredients required for the
solution to have nonnegative species concentrations, positive density, positive
pressure, and bounded entropy. We also discuss how to retain the aforementioned
ability to preserve pressure equilibrium between elements. Operator splitting
is employed to handle stiff chemical reactions. To guarantee satisfaction of
the minimum entropy principle in the reaction step, we develop an
entropy-stable discontinuous Galerkin method based on diagonal-norm
summation-by-parts operators for solving ordinary differential equations. The
developed formulation is used to compute canonical one-dimensional test cases,
namely thermal-bubble advection, multicomponent shock-tube flow, and a moving
hydrogen-oxygen detonation wave with detailed chemistry. We find that the
enforcement of an entropy bound can considerably reduce the large-scale
nonlinear instabilities that emerge when only the positivity property is
enforced, to an even greater extent than in the monocomponent, calorically
perfect case.

We experimentally investigate the behaviour of instantaneous localised
releases of heavy particles falling as turbulent clouds in quiescent water,
both with and without background rotation. We present the results of 514
systematic experiments for no rotation and for three rotation rates $\Omega =
5,10,20$rpm, and for the size of particles in the range $5\mu m$ to $1mm$,
exploring four decades of the Rouse number $\mathcal{R} \in [6\times
10^{-4},4]$ which quantifies the inertia of particles. In the canonical
framework of turbulent thermals described by Morton \textit{et al.}, [Proc. R.
Soc. A: Math. Phys. Sci. \textbf{234}, 1 (1956)], we compare particle clouds
with salt-water thermals to highlight specificities due to the particulate
nature of the turbulence forcing. In the absence of rotation, particle clouds
initially behave as salty thermals with a modulation of their entrainment
capacity, which is optimally enhanced for a finite inertia $\mathcal{R}\simeq
0.3$ due to particulate effects. However this regime of turbulence is limited
in time due to the inertial decoupling between turbulent eddies and particles.
For the three values of $\Omega$ explored here, the particulate enhancement of
entrainment is inhibited. Moreover the cloud's expansion is interrupted when
the Coriolis force overcomes its inertia, forcing the cloud to transform into
vortical columnar flows which considerably increase the residence time of
particles.

We study the tail of $p(U)$, the probability distribution of
$U=\vert\psi(0,L)\vert^2$, for $\ln U\gg 1$, $\psi(x,z)$ being the solution to
$\partial_z\psi -\frac{i}{2m}\nabla_{\perp}^2 \psi =g\vert S\vert^2\, \psi$,
where $S(x,z)$ is a complex Gaussian random field, $z$ and $x$ respectively are
the axial and transverse coordinates, with $0\le z\le L$, and both $m\ne 0$ and
$g>0$ are real parameters. We perform the first instanton analysis of the
corresponding Martin-Siggia-Rose action, from which it is found that the
realizations of $S$ concentrate onto long filamentary instantons, as $\ln U\to
+\infty$. The tail of $p(U)$ is deduced from the statistics of the instantons.
The value of $g$ above which $\langle U\rangle$ diverges coincides with the one
obtained by the completely different approach developed in Mounaix et al. 2006
{\it Commun. Math. Phys.} {\bf 264}~741. Numerical simulations clearly show a
statistical bias of $S$ towards the instanton for the largest sampled values of
$\ln U$. The high maxima -- or `hot spots' -- of $\vert S(x,z)\vert^2$ for the
biased realizations of $S$ tend to cluster in the instanton region.

The Sakiadis boundary layer induced by a moving wall in a semi-infinite fluid
domain is a fundamental laminar flow field relevant to high speed coating
processes. This work provides an analytical solution to the boundary layer
problem for Ostwald-de Waele power law fluids via a power series expansion, and
extends the approach taken for Newtonian fluids [Naghshineh et al., "On the use
of asymptotically motivated gauge functions to obtain convergent series
solutions to nonlinear ODEs", IMA J. of Appl. Math., (2023)] in which variable
substitutions (which naturally determine the gauge function in the power
series) are chosen to be consistent with the large distance behavior away from
the wall. Contrary to prior literature, the asymptotic behavior dictates that a
solution only exists in the range of power law exponents, $\alpha$, lying in
the range $0.5 < \alpha \leq 1$. An analytical solution is obtained in the
range of approximately $0.74 \leq \alpha < 1$, using a convergent power series
with an asymptotically motivated gauge function. For power laws corresponding
to $0.5 < \alpha<0.74$, the gauge function becomes ill-defined over the full
domain, and an approximate analytical solution is obtained using the method of
asymptotic approximants [Barlow et al., "On the summation of divergent,
truncated, and underspecified power series via asymptotic approximants", Q. J.
Mech. Appl. Math., (2017)]. The approximant requires knowledge of two physical
constants, which we compute a priori using a numerical shooting method on a
finite domain. The utility of the power series solution is that it can be
solved on the entire semi-infinite domain and--in contrast to a numerical
solution--does not require a finite domain length approximation and subsequent
domain length refinement.

Learning to use math in physics involves combining (blending) our everyday
experiences and the conceptual ideas of physics with symbolic mathematical
representations. Graphs are one of the best ways to learn to build the blend.
They are a mathematical representation that builds on visual recognition to
create a bridge between words and equations. But students in introductory
physics classes often see a graph as an endpoint, a task the teacher asks them
to complete, rather than as a tool to help them make sense of a physical
system. And most of the graph problems in traditional introductory physics
texts simply ask students to extract a number from a graph. But if graphs are
used appropriately, they can be a powerful tool in helping students learn to
build the blend and develop their physical intuition and ability to think with
math.

M.V. Berry's work [J. Phys. A: Math. Theor. 43, 415302 (2010)] highlighted
the correspondence between backflow in quantum mechanics and superoscillations
in waves. Superoscillations refer to situations where the local oscillation of
a superposition is faster than its fastest Fourier component. This concept has
been used to demonstrate backflow in transverse linear momentum for optical
waves. In this work, we examine the interference of classical light carrying
only negative orbital angular momentum and observe in the dark fringes of such
an interference, positive local orbital angular momentum. This finding may have
implications for the studies of light-matter interaction and represents a step
towards observing quantum backflow in two dimensions.

The ability to express scientific concepts in mathematical terms and
integrate scientific and mathematical reasoning about a phenomenon is a
foundational cognitive process involved in scientific thinking. This process
called blended math-science sensemaking (blended MSS) is a desired skill for
all STEM students, but few students are learning it, and there is little
research on how to teach it. In this work we introduce the development and
testing of a novel instructional method for teaching blended (MSS) that is
suitable for use in STEM courses in undergraduate and K-12 educational
settings. This study builds on our past work on developing and validating a
framework for characterizing in detail the cognitive levels involved in such
sensemaking. This work uses the unique power of interactive simulations for
assessing and developing blended MSS. We designed instructional activities to
help students use blended MSS in the contexts of heat capacity and Coulombs
law. The Heat Capacity activity was piloted in a freshmen Chemistry course and
the Coulombs law activity was piloted in a freshmen Physics course. The results
indicate that for students who came in with no knowledge of the relevant
equation the activity supported the development of both the equation, and their
understanding of the mathematical relationships of the equation. These results
indicate that the teaching approach helps students engage in blended MSS at
higher levels of cognitive complexity.

As students pursue a bachelor's degree in physics, they may ponder over which
area to specialize in, such as theory, computation, or experiment. Often
students develop preferences and dislikes, but it's unclear when this
preference solidifies during their undergraduate experiences. To get a better
understanding, we interviewed eighteen physics majors who were at different
stages of their degree regarding their interest in theory, computation, and
experimental methods. Out of the eighteen students, we chose to analyze only
nine students who rated computation and theory the lowest. Our analysis did not
include interest in experiment because the ratings were less negative. We used
Social Cognitive Career Theory (SCCT) and Lucidchart to analyze students'
responses and create individual graphical representations of the influences for
each student. Through this, we uncovered how various factors such as learning
experiences, self-efficacy, and outcome expectations influenced their low
interest in a particular method. We found that lack of knowledge and experience
is often the main reason why self-efficacy was lower. Students' lack of
interest is also influenced by negative outcome expectations (e.g,
math-intensive and a bad work-life balance) more than other SCCT factors. Our
findings could help physics departments and educators identify positive and
negative factors that could lead to a more motivating and inclusive physics
curriculum.

We further develop the concept of supergrowth [Jordan, Quantum Stud.: Math.
Found. $\textbf{7}$, 285-292 (2020)], a phenomenon complementary to
superoscillation, defined as the local amplitude growth rate of a function
being higher than its largest wavenumber. We identify the superoscillating and
supergrowing regions of a canonical oscillatory function and find the maximum
values of local growth rate and wavenumber. Next, we provide a quantitative
comparison of lengths and relevant intensities between the superoscillating and
the supergrowing regions of a canonical oscillatory function. Our analysis
shows that the supergrowing regions contain intensities that are exponentially
larger in terms of the highest local wavenumber compared to the
superoscillating regions. Finally, we prescribe methods to reconstruct a
sub-wavelength object from the imaging data using both superoscillatory and
supergrowing point spread functions. Our investigation provides an
experimentally preferable alternative to the superoscillation based
superresolution schemes and is relevant to cutting-edge research in far-field
sub-wavelength imaging.